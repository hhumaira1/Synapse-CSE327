generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ==================== ENUMS ====================

enum UserRole {
  ADMIN
  MANAGER
  MEMBER
}

enum TenantType {
  ORGANIZATION
  PERSONAL
  BUSINESS // Added for Supabase migration compatibility
}

enum LeadStatus {
  NEW
  CONTACTED
  QUALIFIED
  UNQUALIFIED
  CONVERTED
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  CLOSED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum TicketSource {
  INTERNAL
  PORTAL
  EMAIL
  API
}

enum InteractionType {
  EMAIL
  CALL
  MEETING
  NOTE
  TICKET
}

// ==================== MULTI-TENANT FOUNDATION ====================

model Tenant {
  id        String     @id @default(cuid())
  name      String
  slug      String     @unique
  domain    String? // Optional domain for tenant
  type      TenantType @default(ORGANIZATION)
  settings  Json?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  users           User[]
  contacts        Contact[]
  leads           Lead[]
  pipelines       Pipeline[]
  deals           Deal[]
  interactions    Interaction[]
  tickets         Ticket[]
  integrations    Integration[]
  callLogs        CallLog[]
  portalCustomers PortalCustomer[]
  userInvitations UserInvitation[]
  conversations   Conversation[] // Chatbot conversations

  @@map("tenants")
}

// ==================== INTERNAL CRM USERS ====================
// ARCHITECTURE: One internal user belongs to ONE tenant only
// Rationale: Simpler security model, matches 95% of CRM use cases
// For multi-company access (consultants/contractors), use PortalCustomer instead

model User {
  id              String   @id @default(cuid())
  tenantId        String   // User belongs to ONE tenant (their employer)
  supabaseUserId  String   @unique @map("supabase_user_id") // Supabase Auth user ID
  email           String   @unique // Global unique - one email = one internal user globally
  firstName       String?  @map("first_name")
  lastName        String?  @map("last_name")
  name            String?  // Deprecated - use firstName/lastName
  role            UserRole @default(MEMBER) // Role in THIS tenant
  isActive        Boolean  @default(true) // Soft delete support
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  tenant               Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  interactions         Interaction[]
  ticketsAssigned      Ticket[]             @relation("TicketAssignedUser")
  ticketComments       TicketComment[]      @relation("TicketComments")
  invitations          UserInvitation[]     // Invitations sent to users
  callLogs             CallLog[]            // Call logs made by this user
  conversations        Conversation[]       // Chatbot conversations
  telegramUsers        TelegramUser[]       // Telegram bot connections
  telegramLinkRequests TelegramLinkRequest[] // Telegram deep link requests

  @@unique([tenantId, supabaseUserId])
  @@index([tenantId])
  @@index([email]) // Fast lookup for global uniqueness check
  @@map("users")
}

// ==================== CORE CRM ENTITIES ====================

model Contact {
  id           String   @id @default(cuid())
  tenantId     String
  firstName    String
  lastName     String
  email        String?
  phone        String?
  company      String?
  jobTitle     String?
  source       String?
  notes        String?
  customFields Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  tenant          Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  leads           Lead[]
  interactions    Interaction[]
  deals           Deal[]
  tickets         Ticket[]
  callLogs        CallLog[]
  portalCustomers PortalCustomer[]

  @@index([tenantId])
  @@index([email])
  @@map("contacts")
}

model Lead {
  id          String     @id @default(cuid())
  tenantId    String
  contactId   String?
  title       String
  source      String
  status      LeadStatus @default(NEW)
  value       Decimal?
  notes       String?    @db.Text
  convertedAt DateTime?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  tenant  Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contact Contact? @relation(fields: [contactId], references: [id], onDelete: SetNull)
  deals   Deal[]

  @@index([tenantId])
  @@index([contactId])
  @@index([status])
  @@map("leads")
}

model Pipeline {
  id          String   @id @default(cuid())
  tenantId    String
  name        String
  description String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant Tenant  @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  stages Stage[]
  deals  Deal[]

  @@index([tenantId])
  @@map("pipelines")
}

model Stage {
  id         String   @id @default(cuid())
  pipelineId String
  name       String
  order      Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  pipeline Pipeline @relation(fields: [pipelineId], references: [id], onDelete: Cascade)
  deals    Deal[]

  @@unique([pipelineId, order])
  @@index([pipelineId])
  @@map("stages")
}

model Deal {
  id                String    @id @default(cuid())
  tenantId          String
  contactId         String
  leadId            String?
  pipelineId        String
  stageId           String
  title             String
  description       String?
  value             Decimal?
  probability       Decimal? // 0.0 to 1.0
  expectedCloseDate DateTime?
  notes             String?    @db.Text
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contact      Contact       @relation(fields: [contactId], references: [id], onDelete: Restrict)
  lead         Lead?         @relation(fields: [leadId], references: [id], onDelete: SetNull)
  pipeline     Pipeline      @relation(fields: [pipelineId], references: [id], onDelete: Restrict)
  stage        Stage         @relation(fields: [stageId], references: [id], onDelete: Restrict)
  interactions Interaction[]
  tickets      Ticket[]
  callLogs     CallLog[]

  @@index([tenantId])
  @@index([contactId])
  @@index([leadId])
  @@index([pipelineId])
  @@index([stageId])
  @@map("deals")
}

model Interaction {
  id        String          @id @default(cuid())
  tenantId  String
  contactId String
  dealId    String?
  userId    String?
  type      InteractionType
  subject   String?
  content   String
  dateTime  DateTime        @default(now())
  createdAt DateTime        @default(now())
  updatedAt DateTime        @updatedAt

  tenant  Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contact Contact  @relation(fields: [contactId], references: [id], onDelete: Cascade)
  deal    Deal?    @relation(fields: [dealId], references: [id], onDelete: SetNull)
  user    User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([contactId])
  @@index([dealId])
  @@index([userId])
  @@index([type])
  @@map("interactions")
}

// ==================== TICKETS / ISSUE TRACKING ====================

model Ticket {
  id                        String         @id @default(cuid())
  tenantId                  String
  contactId                 String
  portalCustomerId          String?
  dealId                    String?
  externalId                String?
  externalSystem            String?
  title                     String
  description               String?
  status                    TicketStatus   @default(OPEN)
  priority                  TicketPriority @default(MEDIUM)
  source                    TicketSource   @default(INTERNAL)
  submittedByPortalCustomer Boolean        @default(false)
  createdAt                 DateTime       @default(now())
  updatedAt                 DateTime       @updatedAt
  assignedUserId            String?

  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contact        Contact         @relation(fields: [contactId], references: [id], onDelete: Cascade)
  portalCustomer PortalCustomer? @relation(fields: [portalCustomerId], references: [id], onDelete: SetNull)
  deal           Deal?           @relation(fields: [dealId], references: [id], onDelete: SetNull)
  assignedUser   User?           @relation("TicketAssignedUser", fields: [assignedUserId], references: [id], onDelete: SetNull)
  comments       TicketComment[]

  @@unique([tenantId, externalId, externalSystem])
  @@index([tenantId])
  @@index([contactId])
  @@index([portalCustomerId])
  @@index([dealId])
  @@index([assignedUserId])
  @@index([status])
  @@index([priority])
  @@map("tickets")
}

model TicketComment {
  id               String   @id @default(cuid())
  ticketId         String
  userId           String?
  portalCustomerId String?
  content          String
  authorName       String?  // Name of the person who commented (from Clerk)
  isInternal       Boolean  @default(true) // true = internal user, false = portal customer
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  ticket         Ticket          @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  user           User?           @relation("TicketComments", fields: [userId], references: [id], onDelete: Restrict)
  portalCustomer PortalCustomer? @relation(fields: [portalCustomerId], references: [id], onDelete: Restrict)

  @@index([ticketId])
  @@index([userId])
  @@index([portalCustomerId])
  @@map("ticket_comments")
}

// ==================== INTEGRATIONS ====================

model Integration {
  id           String    @id @default(cuid())
  tenantId     String
  serviceName  String // gmail, calendar, voip, osticket
  isActive     Boolean   @default(false)
  config       Json? // OAuth tokens, API keys, scopes
  lastSyncAt   DateTime?
  syncStatus   String? // success, failed, in_progress
  errorMessage String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, serviceName])
  @@index([tenantId])
  @@map("integrations")
}

// ==================== CALL LOGS ====================

enum CallDirection {
  INBOUND
  OUTBOUND
}

model CallLog {
  id              String         @id @default(cuid())
  tenantId        String
  userId          String?
  contactId       String?
  dealId          String?
  direction       CallDirection  @default(OUTBOUND)
  fromNumber      String
  toNumber        String
  status          String         @default("INITIATED") // INITIATED, RINGING, ANSWERED, COMPLETED, FAILED
  duration        Int?           // seconds
  outcome         String?        // completed, missed, voicemail
  recordingUrl    String?
  recordingSid    String?        // Twilio recording SID
  twilioCallSid   String?        @unique // Twilio call SID
  transcription   String?
  summary         String?
  startedAt       DateTime?      // When call was answered
  endedAt         DateTime?      // When call ended
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  tenant  Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user    User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  contact Contact? @relation(fields: [contactId], references: [id], onDelete: Restrict)
  deal    Deal?    @relation(fields: [dealId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([userId])
  @@index([contactId])
  @@index([dealId])
  @@index([twilioCallSid])
  @@map("call_logs")
}

// ==================== PORTAL CUSTOMERS ====================

model PortalCustomer {
  id             String   @id @default(cuid())
  tenantId       String
  contactId      String?
  supabaseUserId String?  // Nullable for invitation flow, filled on first login
  email          String
  name           String?
  accessToken    String?  @unique // Token for initial portal access invitation
  isActive       Boolean  @default(true) // Can deactivate portal access
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  tenant         Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  contact        Contact?        @relation(fields: [contactId], references: [id], onDelete: SetNull)
  tickets        Ticket[]
  ticketComments TicketComment[]

  @@unique([tenantId, supabaseUserId]) // One user can belong to multiple tenants
  @@unique([tenantId, email])          // Prevent duplicate emails per tenant
  @@index([supabaseUserId])            // Fast lookup of all user's tenants
  @@index([tenantId])
  @@index([contactId])
  @@index([accessToken])
  @@map("portal_customers")
}

// ==================== USER INVITATIONS ====================

model UserInvitation {
  id         String    @id @default(cuid())
  tenantId   String
  email      String
  role       UserRole  @default(MEMBER)
  invitedBy  String    // User ID who sent the invitation
  token      String    @unique // Unique invitation token
  expiresAt  DateTime
  acceptedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  tenant       Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  invitedByUser User   @relation(fields: [invitedBy], references: [id], onDelete: Cascade)

  @@unique([tenantId, email]) // One pending invitation per email per tenant
  @@index([tenantId])
  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@map("user_invitations")
}

// ==================== CHATBOT ====================

model Conversation {
  id        String    @id @default(cuid())
  userId    String
  tenantId  String
  title     String?   // First message or custom title
  messages  Message[]
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([tenantId])
  @@index([updatedAt])
  @@map("conversations")
}

model Message {
  id             String   @id @default(cuid())
  conversationId String
  role           String   // 'user' | 'assistant'
  content        String   @db.Text
  createdAt      DateTime @default(now())

  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([createdAt])
  @@map("messages")
}

// ==================== TELEGRAM BOT ====================

model TelegramLinkRequest {
  id        String    @id @default(cuid())
  code      String    @unique // One-time code for deep link
  userId    String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([code])
  @@index([userId])
  @@index([expiresAt])
  @@map("telegram_link_requests")
}

model TelegramUser {
  id         String   @id @default(cuid())
  telegramId String   @unique // Telegram user ID (e.g., "123456789")
  userId     String   // Links to User model
  username   String?  // Telegram username (@username)
  firstName  String?  // Telegram first name
  lastName   String?  // Telegram last name
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([telegramId])
  @@index([userId])
  @@map("telegram_users")
}