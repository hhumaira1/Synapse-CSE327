
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Contact
 * 
 */
export type Contact = $Result.DefaultSelection<Prisma.$ContactPayload>
/**
 * Model Lead
 * 
 */
export type Lead = $Result.DefaultSelection<Prisma.$LeadPayload>
/**
 * Model Pipeline
 * 
 */
export type Pipeline = $Result.DefaultSelection<Prisma.$PipelinePayload>
/**
 * Model Stage
 * 
 */
export type Stage = $Result.DefaultSelection<Prisma.$StagePayload>
/**
 * Model Deal
 * 
 */
export type Deal = $Result.DefaultSelection<Prisma.$DealPayload>
/**
 * Model Interaction
 * 
 */
export type Interaction = $Result.DefaultSelection<Prisma.$InteractionPayload>
/**
 * Model Ticket
 * 
 */
export type Ticket = $Result.DefaultSelection<Prisma.$TicketPayload>
/**
 * Model TicketComment
 * 
 */
export type TicketComment = $Result.DefaultSelection<Prisma.$TicketCommentPayload>
/**
 * Model Integration
 * 
 */
export type Integration = $Result.DefaultSelection<Prisma.$IntegrationPayload>
/**
 * Model CallLog
 * 
 */
export type CallLog = $Result.DefaultSelection<Prisma.$CallLogPayload>
/**
 * Model PortalCustomer
 * 
 */
export type PortalCustomer = $Result.DefaultSelection<Prisma.$PortalCustomerPayload>
/**
 * Model UserInvitation
 * 
 */
export type UserInvitation = $Result.DefaultSelection<Prisma.$UserInvitationPayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model TelegramLinkRequest
 * 
 */
export type TelegramLinkRequest = $Result.DefaultSelection<Prisma.$TelegramLinkRequestPayload>
/**
 * Model TelegramUser
 * 
 */
export type TelegramUser = $Result.DefaultSelection<Prisma.$TelegramUserPayload>
/**
 * Model CallEvent
 * 
 */
export type CallEvent = $Result.DefaultSelection<Prisma.$CallEventPayload>
/**
 * Model CallRecording
 * 
 */
export type CallRecording = $Result.DefaultSelection<Prisma.$CallRecordingPayload>
/**
 * Model CallTranscription
 * 
 */
export type CallTranscription = $Result.DefaultSelection<Prisma.$CallTranscriptionPayload>
/**
 * Model UserPresence
 * 
 */
export type UserPresence = $Result.DefaultSelection<Prisma.$UserPresencePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  MANAGER: 'MANAGER',
  MEMBER: 'MEMBER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const TenantType: {
  ORGANIZATION: 'ORGANIZATION',
  PERSONAL: 'PERSONAL',
  BUSINESS: 'BUSINESS'
};

export type TenantType = (typeof TenantType)[keyof typeof TenantType]


export const LeadStatus: {
  NEW: 'NEW',
  CONTACTED: 'CONTACTED',
  QUALIFIED: 'QUALIFIED',
  UNQUALIFIED: 'UNQUALIFIED',
  CONVERTED: 'CONVERTED'
};

export type LeadStatus = (typeof LeadStatus)[keyof typeof LeadStatus]


export const TicketStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  RESOLVED: 'RESOLVED',
  CLOSED: 'CLOSED'
};

export type TicketStatus = (typeof TicketStatus)[keyof typeof TicketStatus]


export const TicketPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type TicketPriority = (typeof TicketPriority)[keyof typeof TicketPriority]


export const TicketSource: {
  INTERNAL: 'INTERNAL',
  PORTAL: 'PORTAL',
  EMAIL: 'EMAIL',
  API: 'API'
};

export type TicketSource = (typeof TicketSource)[keyof typeof TicketSource]


export const InteractionType: {
  EMAIL: 'EMAIL',
  CALL: 'CALL',
  MEETING: 'MEETING',
  NOTE: 'NOTE',
  TICKET: 'TICKET'
};

export type InteractionType = (typeof InteractionType)[keyof typeof InteractionType]


export const CallStatus: {
  INITIATED: 'INITIATED',
  RINGING: 'RINGING',
  CONNECTED: 'CONNECTED',
  ENDED: 'ENDED',
  FAILED: 'FAILED',
  MISSED: 'MISSED'
};

export type CallStatus = (typeof CallStatus)[keyof typeof CallStatus]


export const PresenceStatus: {
  ONLINE: 'ONLINE',
  BUSY: 'BUSY',
  AWAY: 'AWAY',
  OFFLINE: 'OFFLINE'
};

export type PresenceStatus = (typeof PresenceStatus)[keyof typeof PresenceStatus]


export const RecordingProvider: {
  LIVEKIT: 'LIVEKIT',
  AGORA: 'AGORA',
  DAILY: 'DAILY',
  CUSTOM: 'CUSTOM'
};

export type RecordingProvider = (typeof RecordingProvider)[keyof typeof RecordingProvider]


export const RecordingStatus: {
  REQUESTED: 'REQUESTED',
  IN_PROGRESS: 'IN_PROGRESS',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type RecordingStatus = (typeof RecordingStatus)[keyof typeof RecordingStatus]


export const TranscriptionProvider: {
  DEEPGRAM: 'DEEPGRAM',
  ASSEMBLYAI: 'ASSEMBLYAI',
  GOOGLE_CLOUD: 'GOOGLE_CLOUD',
  LIVEKIT: 'LIVEKIT',
  AGORA: 'AGORA'
};

export type TranscriptionProvider = (typeof TranscriptionProvider)[keyof typeof TranscriptionProvider]


export const TranscriptionStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type TranscriptionStatus = (typeof TranscriptionStatus)[keyof typeof TranscriptionStatus]


export const CallDirection: {
  INBOUND: 'INBOUND',
  OUTBOUND: 'OUTBOUND'
};

export type CallDirection = (typeof CallDirection)[keyof typeof CallDirection]


export const ParticipantType: {
  CRM_USER: 'CRM_USER',
  PORTAL_CUSTOMER: 'PORTAL_CUSTOMER'
};

export type ParticipantType = (typeof ParticipantType)[keyof typeof ParticipantType]


export const CallEventType: {
  CALL_STARTED: 'CALL_STARTED',
  RINGING: 'RINGING',
  ACCEPTED: 'ACCEPTED',
  REJECTED: 'REJECTED',
  ENDED: 'ENDED',
  MISSED: 'MISSED'
};

export type CallEventType = (typeof CallEventType)[keyof typeof CallEventType]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type TenantType = $Enums.TenantType

export const TenantType: typeof $Enums.TenantType

export type LeadStatus = $Enums.LeadStatus

export const LeadStatus: typeof $Enums.LeadStatus

export type TicketStatus = $Enums.TicketStatus

export const TicketStatus: typeof $Enums.TicketStatus

export type TicketPriority = $Enums.TicketPriority

export const TicketPriority: typeof $Enums.TicketPriority

export type TicketSource = $Enums.TicketSource

export const TicketSource: typeof $Enums.TicketSource

export type InteractionType = $Enums.InteractionType

export const InteractionType: typeof $Enums.InteractionType

export type CallStatus = $Enums.CallStatus

export const CallStatus: typeof $Enums.CallStatus

export type PresenceStatus = $Enums.PresenceStatus

export const PresenceStatus: typeof $Enums.PresenceStatus

export type RecordingProvider = $Enums.RecordingProvider

export const RecordingProvider: typeof $Enums.RecordingProvider

export type RecordingStatus = $Enums.RecordingStatus

export const RecordingStatus: typeof $Enums.RecordingStatus

export type TranscriptionProvider = $Enums.TranscriptionProvider

export const TranscriptionProvider: typeof $Enums.TranscriptionProvider

export type TranscriptionStatus = $Enums.TranscriptionStatus

export const TranscriptionStatus: typeof $Enums.TranscriptionStatus

export type CallDirection = $Enums.CallDirection

export const CallDirection: typeof $Enums.CallDirection

export type ParticipantType = $Enums.ParticipantType

export const ParticipantType: typeof $Enums.ParticipantType

export type CallEventType = $Enums.CallEventType

export const CallEventType: typeof $Enums.CallEventType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contact`: Exposes CRUD operations for the **Contact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contacts
    * const contacts = await prisma.contact.findMany()
    * ```
    */
  get contact(): Prisma.ContactDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lead`: Exposes CRUD operations for the **Lead** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leads
    * const leads = await prisma.lead.findMany()
    * ```
    */
  get lead(): Prisma.LeadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pipeline`: Exposes CRUD operations for the **Pipeline** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pipelines
    * const pipelines = await prisma.pipeline.findMany()
    * ```
    */
  get pipeline(): Prisma.PipelineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stage`: Exposes CRUD operations for the **Stage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stages
    * const stages = await prisma.stage.findMany()
    * ```
    */
  get stage(): Prisma.StageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deal`: Exposes CRUD operations for the **Deal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deals
    * const deals = await prisma.deal.findMany()
    * ```
    */
  get deal(): Prisma.DealDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.interaction`: Exposes CRUD operations for the **Interaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Interactions
    * const interactions = await prisma.interaction.findMany()
    * ```
    */
  get interaction(): Prisma.InteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticket`: Exposes CRUD operations for the **Ticket** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tickets
    * const tickets = await prisma.ticket.findMany()
    * ```
    */
  get ticket(): Prisma.TicketDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.ticketComment`: Exposes CRUD operations for the **TicketComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TicketComments
    * const ticketComments = await prisma.ticketComment.findMany()
    * ```
    */
  get ticketComment(): Prisma.TicketCommentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration`: Exposes CRUD operations for the **Integration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integrations
    * const integrations = await prisma.integration.findMany()
    * ```
    */
  get integration(): Prisma.IntegrationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callLog`: Exposes CRUD operations for the **CallLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallLogs
    * const callLogs = await prisma.callLog.findMany()
    * ```
    */
  get callLog(): Prisma.CallLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.portalCustomer`: Exposes CRUD operations for the **PortalCustomer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PortalCustomers
    * const portalCustomers = await prisma.portalCustomer.findMany()
    * ```
    */
  get portalCustomer(): Prisma.PortalCustomerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userInvitation`: Exposes CRUD operations for the **UserInvitation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInvitations
    * const userInvitations = await prisma.userInvitation.findMany()
    * ```
    */
  get userInvitation(): Prisma.UserInvitationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telegramLinkRequest`: Exposes CRUD operations for the **TelegramLinkRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramLinkRequests
    * const telegramLinkRequests = await prisma.telegramLinkRequest.findMany()
    * ```
    */
  get telegramLinkRequest(): Prisma.TelegramLinkRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.telegramUser`: Exposes CRUD operations for the **TelegramUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TelegramUsers
    * const telegramUsers = await prisma.telegramUser.findMany()
    * ```
    */
  get telegramUser(): Prisma.TelegramUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callEvent`: Exposes CRUD operations for the **CallEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallEvents
    * const callEvents = await prisma.callEvent.findMany()
    * ```
    */
  get callEvent(): Prisma.CallEventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callRecording`: Exposes CRUD operations for the **CallRecording** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallRecordings
    * const callRecordings = await prisma.callRecording.findMany()
    * ```
    */
  get callRecording(): Prisma.CallRecordingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.callTranscription`: Exposes CRUD operations for the **CallTranscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallTranscriptions
    * const callTranscriptions = await prisma.callTranscription.findMany()
    * ```
    */
  get callTranscription(): Prisma.CallTranscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userPresence`: Exposes CRUD operations for the **UserPresence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserPresences
    * const userPresences = await prisma.userPresence.findMany()
    * ```
    */
  get userPresence(): Prisma.UserPresenceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.0
   * Query Engine version: 2ba551f319ab1df4bc874a89965d8b3641056773
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Contact: 'Contact',
    Lead: 'Lead',
    Pipeline: 'Pipeline',
    Stage: 'Stage',
    Deal: 'Deal',
    Interaction: 'Interaction',
    Ticket: 'Ticket',
    TicketComment: 'TicketComment',
    Integration: 'Integration',
    CallLog: 'CallLog',
    PortalCustomer: 'PortalCustomer',
    UserInvitation: 'UserInvitation',
    Conversation: 'Conversation',
    Message: 'Message',
    TelegramLinkRequest: 'TelegramLinkRequest',
    TelegramUser: 'TelegramUser',
    CallEvent: 'CallEvent',
    CallRecording: 'CallRecording',
    CallTranscription: 'CallTranscription',
    UserPresence: 'UserPresence'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "contact" | "lead" | "pipeline" | "stage" | "deal" | "interaction" | "ticket" | "ticketComment" | "integration" | "callLog" | "portalCustomer" | "userInvitation" | "conversation" | "message" | "telegramLinkRequest" | "telegramUser" | "callEvent" | "callRecording" | "callTranscription" | "userPresence"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TenantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TenantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Contact: {
        payload: Prisma.$ContactPayload<ExtArgs>
        fields: Prisma.ContactFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContactFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContactFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findFirst: {
            args: Prisma.ContactFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContactFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          findMany: {
            args: Prisma.ContactFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          create: {
            args: Prisma.ContactCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          createMany: {
            args: Prisma.ContactCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContactCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          delete: {
            args: Prisma.ContactDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          update: {
            args: Prisma.ContactUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          deleteMany: {
            args: Prisma.ContactDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContactUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContactUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>[]
          }
          upsert: {
            args: Prisma.ContactUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContactPayload>
          }
          aggregate: {
            args: Prisma.ContactAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContact>
          }
          groupBy: {
            args: Prisma.ContactGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContactCountArgs<ExtArgs>
            result: $Utils.Optional<ContactCountAggregateOutputType> | number
          }
        }
      }
      Lead: {
        payload: Prisma.$LeadPayload<ExtArgs>
        fields: Prisma.LeadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findFirst: {
            args: Prisma.LeadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          findMany: {
            args: Prisma.LeadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          create: {
            args: Prisma.LeadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          createMany: {
            args: Prisma.LeadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          delete: {
            args: Prisma.LeadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          update: {
            args: Prisma.LeadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          deleteMany: {
            args: Prisma.LeadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LeadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>[]
          }
          upsert: {
            args: Prisma.LeadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeadPayload>
          }
          aggregate: {
            args: Prisma.LeadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLead>
          }
          groupBy: {
            args: Prisma.LeadGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeadGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeadCountArgs<ExtArgs>
            result: $Utils.Optional<LeadCountAggregateOutputType> | number
          }
        }
      }
      Pipeline: {
        payload: Prisma.$PipelinePayload<ExtArgs>
        fields: Prisma.PipelineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PipelineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PipelineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findFirst: {
            args: Prisma.PipelineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PipelineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          findMany: {
            args: Prisma.PipelineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          create: {
            args: Prisma.PipelineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          createMany: {
            args: Prisma.PipelineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PipelineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          delete: {
            args: Prisma.PipelineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          update: {
            args: Prisma.PipelineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          deleteMany: {
            args: Prisma.PipelineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PipelineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PipelineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>[]
          }
          upsert: {
            args: Prisma.PipelineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PipelinePayload>
          }
          aggregate: {
            args: Prisma.PipelineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePipeline>
          }
          groupBy: {
            args: Prisma.PipelineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PipelineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PipelineCountArgs<ExtArgs>
            result: $Utils.Optional<PipelineCountAggregateOutputType> | number
          }
        }
      }
      Stage: {
        payload: Prisma.$StagePayload<ExtArgs>
        fields: Prisma.StageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findFirst: {
            args: Prisma.StageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          findMany: {
            args: Prisma.StageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          create: {
            args: Prisma.StageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          createMany: {
            args: Prisma.StageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          delete: {
            args: Prisma.StageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          update: {
            args: Prisma.StageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          deleteMany: {
            args: Prisma.StageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>[]
          }
          upsert: {
            args: Prisma.StageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StagePayload>
          }
          aggregate: {
            args: Prisma.StageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStage>
          }
          groupBy: {
            args: Prisma.StageGroupByArgs<ExtArgs>
            result: $Utils.Optional<StageGroupByOutputType>[]
          }
          count: {
            args: Prisma.StageCountArgs<ExtArgs>
            result: $Utils.Optional<StageCountAggregateOutputType> | number
          }
        }
      }
      Deal: {
        payload: Prisma.$DealPayload<ExtArgs>
        fields: Prisma.DealFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DealFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DealFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findFirst: {
            args: Prisma.DealFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DealFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          findMany: {
            args: Prisma.DealFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          create: {
            args: Prisma.DealCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          createMany: {
            args: Prisma.DealCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DealCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          delete: {
            args: Prisma.DealDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          update: {
            args: Prisma.DealUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          deleteMany: {
            args: Prisma.DealDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DealUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DealUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>[]
          }
          upsert: {
            args: Prisma.DealUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DealPayload>
          }
          aggregate: {
            args: Prisma.DealAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeal>
          }
          groupBy: {
            args: Prisma.DealGroupByArgs<ExtArgs>
            result: $Utils.Optional<DealGroupByOutputType>[]
          }
          count: {
            args: Prisma.DealCountArgs<ExtArgs>
            result: $Utils.Optional<DealCountAggregateOutputType> | number
          }
        }
      }
      Interaction: {
        payload: Prisma.$InteractionPayload<ExtArgs>
        fields: Prisma.InteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findFirst: {
            args: Prisma.InteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          findMany: {
            args: Prisma.InteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          create: {
            args: Prisma.InteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          createMany: {
            args: Prisma.InteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          delete: {
            args: Prisma.InteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          update: {
            args: Prisma.InteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          deleteMany: {
            args: Prisma.InteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>[]
          }
          upsert: {
            args: Prisma.InteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InteractionPayload>
          }
          aggregate: {
            args: Prisma.InteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInteraction>
          }
          groupBy: {
            args: Prisma.InteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InteractionCountArgs<ExtArgs>
            result: $Utils.Optional<InteractionCountAggregateOutputType> | number
          }
        }
      }
      Ticket: {
        payload: Prisma.$TicketPayload<ExtArgs>
        fields: Prisma.TicketFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findFirst: {
            args: Prisma.TicketFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          findMany: {
            args: Prisma.TicketFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          create: {
            args: Prisma.TicketCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          createMany: {
            args: Prisma.TicketCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          delete: {
            args: Prisma.TicketDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          update: {
            args: Prisma.TicketUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          deleteMany: {
            args: Prisma.TicketDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>[]
          }
          upsert: {
            args: Prisma.TicketUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketPayload>
          }
          aggregate: {
            args: Prisma.TicketAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicket>
          }
          groupBy: {
            args: Prisma.TicketGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCountAggregateOutputType> | number
          }
        }
      }
      TicketComment: {
        payload: Prisma.$TicketCommentPayload<ExtArgs>
        fields: Prisma.TicketCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TicketCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TicketCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findFirst: {
            args: Prisma.TicketCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TicketCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          findMany: {
            args: Prisma.TicketCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          create: {
            args: Prisma.TicketCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          createMany: {
            args: Prisma.TicketCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TicketCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          delete: {
            args: Prisma.TicketCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          update: {
            args: Prisma.TicketCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          deleteMany: {
            args: Prisma.TicketCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TicketCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TicketCommentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>[]
          }
          upsert: {
            args: Prisma.TicketCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TicketCommentPayload>
          }
          aggregate: {
            args: Prisma.TicketCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTicketComment>
          }
          groupBy: {
            args: Prisma.TicketCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.TicketCommentCountArgs<ExtArgs>
            result: $Utils.Optional<TicketCommentCountAggregateOutputType> | number
          }
        }
      }
      Integration: {
        payload: Prisma.$IntegrationPayload<ExtArgs>
        fields: Prisma.IntegrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.IntegrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.IntegrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findFirst: {
            args: Prisma.IntegrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.IntegrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          findMany: {
            args: Prisma.IntegrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          create: {
            args: Prisma.IntegrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          createMany: {
            args: Prisma.IntegrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.IntegrationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          delete: {
            args: Prisma.IntegrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          update: {
            args: Prisma.IntegrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          deleteMany: {
            args: Prisma.IntegrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.IntegrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.IntegrationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>[]
          }
          upsert: {
            args: Prisma.IntegrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$IntegrationPayload>
          }
          aggregate: {
            args: Prisma.IntegrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration>
          }
          groupBy: {
            args: Prisma.IntegrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<IntegrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.IntegrationCountArgs<ExtArgs>
            result: $Utils.Optional<IntegrationCountAggregateOutputType> | number
          }
        }
      }
      CallLog: {
        payload: Prisma.$CallLogPayload<ExtArgs>
        fields: Prisma.CallLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          findFirst: {
            args: Prisma.CallLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          findMany: {
            args: Prisma.CallLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>[]
          }
          create: {
            args: Prisma.CallLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          createMany: {
            args: Prisma.CallLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>[]
          }
          delete: {
            args: Prisma.CallLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          update: {
            args: Prisma.CallLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          deleteMany: {
            args: Prisma.CallLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>[]
          }
          upsert: {
            args: Prisma.CallLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallLogPayload>
          }
          aggregate: {
            args: Prisma.CallLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallLog>
          }
          groupBy: {
            args: Prisma.CallLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallLogCountArgs<ExtArgs>
            result: $Utils.Optional<CallLogCountAggregateOutputType> | number
          }
        }
      }
      PortalCustomer: {
        payload: Prisma.$PortalCustomerPayload<ExtArgs>
        fields: Prisma.PortalCustomerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PortalCustomerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PortalCustomerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>
          }
          findFirst: {
            args: Prisma.PortalCustomerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PortalCustomerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>
          }
          findMany: {
            args: Prisma.PortalCustomerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>[]
          }
          create: {
            args: Prisma.PortalCustomerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>
          }
          createMany: {
            args: Prisma.PortalCustomerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PortalCustomerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>[]
          }
          delete: {
            args: Prisma.PortalCustomerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>
          }
          update: {
            args: Prisma.PortalCustomerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>
          }
          deleteMany: {
            args: Prisma.PortalCustomerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PortalCustomerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PortalCustomerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>[]
          }
          upsert: {
            args: Prisma.PortalCustomerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PortalCustomerPayload>
          }
          aggregate: {
            args: Prisma.PortalCustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePortalCustomer>
          }
          groupBy: {
            args: Prisma.PortalCustomerGroupByArgs<ExtArgs>
            result: $Utils.Optional<PortalCustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.PortalCustomerCountArgs<ExtArgs>
            result: $Utils.Optional<PortalCustomerCountAggregateOutputType> | number
          }
        }
      }
      UserInvitation: {
        payload: Prisma.$UserInvitationPayload<ExtArgs>
        fields: Prisma.UserInvitationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInvitationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInvitationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findFirst: {
            args: Prisma.UserInvitationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInvitationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          findMany: {
            args: Prisma.UserInvitationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          create: {
            args: Prisma.UserInvitationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          createMany: {
            args: Prisma.UserInvitationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInvitationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          delete: {
            args: Prisma.UserInvitationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          update: {
            args: Prisma.UserInvitationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          deleteMany: {
            args: Prisma.UserInvitationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInvitationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInvitationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>[]
          }
          upsert: {
            args: Prisma.UserInvitationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInvitationPayload>
          }
          aggregate: {
            args: Prisma.UserInvitationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInvitation>
          }
          groupBy: {
            args: Prisma.UserInvitationGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInvitationCountArgs<ExtArgs>
            result: $Utils.Optional<UserInvitationCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      TelegramLinkRequest: {
        payload: Prisma.$TelegramLinkRequestPayload<ExtArgs>
        fields: Prisma.TelegramLinkRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramLinkRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramLinkRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>
          }
          findFirst: {
            args: Prisma.TelegramLinkRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramLinkRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>
          }
          findMany: {
            args: Prisma.TelegramLinkRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>[]
          }
          create: {
            args: Prisma.TelegramLinkRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>
          }
          createMany: {
            args: Prisma.TelegramLinkRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelegramLinkRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>[]
          }
          delete: {
            args: Prisma.TelegramLinkRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>
          }
          update: {
            args: Prisma.TelegramLinkRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>
          }
          deleteMany: {
            args: Prisma.TelegramLinkRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramLinkRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelegramLinkRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>[]
          }
          upsert: {
            args: Prisma.TelegramLinkRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramLinkRequestPayload>
          }
          aggregate: {
            args: Prisma.TelegramLinkRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelegramLinkRequest>
          }
          groupBy: {
            args: Prisma.TelegramLinkRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelegramLinkRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramLinkRequestCountArgs<ExtArgs>
            result: $Utils.Optional<TelegramLinkRequestCountAggregateOutputType> | number
          }
        }
      }
      TelegramUser: {
        payload: Prisma.$TelegramUserPayload<ExtArgs>
        fields: Prisma.TelegramUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TelegramUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TelegramUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>
          }
          findFirst: {
            args: Prisma.TelegramUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TelegramUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>
          }
          findMany: {
            args: Prisma.TelegramUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>[]
          }
          create: {
            args: Prisma.TelegramUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>
          }
          createMany: {
            args: Prisma.TelegramUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TelegramUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>[]
          }
          delete: {
            args: Prisma.TelegramUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>
          }
          update: {
            args: Prisma.TelegramUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>
          }
          deleteMany: {
            args: Prisma.TelegramUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TelegramUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TelegramUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>[]
          }
          upsert: {
            args: Prisma.TelegramUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TelegramUserPayload>
          }
          aggregate: {
            args: Prisma.TelegramUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTelegramUser>
          }
          groupBy: {
            args: Prisma.TelegramUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<TelegramUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.TelegramUserCountArgs<ExtArgs>
            result: $Utils.Optional<TelegramUserCountAggregateOutputType> | number
          }
        }
      }
      CallEvent: {
        payload: Prisma.$CallEventPayload<ExtArgs>
        fields: Prisma.CallEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>
          }
          findFirst: {
            args: Prisma.CallEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>
          }
          findMany: {
            args: Prisma.CallEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>[]
          }
          create: {
            args: Prisma.CallEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>
          }
          createMany: {
            args: Prisma.CallEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>[]
          }
          delete: {
            args: Prisma.CallEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>
          }
          update: {
            args: Prisma.CallEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>
          }
          deleteMany: {
            args: Prisma.CallEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>[]
          }
          upsert: {
            args: Prisma.CallEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallEventPayload>
          }
          aggregate: {
            args: Prisma.CallEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallEvent>
          }
          groupBy: {
            args: Prisma.CallEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallEventCountArgs<ExtArgs>
            result: $Utils.Optional<CallEventCountAggregateOutputType> | number
          }
        }
      }
      CallRecording: {
        payload: Prisma.$CallRecordingPayload<ExtArgs>
        fields: Prisma.CallRecordingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallRecordingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallRecordingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>
          }
          findFirst: {
            args: Prisma.CallRecordingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallRecordingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>
          }
          findMany: {
            args: Prisma.CallRecordingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>[]
          }
          create: {
            args: Prisma.CallRecordingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>
          }
          createMany: {
            args: Prisma.CallRecordingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallRecordingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>[]
          }
          delete: {
            args: Prisma.CallRecordingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>
          }
          update: {
            args: Prisma.CallRecordingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>
          }
          deleteMany: {
            args: Prisma.CallRecordingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallRecordingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallRecordingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>[]
          }
          upsert: {
            args: Prisma.CallRecordingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallRecordingPayload>
          }
          aggregate: {
            args: Prisma.CallRecordingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallRecording>
          }
          groupBy: {
            args: Prisma.CallRecordingGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallRecordingGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallRecordingCountArgs<ExtArgs>
            result: $Utils.Optional<CallRecordingCountAggregateOutputType> | number
          }
        }
      }
      CallTranscription: {
        payload: Prisma.$CallTranscriptionPayload<ExtArgs>
        fields: Prisma.CallTranscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallTranscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallTranscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>
          }
          findFirst: {
            args: Prisma.CallTranscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallTranscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>
          }
          findMany: {
            args: Prisma.CallTranscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>[]
          }
          create: {
            args: Prisma.CallTranscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>
          }
          createMany: {
            args: Prisma.CallTranscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallTranscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>[]
          }
          delete: {
            args: Prisma.CallTranscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>
          }
          update: {
            args: Prisma.CallTranscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>
          }
          deleteMany: {
            args: Prisma.CallTranscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallTranscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CallTranscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>[]
          }
          upsert: {
            args: Prisma.CallTranscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallTranscriptionPayload>
          }
          aggregate: {
            args: Prisma.CallTranscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallTranscription>
          }
          groupBy: {
            args: Prisma.CallTranscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallTranscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallTranscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<CallTranscriptionCountAggregateOutputType> | number
          }
        }
      }
      UserPresence: {
        payload: Prisma.$UserPresencePayload<ExtArgs>
        fields: Prisma.UserPresenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserPresenceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserPresenceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          findFirst: {
            args: Prisma.UserPresenceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserPresenceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          findMany: {
            args: Prisma.UserPresenceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          create: {
            args: Prisma.UserPresenceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          createMany: {
            args: Prisma.UserPresenceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserPresenceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          delete: {
            args: Prisma.UserPresenceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          update: {
            args: Prisma.UserPresenceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          deleteMany: {
            args: Prisma.UserPresenceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserPresenceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserPresenceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>[]
          }
          upsert: {
            args: Prisma.UserPresenceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPresencePayload>
          }
          aggregate: {
            args: Prisma.UserPresenceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserPresence>
          }
          groupBy: {
            args: Prisma.UserPresenceGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserPresenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserPresenceCountArgs<ExtArgs>
            result: $Utils.Optional<UserPresenceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    contact?: ContactOmit
    lead?: LeadOmit
    pipeline?: PipelineOmit
    stage?: StageOmit
    deal?: DealOmit
    interaction?: InteractionOmit
    ticket?: TicketOmit
    ticketComment?: TicketCommentOmit
    integration?: IntegrationOmit
    callLog?: CallLogOmit
    portalCustomer?: PortalCustomerOmit
    userInvitation?: UserInvitationOmit
    conversation?: ConversationOmit
    message?: MessageOmit
    telegramLinkRequest?: TelegramLinkRequestOmit
    telegramUser?: TelegramUserOmit
    callEvent?: CallEventOmit
    callRecording?: CallRecordingOmit
    callTranscription?: CallTranscriptionOmit
    userPresence?: UserPresenceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    users: number
    contacts: number
    leads: number
    pipelines: number
    deals: number
    interactions: number
    tickets: number
    integrations: number
    callLogs: number
    portalCustomers: number
    userInvitations: number
    conversations: number
    callEvents: number
    callRecordings: number
    callTranscriptions: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | TenantCountOutputTypeCountUsersArgs
    contacts?: boolean | TenantCountOutputTypeCountContactsArgs
    leads?: boolean | TenantCountOutputTypeCountLeadsArgs
    pipelines?: boolean | TenantCountOutputTypeCountPipelinesArgs
    deals?: boolean | TenantCountOutputTypeCountDealsArgs
    interactions?: boolean | TenantCountOutputTypeCountInteractionsArgs
    tickets?: boolean | TenantCountOutputTypeCountTicketsArgs
    integrations?: boolean | TenantCountOutputTypeCountIntegrationsArgs
    callLogs?: boolean | TenantCountOutputTypeCountCallLogsArgs
    portalCustomers?: boolean | TenantCountOutputTypeCountPortalCustomersArgs
    userInvitations?: boolean | TenantCountOutputTypeCountUserInvitationsArgs
    conversations?: boolean | TenantCountOutputTypeCountConversationsArgs
    callEvents?: boolean | TenantCountOutputTypeCountCallEventsArgs
    callRecordings?: boolean | TenantCountOutputTypeCountCallRecordingsArgs
    callTranscriptions?: boolean | TenantCountOutputTypeCountCallTranscriptionsArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountContactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountIntegrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCallLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountPortalCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortalCustomerWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountUserInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCallEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallEventWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCallRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallRecordingWhereInput
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountCallTranscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallTranscriptionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    interactions: number
    ticketsAssigned: number
    ticketComments: number
    invitations: number
    conversations: number
    telegramUsers: number
    telegramLinkRequests: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | UserCountOutputTypeCountInteractionsArgs
    ticketsAssigned?: boolean | UserCountOutputTypeCountTicketsAssignedArgs
    ticketComments?: boolean | UserCountOutputTypeCountTicketCommentsArgs
    invitations?: boolean | UserCountOutputTypeCountInvitationsArgs
    conversations?: boolean | UserCountOutputTypeCountConversationsArgs
    telegramUsers?: boolean | UserCountOutputTypeCountTelegramUsersArgs
    telegramLinkRequests?: boolean | UserCountOutputTypeCountTelegramLinkRequestsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketsAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTicketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTelegramUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTelegramLinkRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramLinkRequestWhereInput
  }


  /**
   * Count Type ContactCountOutputType
   */

  export type ContactCountOutputType = {
    leads: number
    interactions: number
    deals: number
    tickets: number
    callLogs: number
    portalCustomers: number
  }

  export type ContactCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    leads?: boolean | ContactCountOutputTypeCountLeadsArgs
    interactions?: boolean | ContactCountOutputTypeCountInteractionsArgs
    deals?: boolean | ContactCountOutputTypeCountDealsArgs
    tickets?: boolean | ContactCountOutputTypeCountTicketsArgs
    callLogs?: boolean | ContactCountOutputTypeCountCallLogsArgs
    portalCustomers?: boolean | ContactCountOutputTypeCountPortalCustomersArgs
  }

  // Custom InputTypes
  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContactCountOutputType
     */
    select?: ContactCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountLeadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountCallLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
  }

  /**
   * ContactCountOutputType without action
   */
  export type ContactCountOutputTypeCountPortalCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortalCustomerWhereInput
  }


  /**
   * Count Type LeadCountOutputType
   */

  export type LeadCountOutputType = {
    deals: number
  }

  export type LeadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deals?: boolean | LeadCountOutputTypeCountDealsArgs
  }

  // Custom InputTypes
  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeadCountOutputType
     */
    select?: LeadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LeadCountOutputType without action
   */
  export type LeadCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * Count Type PipelineCountOutputType
   */

  export type PipelineCountOutputType = {
    stages: number
    deals: number
  }

  export type PipelineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    stages?: boolean | PipelineCountOutputTypeCountStagesArgs
    deals?: boolean | PipelineCountOutputTypeCountDealsArgs
  }

  // Custom InputTypes
  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PipelineCountOutputType
     */
    select?: PipelineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountStagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
  }

  /**
   * PipelineCountOutputType without action
   */
  export type PipelineCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * Count Type StageCountOutputType
   */

  export type StageCountOutputType = {
    deals: number
  }

  export type StageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    deals?: boolean | StageCountOutputTypeCountDealsArgs
  }

  // Custom InputTypes
  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StageCountOutputType
     */
    select?: StageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StageCountOutputType without action
   */
  export type StageCountOutputTypeCountDealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
  }


  /**
   * Count Type DealCountOutputType
   */

  export type DealCountOutputType = {
    interactions: number
    tickets: number
    callLogs: number
  }

  export type DealCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    interactions?: boolean | DealCountOutputTypeCountInteractionsArgs
    tickets?: boolean | DealCountOutputTypeCountTicketsArgs
    callLogs?: boolean | DealCountOutputTypeCountCallLogsArgs
  }

  // Custom InputTypes
  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DealCountOutputType
     */
    select?: DealCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * DealCountOutputType without action
   */
  export type DealCountOutputTypeCountCallLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
  }


  /**
   * Count Type TicketCountOutputType
   */

  export type TicketCountOutputType = {
    comments: number
  }

  export type TicketCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | TicketCountOutputTypeCountCommentsArgs
  }

  // Custom InputTypes
  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketCountOutputType
     */
    select?: TicketCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TicketCountOutputType without action
   */
  export type TicketCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }


  /**
   * Count Type PortalCustomerCountOutputType
   */

  export type PortalCustomerCountOutputType = {
    tickets: number
    ticketComments: number
  }

  export type PortalCustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tickets?: boolean | PortalCustomerCountOutputTypeCountTicketsArgs
    ticketComments?: boolean | PortalCustomerCountOutputTypeCountTicketCommentsArgs
  }

  // Custom InputTypes
  /**
   * PortalCustomerCountOutputType without action
   */
  export type PortalCustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomerCountOutputType
     */
    select?: PortalCustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PortalCustomerCountOutputType without action
   */
  export type PortalCustomerCountOutputTypeCountTicketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
  }

  /**
   * PortalCustomerCountOutputType without action
   */
  export type PortalCustomerCountOutputTypeCountTicketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    messages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    domain: string | null
    type: $Enums.TenantType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    domain: string | null
    type: $Enums.TenantType | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    domain: number
    type: number
    settings: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    domain?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    domain?: true
    type?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    domain?: true
    type?: true
    settings?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    domain: string | null
    type: $Enums.TenantType
    settings: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    type?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Tenant$usersArgs<ExtArgs>
    contacts?: boolean | Tenant$contactsArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    pipelines?: boolean | Tenant$pipelinesArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    interactions?: boolean | Tenant$interactionsArgs<ExtArgs>
    tickets?: boolean | Tenant$ticketsArgs<ExtArgs>
    integrations?: boolean | Tenant$integrationsArgs<ExtArgs>
    callLogs?: boolean | Tenant$callLogsArgs<ExtArgs>
    portalCustomers?: boolean | Tenant$portalCustomersArgs<ExtArgs>
    userInvitations?: boolean | Tenant$userInvitationsArgs<ExtArgs>
    conversations?: boolean | Tenant$conversationsArgs<ExtArgs>
    callEvents?: boolean | Tenant$callEventsArgs<ExtArgs>
    callRecordings?: boolean | Tenant$callRecordingsArgs<ExtArgs>
    callTranscriptions?: boolean | Tenant$callTranscriptionsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    type?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    type?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tenant"]>

  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    domain?: boolean
    type?: boolean
    settings?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "domain" | "type" | "settings" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Tenant$usersArgs<ExtArgs>
    contacts?: boolean | Tenant$contactsArgs<ExtArgs>
    leads?: boolean | Tenant$leadsArgs<ExtArgs>
    pipelines?: boolean | Tenant$pipelinesArgs<ExtArgs>
    deals?: boolean | Tenant$dealsArgs<ExtArgs>
    interactions?: boolean | Tenant$interactionsArgs<ExtArgs>
    tickets?: boolean | Tenant$ticketsArgs<ExtArgs>
    integrations?: boolean | Tenant$integrationsArgs<ExtArgs>
    callLogs?: boolean | Tenant$callLogsArgs<ExtArgs>
    portalCustomers?: boolean | Tenant$portalCustomersArgs<ExtArgs>
    userInvitations?: boolean | Tenant$userInvitationsArgs<ExtArgs>
    conversations?: boolean | Tenant$conversationsArgs<ExtArgs>
    callEvents?: boolean | Tenant$callEventsArgs<ExtArgs>
    callRecordings?: boolean | Tenant$callRecordingsArgs<ExtArgs>
    callTranscriptions?: boolean | Tenant$callTranscriptionsArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TenantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TenantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      contacts: Prisma.$ContactPayload<ExtArgs>[]
      leads: Prisma.$LeadPayload<ExtArgs>[]
      pipelines: Prisma.$PipelinePayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      integrations: Prisma.$IntegrationPayload<ExtArgs>[]
      callLogs: Prisma.$CallLogPayload<ExtArgs>[]
      portalCustomers: Prisma.$PortalCustomerPayload<ExtArgs>[]
      userInvitations: Prisma.$UserInvitationPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      callEvents: Prisma.$CallEventPayload<ExtArgs>[]
      callRecordings: Prisma.$CallRecordingPayload<ExtArgs>[]
      callTranscriptions: Prisma.$CallTranscriptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      domain: string | null
      type: $Enums.TenantType
      settings: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tenants and returns the data saved in the database.
     * @param {TenantCreateManyAndReturnArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TenantCreateManyAndReturnArgs>(args?: SelectSubset<T, TenantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants and returns the data updated in the database.
     * @param {TenantUpdateManyAndReturnArgs} args - Arguments to update many Tenants.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tenants and only return the `id`
     * const tenantWithIdOnly = await prisma.tenant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TenantUpdateManyAndReturnArgs>(args: SelectSubset<T, TenantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Tenant$usersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contacts<T extends Tenant$contactsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$contactsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    leads<T extends Tenant$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    pipelines<T extends Tenant$pipelinesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$pipelinesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deals<T extends Tenant$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends Tenant$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Tenant$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integrations<T extends Tenant$integrationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    callLogs<T extends Tenant$callLogsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$callLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    portalCustomers<T extends Tenant$portalCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$portalCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    userInvitations<T extends Tenant$userInvitationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$userInvitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends Tenant$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    callEvents<T extends Tenant$callEventsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$callEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    callRecordings<T extends Tenant$callRecordingsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$callRecordingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    callTranscriptions<T extends Tenant$callTranscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$callTranscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly domain: FieldRef<"Tenant", 'String'>
    readonly type: FieldRef<"Tenant", 'TenantType'>
    readonly settings: FieldRef<"Tenant", 'Json'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant createManyAndReturn
   */
  export type TenantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant updateManyAndReturn
   */
  export type TenantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant.users
   */
  export type Tenant$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Tenant.contacts
   */
  export type Tenant$contactsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    cursor?: ContactWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Tenant.leads
   */
  export type Tenant$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Tenant.pipelines
   */
  export type Tenant$pipelinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    cursor?: PipelineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Tenant.deals
   */
  export type Tenant$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Tenant.interactions
   */
  export type Tenant$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Tenant.tickets
   */
  export type Tenant$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Tenant.integrations
   */
  export type Tenant$integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    cursor?: IntegrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Tenant.callLogs
   */
  export type Tenant$callLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    cursor?: CallLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * Tenant.portalCustomers
   */
  export type Tenant$portalCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    where?: PortalCustomerWhereInput
    orderBy?: PortalCustomerOrderByWithRelationInput | PortalCustomerOrderByWithRelationInput[]
    cursor?: PortalCustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortalCustomerScalarFieldEnum | PortalCustomerScalarFieldEnum[]
  }

  /**
   * Tenant.userInvitations
   */
  export type Tenant$userInvitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    cursor?: UserInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * Tenant.conversations
   */
  export type Tenant$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Tenant.callEvents
   */
  export type Tenant$callEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    where?: CallEventWhereInput
    orderBy?: CallEventOrderByWithRelationInput | CallEventOrderByWithRelationInput[]
    cursor?: CallEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallEventScalarFieldEnum | CallEventScalarFieldEnum[]
  }

  /**
   * Tenant.callRecordings
   */
  export type Tenant$callRecordingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    where?: CallRecordingWhereInput
    orderBy?: CallRecordingOrderByWithRelationInput | CallRecordingOrderByWithRelationInput[]
    cursor?: CallRecordingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallRecordingScalarFieldEnum | CallRecordingScalarFieldEnum[]
  }

  /**
   * Tenant.callTranscriptions
   */
  export type Tenant$callTranscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    where?: CallTranscriptionWhereInput
    orderBy?: CallTranscriptionOrderByWithRelationInput | CallTranscriptionOrderByWithRelationInput[]
    cursor?: CallTranscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallTranscriptionScalarFieldEnum | CallTranscriptionScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supabaseUserId: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    avatarUrl: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    fcmToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    supabaseUserId: string | null
    email: string | null
    firstName: string | null
    lastName: string | null
    name: string | null
    avatarUrl: string | null
    role: $Enums.UserRole | null
    isActive: boolean | null
    fcmToken: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    tenantId: number
    supabaseUserId: number
    email: number
    firstName: number
    lastName: number
    name: number
    avatarUrl: number
    role: number
    isActive: number
    fcmToken: number
    pushSubscription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    tenantId?: true
    supabaseUserId?: true
    email?: true
    firstName?: true
    lastName?: true
    name?: true
    avatarUrl?: true
    role?: true
    isActive?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    tenantId?: true
    supabaseUserId?: true
    email?: true
    firstName?: true
    lastName?: true
    name?: true
    avatarUrl?: true
    role?: true
    isActive?: true
    fcmToken?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    tenantId?: true
    supabaseUserId?: true
    email?: true
    firstName?: true
    lastName?: true
    name?: true
    avatarUrl?: true
    role?: true
    isActive?: true
    fcmToken?: true
    pushSubscription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName: string | null
    lastName: string | null
    name: string | null
    avatarUrl: string | null
    role: $Enums.UserRole
    isActive: boolean
    fcmToken: string | null
    pushSubscription: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    avatarUrl?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    interactions?: boolean | User$interactionsArgs<ExtArgs>
    ticketsAssigned?: boolean | User$ticketsAssignedArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    telegramUsers?: boolean | User$telegramUsersArgs<ExtArgs>
    telegramLinkRequests?: boolean | User$telegramLinkRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    avatarUrl?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    avatarUrl?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    tenantId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    firstName?: boolean
    lastName?: boolean
    name?: boolean
    avatarUrl?: boolean
    role?: boolean
    isActive?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "supabaseUserId" | "email" | "firstName" | "lastName" | "name" | "avatarUrl" | "role" | "isActive" | "fcmToken" | "pushSubscription" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    interactions?: boolean | User$interactionsArgs<ExtArgs>
    ticketsAssigned?: boolean | User$ticketsAssignedArgs<ExtArgs>
    ticketComments?: boolean | User$ticketCommentsArgs<ExtArgs>
    invitations?: boolean | User$invitationsArgs<ExtArgs>
    conversations?: boolean | User$conversationsArgs<ExtArgs>
    telegramUsers?: boolean | User$telegramUsersArgs<ExtArgs>
    telegramLinkRequests?: boolean | User$telegramLinkRequestsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      ticketsAssigned: Prisma.$TicketPayload<ExtArgs>[]
      ticketComments: Prisma.$TicketCommentPayload<ExtArgs>[]
      invitations: Prisma.$UserInvitationPayload<ExtArgs>[]
      conversations: Prisma.$ConversationPayload<ExtArgs>[]
      telegramUsers: Prisma.$TelegramUserPayload<ExtArgs>[]
      telegramLinkRequests: Prisma.$TelegramLinkRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      supabaseUserId: string
      email: string
      firstName: string | null
      lastName: string | null
      name: string | null
      avatarUrl: string | null
      role: $Enums.UserRole
      isActive: boolean
      fcmToken: string | null
      pushSubscription: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interactions<T extends User$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketsAssigned<T extends User$ticketsAssignedArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketsAssignedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketComments<T extends User$ticketCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$ticketCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invitations<T extends User$invitationsArgs<ExtArgs> = {}>(args?: Subset<T, User$invitationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversations<T extends User$conversationsArgs<ExtArgs> = {}>(args?: Subset<T, User$conversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    telegramUsers<T extends User$telegramUsersArgs<ExtArgs> = {}>(args?: Subset<T, User$telegramUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    telegramLinkRequests<T extends User$telegramLinkRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$telegramLinkRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly supabaseUserId: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly avatarUrl: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly fcmToken: FieldRef<"User", 'String'>
    readonly pushSubscription: FieldRef<"User", 'Json'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.interactions
   */
  export type User$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * User.ticketsAssigned
   */
  export type User$ticketsAssignedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * User.ticketComments
   */
  export type User$ticketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * User.invitations
   */
  export type User$invitationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    cursor?: UserInvitationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * User.conversations
   */
  export type User$conversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * User.telegramUsers
   */
  export type User$telegramUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    where?: TelegramUserWhereInput
    orderBy?: TelegramUserOrderByWithRelationInput | TelegramUserOrderByWithRelationInput[]
    cursor?: TelegramUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramUserScalarFieldEnum | TelegramUserScalarFieldEnum[]
  }

  /**
   * User.telegramLinkRequests
   */
  export type User$telegramLinkRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    where?: TelegramLinkRequestWhereInput
    orderBy?: TelegramLinkRequestOrderByWithRelationInput | TelegramLinkRequestOrderByWithRelationInput[]
    cursor?: TelegramLinkRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TelegramLinkRequestScalarFieldEnum | TelegramLinkRequestScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Contact
   */

  export type AggregateContact = {
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  export type ContactMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    source: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    source: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContactCountAggregateOutputType = {
    id: number
    tenantId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    company: number
    jobTitle: number
    source: number
    notes: number
    customFields: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContactMinAggregateInputType = {
    id?: true
    tenantId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    source?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactMaxAggregateInputType = {
    id?: true
    tenantId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    source?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContactCountAggregateInputType = {
    id?: true
    tenantId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    company?: true
    jobTitle?: true
    source?: true
    notes?: true
    customFields?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContactAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contact to aggregate.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contacts
    **/
    _count?: true | ContactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactMaxAggregateInputType
  }

  export type GetContactAggregateType<T extends ContactAggregateArgs> = {
        [P in keyof T & keyof AggregateContact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContact[P]>
      : GetScalarType<T[P], AggregateContact[P]>
  }




  export type ContactGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContactWhereInput
    orderBy?: ContactOrderByWithAggregationInput | ContactOrderByWithAggregationInput[]
    by: ContactScalarFieldEnum[] | ContactScalarFieldEnum
    having?: ContactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactCountAggregateInputType | true
    _min?: ContactMinAggregateInputType
    _max?: ContactMaxAggregateInputType
  }

  export type ContactGroupByOutputType = {
    id: string
    tenantId: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    company: string | null
    jobTitle: string | null
    source: string | null
    notes: string | null
    customFields: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ContactCountAggregateOutputType | null
    _min: ContactMinAggregateOutputType | null
    _max: ContactMaxAggregateOutputType | null
  }

  type GetContactGroupByPayload<T extends ContactGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactGroupByOutputType[P]>
            : GetScalarType<T[P], ContactGroupByOutputType[P]>
        }
      >
    >


  export type ContactSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    source?: boolean
    notes?: boolean
    customFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    leads?: boolean | Contact$leadsArgs<ExtArgs>
    interactions?: boolean | Contact$interactionsArgs<ExtArgs>
    deals?: boolean | Contact$dealsArgs<ExtArgs>
    tickets?: boolean | Contact$ticketsArgs<ExtArgs>
    callLogs?: boolean | Contact$callLogsArgs<ExtArgs>
    portalCustomers?: boolean | Contact$portalCustomersArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    source?: boolean
    notes?: boolean
    customFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    source?: boolean
    notes?: boolean
    customFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contact"]>

  export type ContactSelectScalar = {
    id?: boolean
    tenantId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    company?: boolean
    jobTitle?: boolean
    source?: boolean
    notes?: boolean
    customFields?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContactOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "firstName" | "lastName" | "email" | "phone" | "company" | "jobTitle" | "source" | "notes" | "customFields" | "createdAt" | "updatedAt", ExtArgs["result"]["contact"]>
  export type ContactInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    leads?: boolean | Contact$leadsArgs<ExtArgs>
    interactions?: boolean | Contact$interactionsArgs<ExtArgs>
    deals?: boolean | Contact$dealsArgs<ExtArgs>
    tickets?: boolean | Contact$ticketsArgs<ExtArgs>
    callLogs?: boolean | Contact$callLogsArgs<ExtArgs>
    portalCustomers?: boolean | Contact$portalCustomersArgs<ExtArgs>
    _count?: boolean | ContactCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContactIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ContactIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ContactPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contact"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      leads: Prisma.$LeadPayload<ExtArgs>[]
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      callLogs: Prisma.$CallLogPayload<ExtArgs>[]
      portalCustomers: Prisma.$PortalCustomerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      company: string | null
      jobTitle: string | null
      source: string | null
      notes: string | null
      customFields: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contact"]>
    composites: {}
  }

  type ContactGetPayload<S extends boolean | null | undefined | ContactDefaultArgs> = $Result.GetResult<Prisma.$ContactPayload, S>

  type ContactCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContactFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContactCountAggregateInputType | true
    }

  export interface ContactDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contact'], meta: { name: 'Contact' } }
    /**
     * Find zero or one Contact that matches the filter.
     * @param {ContactFindUniqueArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContactFindUniqueArgs>(args: SelectSubset<T, ContactFindUniqueArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contact that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContactFindUniqueOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContactFindUniqueOrThrowArgs>(args: SelectSubset<T, ContactFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContactFindFirstArgs>(args?: SelectSubset<T, ContactFindFirstArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contact that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindFirstOrThrowArgs} args - Arguments to find a Contact
     * @example
     * // Get one Contact
     * const contact = await prisma.contact.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContactFindFirstOrThrowArgs>(args?: SelectSubset<T, ContactFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contacts
     * const contacts = await prisma.contact.findMany()
     * 
     * // Get first 10 Contacts
     * const contacts = await prisma.contact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactWithIdOnly = await prisma.contact.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContactFindManyArgs>(args?: SelectSubset<T, ContactFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contact.
     * @param {ContactCreateArgs} args - Arguments to create a Contact.
     * @example
     * // Create one Contact
     * const Contact = await prisma.contact.create({
     *   data: {
     *     // ... data to create a Contact
     *   }
     * })
     * 
     */
    create<T extends ContactCreateArgs>(args: SelectSubset<T, ContactCreateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contacts.
     * @param {ContactCreateManyArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContactCreateManyArgs>(args?: SelectSubset<T, ContactCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contacts and returns the data saved in the database.
     * @param {ContactCreateManyAndReturnArgs} args - Arguments to create many Contacts.
     * @example
     * // Create many Contacts
     * const contact = await prisma.contact.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContactCreateManyAndReturnArgs>(args?: SelectSubset<T, ContactCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contact.
     * @param {ContactDeleteArgs} args - Arguments to delete one Contact.
     * @example
     * // Delete one Contact
     * const Contact = await prisma.contact.delete({
     *   where: {
     *     // ... filter to delete one Contact
     *   }
     * })
     * 
     */
    delete<T extends ContactDeleteArgs>(args: SelectSubset<T, ContactDeleteArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contact.
     * @param {ContactUpdateArgs} args - Arguments to update one Contact.
     * @example
     * // Update one Contact
     * const contact = await prisma.contact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContactUpdateArgs>(args: SelectSubset<T, ContactUpdateArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contacts.
     * @param {ContactDeleteManyArgs} args - Arguments to filter Contacts to delete.
     * @example
     * // Delete a few Contacts
     * const { count } = await prisma.contact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContactDeleteManyArgs>(args?: SelectSubset<T, ContactDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContactUpdateManyArgs>(args: SelectSubset<T, ContactUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contacts and returns the data updated in the database.
     * @param {ContactUpdateManyAndReturnArgs} args - Arguments to update many Contacts.
     * @example
     * // Update many Contacts
     * const contact = await prisma.contact.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contacts and only return the `id`
     * const contactWithIdOnly = await prisma.contact.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContactUpdateManyAndReturnArgs>(args: SelectSubset<T, ContactUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contact.
     * @param {ContactUpsertArgs} args - Arguments to update or create a Contact.
     * @example
     * // Update or create a Contact
     * const contact = await prisma.contact.upsert({
     *   create: {
     *     // ... data to create a Contact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contact we want to update
     *   }
     * })
     */
    upsert<T extends ContactUpsertArgs>(args: SelectSubset<T, ContactUpsertArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactCountArgs} args - Arguments to filter Contacts to count.
     * @example
     * // Count the number of Contacts
     * const count = await prisma.contact.count({
     *   where: {
     *     // ... the filter for the Contacts we want to count
     *   }
     * })
    **/
    count<T extends ContactCountArgs>(
      args?: Subset<T, ContactCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactAggregateArgs>(args: Subset<T, ContactAggregateArgs>): Prisma.PrismaPromise<GetContactAggregateType<T>>

    /**
     * Group by Contact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContactGroupByArgs['orderBy'] }
        : { orderBy?: ContactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contact model
   */
  readonly fields: ContactFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContactClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    leads<T extends Contact$leadsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$leadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends Contact$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deals<T extends Contact$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Contact$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    callLogs<T extends Contact$callLogsArgs<ExtArgs> = {}>(args?: Subset<T, Contact$callLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    portalCustomers<T extends Contact$portalCustomersArgs<ExtArgs> = {}>(args?: Subset<T, Contact$portalCustomersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contact model
   */
  interface ContactFieldRefs {
    readonly id: FieldRef<"Contact", 'String'>
    readonly tenantId: FieldRef<"Contact", 'String'>
    readonly firstName: FieldRef<"Contact", 'String'>
    readonly lastName: FieldRef<"Contact", 'String'>
    readonly email: FieldRef<"Contact", 'String'>
    readonly phone: FieldRef<"Contact", 'String'>
    readonly company: FieldRef<"Contact", 'String'>
    readonly jobTitle: FieldRef<"Contact", 'String'>
    readonly source: FieldRef<"Contact", 'String'>
    readonly notes: FieldRef<"Contact", 'String'>
    readonly customFields: FieldRef<"Contact", 'Json'>
    readonly createdAt: FieldRef<"Contact", 'DateTime'>
    readonly updatedAt: FieldRef<"Contact", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contact findUnique
   */
  export type ContactFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findUniqueOrThrow
   */
  export type ContactFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact findFirst
   */
  export type ContactFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findFirstOrThrow
   */
  export type ContactFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contact to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contacts.
     */
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact findMany
   */
  export type ContactFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter, which Contacts to fetch.
     */
    where?: ContactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contacts to fetch.
     */
    orderBy?: ContactOrderByWithRelationInput | ContactOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contacts.
     */
    cursor?: ContactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contacts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contacts.
     */
    skip?: number
    distinct?: ContactScalarFieldEnum | ContactScalarFieldEnum[]
  }

  /**
   * Contact create
   */
  export type ContactCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to create a Contact.
     */
    data: XOR<ContactCreateInput, ContactUncheckedCreateInput>
  }

  /**
   * Contact createMany
   */
  export type ContactCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contact createManyAndReturn
   */
  export type ContactCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to create many Contacts.
     */
    data: ContactCreateManyInput | ContactCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact update
   */
  export type ContactUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The data needed to update a Contact.
     */
    data: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
    /**
     * Choose, which Contact to update.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact updateMany
   */
  export type ContactUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
  }

  /**
   * Contact updateManyAndReturn
   */
  export type ContactUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * The data used to update Contacts.
     */
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyInput>
    /**
     * Filter which Contacts to update
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contact upsert
   */
  export type ContactUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * The filter to search for the Contact to update in case it exists.
     */
    where: ContactWhereUniqueInput
    /**
     * In case the Contact found by the `where` argument doesn't exist, create a new Contact with this data.
     */
    create: XOR<ContactCreateInput, ContactUncheckedCreateInput>
    /**
     * In case the Contact was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContactUpdateInput, ContactUncheckedUpdateInput>
  }

  /**
   * Contact delete
   */
  export type ContactDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    /**
     * Filter which Contact to delete.
     */
    where: ContactWhereUniqueInput
  }

  /**
   * Contact deleteMany
   */
  export type ContactDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contacts to delete
     */
    where?: ContactWhereInput
    /**
     * Limit how many Contacts to delete.
     */
    limit?: number
  }

  /**
   * Contact.leads
   */
  export type Contact$leadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    cursor?: LeadWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Contact.interactions
   */
  export type Contact$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Contact.deals
   */
  export type Contact$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Contact.tickets
   */
  export type Contact$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Contact.callLogs
   */
  export type Contact$callLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    cursor?: CallLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * Contact.portalCustomers
   */
  export type Contact$portalCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    where?: PortalCustomerWhereInput
    orderBy?: PortalCustomerOrderByWithRelationInput | PortalCustomerOrderByWithRelationInput[]
    cursor?: PortalCustomerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PortalCustomerScalarFieldEnum | PortalCustomerScalarFieldEnum[]
  }

  /**
   * Contact without action
   */
  export type ContactDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
  }


  /**
   * Model Lead
   */

  export type AggregateLead = {
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  export type LeadAvgAggregateOutputType = {
    value: Decimal | null
  }

  export type LeadSumAggregateOutputType = {
    value: Decimal | null
  }

  export type LeadMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    title: string | null
    source: string | null
    status: $Enums.LeadStatus | null
    value: Decimal | null
    notes: string | null
    convertedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    title: string | null
    source: string | null
    status: $Enums.LeadStatus | null
    value: Decimal | null
    notes: string | null
    convertedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeadCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    title: number
    source: number
    status: number
    value: number
    notes: number
    convertedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeadAvgAggregateInputType = {
    value?: true
  }

  export type LeadSumAggregateInputType = {
    value?: true
  }

  export type LeadMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    title?: true
    source?: true
    status?: true
    value?: true
    notes?: true
    convertedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    title?: true
    source?: true
    status?: true
    value?: true
    notes?: true
    convertedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeadCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    title?: true
    source?: true
    status?: true
    value?: true
    notes?: true
    convertedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lead to aggregate.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leads
    **/
    _count?: true | LeadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeadAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeadSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeadMaxAggregateInputType
  }

  export type GetLeadAggregateType<T extends LeadAggregateArgs> = {
        [P in keyof T & keyof AggregateLead]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLead[P]>
      : GetScalarType<T[P], AggregateLead[P]>
  }




  export type LeadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeadWhereInput
    orderBy?: LeadOrderByWithAggregationInput | LeadOrderByWithAggregationInput[]
    by: LeadScalarFieldEnum[] | LeadScalarFieldEnum
    having?: LeadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeadCountAggregateInputType | true
    _avg?: LeadAvgAggregateInputType
    _sum?: LeadSumAggregateInputType
    _min?: LeadMinAggregateInputType
    _max?: LeadMaxAggregateInputType
  }

  export type LeadGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string | null
    title: string
    source: string
    status: $Enums.LeadStatus
    value: Decimal | null
    notes: string | null
    convertedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LeadCountAggregateOutputType | null
    _avg: LeadAvgAggregateOutputType | null
    _sum: LeadSumAggregateOutputType | null
    _min: LeadMinAggregateOutputType | null
    _max: LeadMaxAggregateOutputType | null
  }

  type GetLeadGroupByPayload<T extends LeadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeadGroupByOutputType[P]>
            : GetScalarType<T[P], LeadGroupByOutputType[P]>
        }
      >
    >


  export type LeadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    title?: boolean
    source?: boolean
    status?: boolean
    value?: boolean
    notes?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
    deals?: boolean | Lead$dealsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    title?: boolean
    source?: boolean
    status?: boolean
    value?: boolean
    notes?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    title?: boolean
    source?: boolean
    status?: boolean
    value?: boolean
    notes?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }, ExtArgs["result"]["lead"]>

  export type LeadSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    title?: boolean
    source?: boolean
    status?: boolean
    value?: boolean
    notes?: boolean
    convertedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "title" | "source" | "status" | "value" | "notes" | "convertedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["lead"]>
  export type LeadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
    deals?: boolean | Lead$dealsArgs<ExtArgs>
    _count?: boolean | LeadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LeadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }
  export type LeadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | Lead$contactArgs<ExtArgs>
  }

  export type $LeadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lead"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
      deals: Prisma.$DealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string | null
      title: string
      source: string
      status: $Enums.LeadStatus
      value: Prisma.Decimal | null
      notes: string | null
      convertedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lead"]>
    composites: {}
  }

  type LeadGetPayload<S extends boolean | null | undefined | LeadDefaultArgs> = $Result.GetResult<Prisma.$LeadPayload, S>

  type LeadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LeadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LeadCountAggregateInputType | true
    }

  export interface LeadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lead'], meta: { name: 'Lead' } }
    /**
     * Find zero or one Lead that matches the filter.
     * @param {LeadFindUniqueArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeadFindUniqueArgs>(args: SelectSubset<T, LeadFindUniqueArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lead that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LeadFindUniqueOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeadFindUniqueOrThrowArgs>(args: SelectSubset<T, LeadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeadFindFirstArgs>(args?: SelectSubset<T, LeadFindFirstArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lead that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindFirstOrThrowArgs} args - Arguments to find a Lead
     * @example
     * // Get one Lead
     * const lead = await prisma.lead.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeadFindFirstOrThrowArgs>(args?: SelectSubset<T, LeadFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Leads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leads
     * const leads = await prisma.lead.findMany()
     * 
     * // Get first 10 Leads
     * const leads = await prisma.lead.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leadWithIdOnly = await prisma.lead.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeadFindManyArgs>(args?: SelectSubset<T, LeadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lead.
     * @param {LeadCreateArgs} args - Arguments to create a Lead.
     * @example
     * // Create one Lead
     * const Lead = await prisma.lead.create({
     *   data: {
     *     // ... data to create a Lead
     *   }
     * })
     * 
     */
    create<T extends LeadCreateArgs>(args: SelectSubset<T, LeadCreateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Leads.
     * @param {LeadCreateManyArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeadCreateManyArgs>(args?: SelectSubset<T, LeadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Leads and returns the data saved in the database.
     * @param {LeadCreateManyAndReturnArgs} args - Arguments to create many Leads.
     * @example
     * // Create many Leads
     * const lead = await prisma.lead.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeadCreateManyAndReturnArgs>(args?: SelectSubset<T, LeadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lead.
     * @param {LeadDeleteArgs} args - Arguments to delete one Lead.
     * @example
     * // Delete one Lead
     * const Lead = await prisma.lead.delete({
     *   where: {
     *     // ... filter to delete one Lead
     *   }
     * })
     * 
     */
    delete<T extends LeadDeleteArgs>(args: SelectSubset<T, LeadDeleteArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lead.
     * @param {LeadUpdateArgs} args - Arguments to update one Lead.
     * @example
     * // Update one Lead
     * const lead = await prisma.lead.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeadUpdateArgs>(args: SelectSubset<T, LeadUpdateArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Leads.
     * @param {LeadDeleteManyArgs} args - Arguments to filter Leads to delete.
     * @example
     * // Delete a few Leads
     * const { count } = await prisma.lead.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeadDeleteManyArgs>(args?: SelectSubset<T, LeadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeadUpdateManyArgs>(args: SelectSubset<T, LeadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leads and returns the data updated in the database.
     * @param {LeadUpdateManyAndReturnArgs} args - Arguments to update many Leads.
     * @example
     * // Update many Leads
     * const lead = await prisma.lead.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Leads and only return the `id`
     * const leadWithIdOnly = await prisma.lead.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LeadUpdateManyAndReturnArgs>(args: SelectSubset<T, LeadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lead.
     * @param {LeadUpsertArgs} args - Arguments to update or create a Lead.
     * @example
     * // Update or create a Lead
     * const lead = await prisma.lead.upsert({
     *   create: {
     *     // ... data to create a Lead
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lead we want to update
     *   }
     * })
     */
    upsert<T extends LeadUpsertArgs>(args: SelectSubset<T, LeadUpsertArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Leads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadCountArgs} args - Arguments to filter Leads to count.
     * @example
     * // Count the number of Leads
     * const count = await prisma.lead.count({
     *   where: {
     *     // ... the filter for the Leads we want to count
     *   }
     * })
    **/
    count<T extends LeadCountArgs>(
      args?: Subset<T, LeadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeadAggregateArgs>(args: Subset<T, LeadAggregateArgs>): Prisma.PrismaPromise<GetLeadAggregateType<T>>

    /**
     * Group by Lead.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeadGroupByArgs['orderBy'] }
        : { orderBy?: LeadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lead model
   */
  readonly fields: LeadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lead.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends Lead$contactArgs<ExtArgs> = {}>(args?: Subset<T, Lead$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deals<T extends Lead$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Lead$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lead model
   */
  interface LeadFieldRefs {
    readonly id: FieldRef<"Lead", 'String'>
    readonly tenantId: FieldRef<"Lead", 'String'>
    readonly contactId: FieldRef<"Lead", 'String'>
    readonly title: FieldRef<"Lead", 'String'>
    readonly source: FieldRef<"Lead", 'String'>
    readonly status: FieldRef<"Lead", 'LeadStatus'>
    readonly value: FieldRef<"Lead", 'Decimal'>
    readonly notes: FieldRef<"Lead", 'String'>
    readonly convertedAt: FieldRef<"Lead", 'DateTime'>
    readonly createdAt: FieldRef<"Lead", 'DateTime'>
    readonly updatedAt: FieldRef<"Lead", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lead findUnique
   */
  export type LeadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findUniqueOrThrow
   */
  export type LeadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead findFirst
   */
  export type LeadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findFirstOrThrow
   */
  export type LeadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Lead to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leads.
     */
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead findMany
   */
  export type LeadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter, which Leads to fetch.
     */
    where?: LeadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leads to fetch.
     */
    orderBy?: LeadOrderByWithRelationInput | LeadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leads.
     */
    cursor?: LeadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leads.
     */
    skip?: number
    distinct?: LeadScalarFieldEnum | LeadScalarFieldEnum[]
  }

  /**
   * Lead create
   */
  export type LeadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to create a Lead.
     */
    data: XOR<LeadCreateInput, LeadUncheckedCreateInput>
  }

  /**
   * Lead createMany
   */
  export type LeadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lead createManyAndReturn
   */
  export type LeadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to create many Leads.
     */
    data: LeadCreateManyInput | LeadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead update
   */
  export type LeadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The data needed to update a Lead.
     */
    data: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
    /**
     * Choose, which Lead to update.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead updateMany
   */
  export type LeadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
  }

  /**
   * Lead updateManyAndReturn
   */
  export type LeadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * The data used to update Leads.
     */
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyInput>
    /**
     * Filter which Leads to update
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lead upsert
   */
  export type LeadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * The filter to search for the Lead to update in case it exists.
     */
    where: LeadWhereUniqueInput
    /**
     * In case the Lead found by the `where` argument doesn't exist, create a new Lead with this data.
     */
    create: XOR<LeadCreateInput, LeadUncheckedCreateInput>
    /**
     * In case the Lead was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeadUpdateInput, LeadUncheckedUpdateInput>
  }

  /**
   * Lead delete
   */
  export type LeadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    /**
     * Filter which Lead to delete.
     */
    where: LeadWhereUniqueInput
  }

  /**
   * Lead deleteMany
   */
  export type LeadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leads to delete
     */
    where?: LeadWhereInput
    /**
     * Limit how many Leads to delete.
     */
    limit?: number
  }

  /**
   * Lead.contact
   */
  export type Lead$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * Lead.deals
   */
  export type Lead$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Lead without action
   */
  export type LeadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
  }


  /**
   * Model Pipeline
   */

  export type AggregatePipeline = {
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  export type PipelineMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    name: string | null
    description: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PipelineCountAggregateOutputType = {
    id: number
    tenantId: number
    name: number
    description: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PipelineMinAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineMaxAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PipelineCountAggregateInputType = {
    id?: true
    tenantId?: true
    name?: true
    description?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PipelineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipeline to aggregate.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pipelines
    **/
    _count?: true | PipelineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PipelineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PipelineMaxAggregateInputType
  }

  export type GetPipelineAggregateType<T extends PipelineAggregateArgs> = {
        [P in keyof T & keyof AggregatePipeline]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePipeline[P]>
      : GetScalarType<T[P], AggregatePipeline[P]>
  }




  export type PipelineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PipelineWhereInput
    orderBy?: PipelineOrderByWithAggregationInput | PipelineOrderByWithAggregationInput[]
    by: PipelineScalarFieldEnum[] | PipelineScalarFieldEnum
    having?: PipelineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PipelineCountAggregateInputType | true
    _min?: PipelineMinAggregateInputType
    _max?: PipelineMaxAggregateInputType
  }

  export type PipelineGroupByOutputType = {
    id: string
    tenantId: string
    name: string
    description: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PipelineCountAggregateOutputType | null
    _min: PipelineMinAggregateOutputType | null
    _max: PipelineMaxAggregateOutputType | null
  }

  type GetPipelineGroupByPayload<T extends PipelineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PipelineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PipelineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PipelineGroupByOutputType[P]>
            : GetScalarType<T[P], PipelineGroupByOutputType[P]>
        }
      >
    >


  export type PipelineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    stages?: boolean | Pipeline$stagesArgs<ExtArgs>
    deals?: boolean | Pipeline$dealsArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pipeline"]>

  export type PipelineSelectScalar = {
    id?: boolean
    tenantId?: boolean
    name?: boolean
    description?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PipelineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "name" | "description" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["pipeline"]>
  export type PipelineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    stages?: boolean | Pipeline$stagesArgs<ExtArgs>
    deals?: boolean | Pipeline$dealsArgs<ExtArgs>
    _count?: boolean | PipelineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PipelineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type PipelineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $PipelinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Pipeline"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      stages: Prisma.$StagePayload<ExtArgs>[]
      deals: Prisma.$DealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      name: string
      description: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pipeline"]>
    composites: {}
  }

  type PipelineGetPayload<S extends boolean | null | undefined | PipelineDefaultArgs> = $Result.GetResult<Prisma.$PipelinePayload, S>

  type PipelineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PipelineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PipelineCountAggregateInputType | true
    }

  export interface PipelineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pipeline'], meta: { name: 'Pipeline' } }
    /**
     * Find zero or one Pipeline that matches the filter.
     * @param {PipelineFindUniqueArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PipelineFindUniqueArgs>(args: SelectSubset<T, PipelineFindUniqueArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Pipeline that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PipelineFindUniqueOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PipelineFindUniqueOrThrowArgs>(args: SelectSubset<T, PipelineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PipelineFindFirstArgs>(args?: SelectSubset<T, PipelineFindFirstArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Pipeline that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindFirstOrThrowArgs} args - Arguments to find a Pipeline
     * @example
     * // Get one Pipeline
     * const pipeline = await prisma.pipeline.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PipelineFindFirstOrThrowArgs>(args?: SelectSubset<T, PipelineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Pipelines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pipelines
     * const pipelines = await prisma.pipeline.findMany()
     * 
     * // Get first 10 Pipelines
     * const pipelines = await prisma.pipeline.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PipelineFindManyArgs>(args?: SelectSubset<T, PipelineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Pipeline.
     * @param {PipelineCreateArgs} args - Arguments to create a Pipeline.
     * @example
     * // Create one Pipeline
     * const Pipeline = await prisma.pipeline.create({
     *   data: {
     *     // ... data to create a Pipeline
     *   }
     * })
     * 
     */
    create<T extends PipelineCreateArgs>(args: SelectSubset<T, PipelineCreateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Pipelines.
     * @param {PipelineCreateManyArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PipelineCreateManyArgs>(args?: SelectSubset<T, PipelineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Pipelines and returns the data saved in the database.
     * @param {PipelineCreateManyAndReturnArgs} args - Arguments to create many Pipelines.
     * @example
     * // Create many Pipelines
     * const pipeline = await prisma.pipeline.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Pipelines and only return the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PipelineCreateManyAndReturnArgs>(args?: SelectSubset<T, PipelineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Pipeline.
     * @param {PipelineDeleteArgs} args - Arguments to delete one Pipeline.
     * @example
     * // Delete one Pipeline
     * const Pipeline = await prisma.pipeline.delete({
     *   where: {
     *     // ... filter to delete one Pipeline
     *   }
     * })
     * 
     */
    delete<T extends PipelineDeleteArgs>(args: SelectSubset<T, PipelineDeleteArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Pipeline.
     * @param {PipelineUpdateArgs} args - Arguments to update one Pipeline.
     * @example
     * // Update one Pipeline
     * const pipeline = await prisma.pipeline.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PipelineUpdateArgs>(args: SelectSubset<T, PipelineUpdateArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Pipelines.
     * @param {PipelineDeleteManyArgs} args - Arguments to filter Pipelines to delete.
     * @example
     * // Delete a few Pipelines
     * const { count } = await prisma.pipeline.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PipelineDeleteManyArgs>(args?: SelectSubset<T, PipelineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PipelineUpdateManyArgs>(args: SelectSubset<T, PipelineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pipelines and returns the data updated in the database.
     * @param {PipelineUpdateManyAndReturnArgs} args - Arguments to update many Pipelines.
     * @example
     * // Update many Pipelines
     * const pipeline = await prisma.pipeline.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Pipelines and only return the `id`
     * const pipelineWithIdOnly = await prisma.pipeline.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PipelineUpdateManyAndReturnArgs>(args: SelectSubset<T, PipelineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Pipeline.
     * @param {PipelineUpsertArgs} args - Arguments to update or create a Pipeline.
     * @example
     * // Update or create a Pipeline
     * const pipeline = await prisma.pipeline.upsert({
     *   create: {
     *     // ... data to create a Pipeline
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pipeline we want to update
     *   }
     * })
     */
    upsert<T extends PipelineUpsertArgs>(args: SelectSubset<T, PipelineUpsertArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Pipelines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineCountArgs} args - Arguments to filter Pipelines to count.
     * @example
     * // Count the number of Pipelines
     * const count = await prisma.pipeline.count({
     *   where: {
     *     // ... the filter for the Pipelines we want to count
     *   }
     * })
    **/
    count<T extends PipelineCountArgs>(
      args?: Subset<T, PipelineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PipelineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PipelineAggregateArgs>(args: Subset<T, PipelineAggregateArgs>): Prisma.PrismaPromise<GetPipelineAggregateType<T>>

    /**
     * Group by Pipeline.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PipelineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PipelineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PipelineGroupByArgs['orderBy'] }
        : { orderBy?: PipelineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PipelineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPipelineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pipeline model
   */
  readonly fields: PipelineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pipeline.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PipelineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stages<T extends Pipeline$stagesArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$stagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deals<T extends Pipeline$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Pipeline$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Pipeline model
   */
  interface PipelineFieldRefs {
    readonly id: FieldRef<"Pipeline", 'String'>
    readonly tenantId: FieldRef<"Pipeline", 'String'>
    readonly name: FieldRef<"Pipeline", 'String'>
    readonly description: FieldRef<"Pipeline", 'String'>
    readonly isActive: FieldRef<"Pipeline", 'Boolean'>
    readonly createdAt: FieldRef<"Pipeline", 'DateTime'>
    readonly updatedAt: FieldRef<"Pipeline", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Pipeline findUnique
   */
  export type PipelineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findUniqueOrThrow
   */
  export type PipelineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline findFirst
   */
  export type PipelineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findFirstOrThrow
   */
  export type PipelineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipeline to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pipelines.
     */
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline findMany
   */
  export type PipelineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter, which Pipelines to fetch.
     */
    where?: PipelineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pipelines to fetch.
     */
    orderBy?: PipelineOrderByWithRelationInput | PipelineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pipelines.
     */
    cursor?: PipelineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pipelines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pipelines.
     */
    skip?: number
    distinct?: PipelineScalarFieldEnum | PipelineScalarFieldEnum[]
  }

  /**
   * Pipeline create
   */
  export type PipelineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to create a Pipeline.
     */
    data: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
  }

  /**
   * Pipeline createMany
   */
  export type PipelineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Pipeline createManyAndReturn
   */
  export type PipelineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data used to create many Pipelines.
     */
    data: PipelineCreateManyInput | PipelineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipeline update
   */
  export type PipelineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The data needed to update a Pipeline.
     */
    data: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
    /**
     * Choose, which Pipeline to update.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline updateMany
   */
  export type PipelineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
  }

  /**
   * Pipeline updateManyAndReturn
   */
  export type PipelineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * The data used to update Pipelines.
     */
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyInput>
    /**
     * Filter which Pipelines to update
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Pipeline upsert
   */
  export type PipelineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * The filter to search for the Pipeline to update in case it exists.
     */
    where: PipelineWhereUniqueInput
    /**
     * In case the Pipeline found by the `where` argument doesn't exist, create a new Pipeline with this data.
     */
    create: XOR<PipelineCreateInput, PipelineUncheckedCreateInput>
    /**
     * In case the Pipeline was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PipelineUpdateInput, PipelineUncheckedUpdateInput>
  }

  /**
   * Pipeline delete
   */
  export type PipelineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
    /**
     * Filter which Pipeline to delete.
     */
    where: PipelineWhereUniqueInput
  }

  /**
   * Pipeline deleteMany
   */
  export type PipelineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pipelines to delete
     */
    where?: PipelineWhereInput
    /**
     * Limit how many Pipelines to delete.
     */
    limit?: number
  }

  /**
   * Pipeline.stages
   */
  export type Pipeline$stagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    where?: StageWhereInput
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    cursor?: StageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Pipeline.deals
   */
  export type Pipeline$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Pipeline without action
   */
  export type PipelineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pipeline
     */
    select?: PipelineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Pipeline
     */
    omit?: PipelineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PipelineInclude<ExtArgs> | null
  }


  /**
   * Model Stage
   */

  export type AggregateStage = {
    _count: StageCountAggregateOutputType | null
    _avg: StageAvgAggregateOutputType | null
    _sum: StageSumAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  export type StageAvgAggregateOutputType = {
    order: number | null
  }

  export type StageSumAggregateOutputType = {
    order: number | null
  }

  export type StageMinAggregateOutputType = {
    id: string | null
    pipelineId: string | null
    name: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageMaxAggregateOutputType = {
    id: string | null
    pipelineId: string | null
    name: string | null
    order: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StageCountAggregateOutputType = {
    id: number
    pipelineId: number
    name: number
    order: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StageAvgAggregateInputType = {
    order?: true
  }

  export type StageSumAggregateInputType = {
    order?: true
  }

  export type StageMinAggregateInputType = {
    id?: true
    pipelineId?: true
    name?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageMaxAggregateInputType = {
    id?: true
    pipelineId?: true
    name?: true
    order?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StageCountAggregateInputType = {
    id?: true
    pipelineId?: true
    name?: true
    order?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stage to aggregate.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stages
    **/
    _count?: true | StageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StageMaxAggregateInputType
  }

  export type GetStageAggregateType<T extends StageAggregateArgs> = {
        [P in keyof T & keyof AggregateStage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStage[P]>
      : GetScalarType<T[P], AggregateStage[P]>
  }




  export type StageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StageWhereInput
    orderBy?: StageOrderByWithAggregationInput | StageOrderByWithAggregationInput[]
    by: StageScalarFieldEnum[] | StageScalarFieldEnum
    having?: StageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StageCountAggregateInputType | true
    _avg?: StageAvgAggregateInputType
    _sum?: StageSumAggregateInputType
    _min?: StageMinAggregateInputType
    _max?: StageMaxAggregateInputType
  }

  export type StageGroupByOutputType = {
    id: string
    pipelineId: string
    name: string
    order: number
    createdAt: Date
    updatedAt: Date
    _count: StageCountAggregateOutputType | null
    _avg: StageAvgAggregateOutputType | null
    _sum: StageSumAggregateOutputType | null
    _min: StageMinAggregateOutputType | null
    _max: StageMaxAggregateOutputType | null
  }

  type GetStageGroupByPayload<T extends StageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StageGroupByOutputType[P]>
            : GetScalarType<T[P], StageGroupByOutputType[P]>
        }
      >
    >


  export type StageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pipelineId?: boolean
    name?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    deals?: boolean | Stage$dealsArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pipelineId?: boolean
    name?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    pipelineId?: boolean
    name?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stage"]>

  export type StageSelectScalar = {
    id?: boolean
    pipelineId?: boolean
    name?: boolean
    order?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "pipelineId" | "name" | "order" | "createdAt" | "updatedAt", ExtArgs["result"]["stage"]>
  export type StageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    deals?: boolean | Stage$dealsArgs<ExtArgs>
    _count?: boolean | StageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }
  export type StageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
  }

  export type $StagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stage"
    objects: {
      pipeline: Prisma.$PipelinePayload<ExtArgs>
      deals: Prisma.$DealPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      pipelineId: string
      name: string
      order: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["stage"]>
    composites: {}
  }

  type StageGetPayload<S extends boolean | null | undefined | StageDefaultArgs> = $Result.GetResult<Prisma.$StagePayload, S>

  type StageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StageCountAggregateInputType | true
    }

  export interface StageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stage'], meta: { name: 'Stage' } }
    /**
     * Find zero or one Stage that matches the filter.
     * @param {StageFindUniqueArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StageFindUniqueArgs>(args: SelectSubset<T, StageFindUniqueArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StageFindUniqueOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StageFindUniqueOrThrowArgs>(args: SelectSubset<T, StageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StageFindFirstArgs>(args?: SelectSubset<T, StageFindFirstArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindFirstOrThrowArgs} args - Arguments to find a Stage
     * @example
     * // Get one Stage
     * const stage = await prisma.stage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StageFindFirstOrThrowArgs>(args?: SelectSubset<T, StageFindFirstOrThrowArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stages
     * const stages = await prisma.stage.findMany()
     * 
     * // Get first 10 Stages
     * const stages = await prisma.stage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stageWithIdOnly = await prisma.stage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StageFindManyArgs>(args?: SelectSubset<T, StageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stage.
     * @param {StageCreateArgs} args - Arguments to create a Stage.
     * @example
     * // Create one Stage
     * const Stage = await prisma.stage.create({
     *   data: {
     *     // ... data to create a Stage
     *   }
     * })
     * 
     */
    create<T extends StageCreateArgs>(args: SelectSubset<T, StageCreateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stages.
     * @param {StageCreateManyArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StageCreateManyArgs>(args?: SelectSubset<T, StageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stages and returns the data saved in the database.
     * @param {StageCreateManyAndReturnArgs} args - Arguments to create many Stages.
     * @example
     * // Create many Stages
     * const stage = await prisma.stage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stages and only return the `id`
     * const stageWithIdOnly = await prisma.stage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StageCreateManyAndReturnArgs>(args?: SelectSubset<T, StageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Stage.
     * @param {StageDeleteArgs} args - Arguments to delete one Stage.
     * @example
     * // Delete one Stage
     * const Stage = await prisma.stage.delete({
     *   where: {
     *     // ... filter to delete one Stage
     *   }
     * })
     * 
     */
    delete<T extends StageDeleteArgs>(args: SelectSubset<T, StageDeleteArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stage.
     * @param {StageUpdateArgs} args - Arguments to update one Stage.
     * @example
     * // Update one Stage
     * const stage = await prisma.stage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StageUpdateArgs>(args: SelectSubset<T, StageUpdateArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stages.
     * @param {StageDeleteManyArgs} args - Arguments to filter Stages to delete.
     * @example
     * // Delete a few Stages
     * const { count } = await prisma.stage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StageDeleteManyArgs>(args?: SelectSubset<T, StageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stages
     * const stage = await prisma.stage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StageUpdateManyArgs>(args: SelectSubset<T, StageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stages and returns the data updated in the database.
     * @param {StageUpdateManyAndReturnArgs} args - Arguments to update many Stages.
     * @example
     * // Update many Stages
     * const stage = await prisma.stage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Stages and only return the `id`
     * const stageWithIdOnly = await prisma.stage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StageUpdateManyAndReturnArgs>(args: SelectSubset<T, StageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Stage.
     * @param {StageUpsertArgs} args - Arguments to update or create a Stage.
     * @example
     * // Update or create a Stage
     * const stage = await prisma.stage.upsert({
     *   create: {
     *     // ... data to create a Stage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stage we want to update
     *   }
     * })
     */
    upsert<T extends StageUpsertArgs>(args: SelectSubset<T, StageUpsertArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageCountArgs} args - Arguments to filter Stages to count.
     * @example
     * // Count the number of Stages
     * const count = await prisma.stage.count({
     *   where: {
     *     // ... the filter for the Stages we want to count
     *   }
     * })
    **/
    count<T extends StageCountArgs>(
      args?: Subset<T, StageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StageAggregateArgs>(args: Subset<T, StageAggregateArgs>): Prisma.PrismaPromise<GetStageAggregateType<T>>

    /**
     * Group by Stage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StageGroupByArgs['orderBy'] }
        : { orderBy?: StageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stage model
   */
  readonly fields: StageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    pipeline<T extends PipelineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelineDefaultArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deals<T extends Stage$dealsArgs<ExtArgs> = {}>(args?: Subset<T, Stage$dealsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stage model
   */
  interface StageFieldRefs {
    readonly id: FieldRef<"Stage", 'String'>
    readonly pipelineId: FieldRef<"Stage", 'String'>
    readonly name: FieldRef<"Stage", 'String'>
    readonly order: FieldRef<"Stage", 'Int'>
    readonly createdAt: FieldRef<"Stage", 'DateTime'>
    readonly updatedAt: FieldRef<"Stage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Stage findUnique
   */
  export type StageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findUniqueOrThrow
   */
  export type StageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage findFirst
   */
  export type StageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findFirstOrThrow
   */
  export type StageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stage to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stages.
     */
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage findMany
   */
  export type StageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter, which Stages to fetch.
     */
    where?: StageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stages to fetch.
     */
    orderBy?: StageOrderByWithRelationInput | StageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stages.
     */
    cursor?: StageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stages.
     */
    skip?: number
    distinct?: StageScalarFieldEnum | StageScalarFieldEnum[]
  }

  /**
   * Stage create
   */
  export type StageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to create a Stage.
     */
    data: XOR<StageCreateInput, StageUncheckedCreateInput>
  }

  /**
   * Stage createMany
   */
  export type StageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stage createManyAndReturn
   */
  export type StageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * The data used to create many Stages.
     */
    data: StageCreateManyInput | StageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stage update
   */
  export type StageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The data needed to update a Stage.
     */
    data: XOR<StageUpdateInput, StageUncheckedUpdateInput>
    /**
     * Choose, which Stage to update.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage updateMany
   */
  export type StageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stages.
     */
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyInput>
    /**
     * Filter which Stages to update
     */
    where?: StageWhereInput
    /**
     * Limit how many Stages to update.
     */
    limit?: number
  }

  /**
   * Stage updateManyAndReturn
   */
  export type StageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * The data used to update Stages.
     */
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyInput>
    /**
     * Filter which Stages to update
     */
    where?: StageWhereInput
    /**
     * Limit how many Stages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Stage upsert
   */
  export type StageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * The filter to search for the Stage to update in case it exists.
     */
    where: StageWhereUniqueInput
    /**
     * In case the Stage found by the `where` argument doesn't exist, create a new Stage with this data.
     */
    create: XOR<StageCreateInput, StageUncheckedCreateInput>
    /**
     * In case the Stage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StageUpdateInput, StageUncheckedUpdateInput>
  }

  /**
   * Stage delete
   */
  export type StageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
    /**
     * Filter which Stage to delete.
     */
    where: StageWhereUniqueInput
  }

  /**
   * Stage deleteMany
   */
  export type StageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stages to delete
     */
    where?: StageWhereInput
    /**
     * Limit how many Stages to delete.
     */
    limit?: number
  }

  /**
   * Stage.deals
   */
  export type Stage$dealsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    cursor?: DealWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Stage without action
   */
  export type StageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stage
     */
    select?: StageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Stage
     */
    omit?: StageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StageInclude<ExtArgs> | null
  }


  /**
   * Model Deal
   */

  export type AggregateDeal = {
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  export type DealAvgAggregateOutputType = {
    value: Decimal | null
    probability: Decimal | null
  }

  export type DealSumAggregateOutputType = {
    value: Decimal | null
    probability: Decimal | null
  }

  export type DealMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    leadId: string | null
    pipelineId: string | null
    stageId: string | null
    title: string | null
    description: string | null
    value: Decimal | null
    probability: Decimal | null
    expectedCloseDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    leadId: string | null
    pipelineId: string | null
    stageId: string | null
    title: string | null
    description: string | null
    value: Decimal | null
    probability: Decimal | null
    expectedCloseDate: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DealCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    leadId: number
    pipelineId: number
    stageId: number
    title: number
    description: number
    value: number
    probability: number
    expectedCloseDate: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DealAvgAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealSumAggregateInputType = {
    value?: true
    probability?: true
  }

  export type DealMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    leadId?: true
    pipelineId?: true
    stageId?: true
    title?: true
    description?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    leadId?: true
    pipelineId?: true
    stageId?: true
    title?: true
    description?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DealCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    leadId?: true
    pipelineId?: true
    stageId?: true
    title?: true
    description?: true
    value?: true
    probability?: true
    expectedCloseDate?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DealAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deal to aggregate.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Deals
    **/
    _count?: true | DealCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DealAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DealSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DealMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DealMaxAggregateInputType
  }

  export type GetDealAggregateType<T extends DealAggregateArgs> = {
        [P in keyof T & keyof AggregateDeal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeal[P]>
      : GetScalarType<T[P], AggregateDeal[P]>
  }




  export type DealGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DealWhereInput
    orderBy?: DealOrderByWithAggregationInput | DealOrderByWithAggregationInput[]
    by: DealScalarFieldEnum[] | DealScalarFieldEnum
    having?: DealScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DealCountAggregateInputType | true
    _avg?: DealAvgAggregateInputType
    _sum?: DealSumAggregateInputType
    _min?: DealMinAggregateInputType
    _max?: DealMaxAggregateInputType
  }

  export type DealGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string
    leadId: string | null
    pipelineId: string
    stageId: string
    title: string
    description: string | null
    value: Decimal | null
    probability: Decimal | null
    expectedCloseDate: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: DealCountAggregateOutputType | null
    _avg: DealAvgAggregateOutputType | null
    _sum: DealSumAggregateOutputType | null
    _min: DealMinAggregateOutputType | null
    _max: DealMaxAggregateOutputType | null
  }

  type GetDealGroupByPayload<T extends DealGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DealGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DealGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DealGroupByOutputType[P]>
            : GetScalarType<T[P], DealGroupByOutputType[P]>
        }
      >
    >


  export type DealSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    pipelineId?: boolean
    stageId?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
    interactions?: boolean | Deal$interactionsArgs<ExtArgs>
    tickets?: boolean | Deal$ticketsArgs<ExtArgs>
    callLogs?: boolean | Deal$callLogsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    pipelineId?: boolean
    stageId?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    pipelineId?: boolean
    stageId?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deal"]>

  export type DealSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    leadId?: boolean
    pipelineId?: boolean
    stageId?: boolean
    title?: boolean
    description?: boolean
    value?: boolean
    probability?: boolean
    expectedCloseDate?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DealOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "leadId" | "pipelineId" | "stageId" | "title" | "description" | "value" | "probability" | "expectedCloseDate" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["deal"]>
  export type DealInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
    interactions?: boolean | Deal$interactionsArgs<ExtArgs>
    tickets?: boolean | Deal$ticketsArgs<ExtArgs>
    callLogs?: boolean | Deal$callLogsArgs<ExtArgs>
    _count?: boolean | DealCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DealIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }
  export type DealIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    lead?: boolean | Deal$leadArgs<ExtArgs>
    pipeline?: boolean | PipelineDefaultArgs<ExtArgs>
    stage?: boolean | StageDefaultArgs<ExtArgs>
  }

  export type $DealPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Deal"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      lead: Prisma.$LeadPayload<ExtArgs> | null
      pipeline: Prisma.$PipelinePayload<ExtArgs>
      stage: Prisma.$StagePayload<ExtArgs>
      interactions: Prisma.$InteractionPayload<ExtArgs>[]
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      callLogs: Prisma.$CallLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string
      leadId: string | null
      pipelineId: string
      stageId: string
      title: string
      description: string | null
      value: Prisma.Decimal | null
      probability: Prisma.Decimal | null
      expectedCloseDate: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["deal"]>
    composites: {}
  }

  type DealGetPayload<S extends boolean | null | undefined | DealDefaultArgs> = $Result.GetResult<Prisma.$DealPayload, S>

  type DealCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DealFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DealCountAggregateInputType | true
    }

  export interface DealDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Deal'], meta: { name: 'Deal' } }
    /**
     * Find zero or one Deal that matches the filter.
     * @param {DealFindUniqueArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DealFindUniqueArgs>(args: SelectSubset<T, DealFindUniqueArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Deal that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DealFindUniqueOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DealFindUniqueOrThrowArgs>(args: SelectSubset<T, DealFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DealFindFirstArgs>(args?: SelectSubset<T, DealFindFirstArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Deal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindFirstOrThrowArgs} args - Arguments to find a Deal
     * @example
     * // Get one Deal
     * const deal = await prisma.deal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DealFindFirstOrThrowArgs>(args?: SelectSubset<T, DealFindFirstOrThrowArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Deals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Deals
     * const deals = await prisma.deal.findMany()
     * 
     * // Get first 10 Deals
     * const deals = await prisma.deal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dealWithIdOnly = await prisma.deal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DealFindManyArgs>(args?: SelectSubset<T, DealFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Deal.
     * @param {DealCreateArgs} args - Arguments to create a Deal.
     * @example
     * // Create one Deal
     * const Deal = await prisma.deal.create({
     *   data: {
     *     // ... data to create a Deal
     *   }
     * })
     * 
     */
    create<T extends DealCreateArgs>(args: SelectSubset<T, DealCreateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Deals.
     * @param {DealCreateManyArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DealCreateManyArgs>(args?: SelectSubset<T, DealCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Deals and returns the data saved in the database.
     * @param {DealCreateManyAndReturnArgs} args - Arguments to create many Deals.
     * @example
     * // Create many Deals
     * const deal = await prisma.deal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DealCreateManyAndReturnArgs>(args?: SelectSubset<T, DealCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Deal.
     * @param {DealDeleteArgs} args - Arguments to delete one Deal.
     * @example
     * // Delete one Deal
     * const Deal = await prisma.deal.delete({
     *   where: {
     *     // ... filter to delete one Deal
     *   }
     * })
     * 
     */
    delete<T extends DealDeleteArgs>(args: SelectSubset<T, DealDeleteArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Deal.
     * @param {DealUpdateArgs} args - Arguments to update one Deal.
     * @example
     * // Update one Deal
     * const deal = await prisma.deal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DealUpdateArgs>(args: SelectSubset<T, DealUpdateArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Deals.
     * @param {DealDeleteManyArgs} args - Arguments to filter Deals to delete.
     * @example
     * // Delete a few Deals
     * const { count } = await prisma.deal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DealDeleteManyArgs>(args?: SelectSubset<T, DealDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DealUpdateManyArgs>(args: SelectSubset<T, DealUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Deals and returns the data updated in the database.
     * @param {DealUpdateManyAndReturnArgs} args - Arguments to update many Deals.
     * @example
     * // Update many Deals
     * const deal = await prisma.deal.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Deals and only return the `id`
     * const dealWithIdOnly = await prisma.deal.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DealUpdateManyAndReturnArgs>(args: SelectSubset<T, DealUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Deal.
     * @param {DealUpsertArgs} args - Arguments to update or create a Deal.
     * @example
     * // Update or create a Deal
     * const deal = await prisma.deal.upsert({
     *   create: {
     *     // ... data to create a Deal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Deal we want to update
     *   }
     * })
     */
    upsert<T extends DealUpsertArgs>(args: SelectSubset<T, DealUpsertArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Deals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealCountArgs} args - Arguments to filter Deals to count.
     * @example
     * // Count the number of Deals
     * const count = await prisma.deal.count({
     *   where: {
     *     // ... the filter for the Deals we want to count
     *   }
     * })
    **/
    count<T extends DealCountArgs>(
      args?: Subset<T, DealCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DealCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DealAggregateArgs>(args: Subset<T, DealAggregateArgs>): Prisma.PrismaPromise<GetDealAggregateType<T>>

    /**
     * Group by Deal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DealGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DealGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DealGroupByArgs['orderBy'] }
        : { orderBy?: DealGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DealGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDealGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Deal model
   */
  readonly fields: DealFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Deal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DealClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lead<T extends Deal$leadArgs<ExtArgs> = {}>(args?: Subset<T, Deal$leadArgs<ExtArgs>>): Prisma__LeadClient<$Result.GetResult<Prisma.$LeadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pipeline<T extends PipelineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PipelineDefaultArgs<ExtArgs>>): Prisma__PipelineClient<$Result.GetResult<Prisma.$PipelinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stage<T extends StageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StageDefaultArgs<ExtArgs>>): Prisma__StageClient<$Result.GetResult<Prisma.$StagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    interactions<T extends Deal$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tickets<T extends Deal$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    callLogs<T extends Deal$callLogsArgs<ExtArgs> = {}>(args?: Subset<T, Deal$callLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Deal model
   */
  interface DealFieldRefs {
    readonly id: FieldRef<"Deal", 'String'>
    readonly tenantId: FieldRef<"Deal", 'String'>
    readonly contactId: FieldRef<"Deal", 'String'>
    readonly leadId: FieldRef<"Deal", 'String'>
    readonly pipelineId: FieldRef<"Deal", 'String'>
    readonly stageId: FieldRef<"Deal", 'String'>
    readonly title: FieldRef<"Deal", 'String'>
    readonly description: FieldRef<"Deal", 'String'>
    readonly value: FieldRef<"Deal", 'Decimal'>
    readonly probability: FieldRef<"Deal", 'Decimal'>
    readonly expectedCloseDate: FieldRef<"Deal", 'DateTime'>
    readonly notes: FieldRef<"Deal", 'String'>
    readonly createdAt: FieldRef<"Deal", 'DateTime'>
    readonly updatedAt: FieldRef<"Deal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Deal findUnique
   */
  export type DealFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findUniqueOrThrow
   */
  export type DealFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal findFirst
   */
  export type DealFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findFirstOrThrow
   */
  export type DealFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deal to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Deals.
     */
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal findMany
   */
  export type DealFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter, which Deals to fetch.
     */
    where?: DealWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Deals to fetch.
     */
    orderBy?: DealOrderByWithRelationInput | DealOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Deals.
     */
    cursor?: DealWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Deals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Deals.
     */
    skip?: number
    distinct?: DealScalarFieldEnum | DealScalarFieldEnum[]
  }

  /**
   * Deal create
   */
  export type DealCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to create a Deal.
     */
    data: XOR<DealCreateInput, DealUncheckedCreateInput>
  }

  /**
   * Deal createMany
   */
  export type DealCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Deal createManyAndReturn
   */
  export type DealCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * The data used to create many Deals.
     */
    data: DealCreateManyInput | DealCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal update
   */
  export type DealUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The data needed to update a Deal.
     */
    data: XOR<DealUpdateInput, DealUncheckedUpdateInput>
    /**
     * Choose, which Deal to update.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal updateMany
   */
  export type DealUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to update.
     */
    limit?: number
  }

  /**
   * Deal updateManyAndReturn
   */
  export type DealUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * The data used to update Deals.
     */
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyInput>
    /**
     * Filter which Deals to update
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Deal upsert
   */
  export type DealUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * The filter to search for the Deal to update in case it exists.
     */
    where: DealWhereUniqueInput
    /**
     * In case the Deal found by the `where` argument doesn't exist, create a new Deal with this data.
     */
    create: XOR<DealCreateInput, DealUncheckedCreateInput>
    /**
     * In case the Deal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DealUpdateInput, DealUncheckedUpdateInput>
  }

  /**
   * Deal delete
   */
  export type DealDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    /**
     * Filter which Deal to delete.
     */
    where: DealWhereUniqueInput
  }

  /**
   * Deal deleteMany
   */
  export type DealDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Deals to delete
     */
    where?: DealWhereInput
    /**
     * Limit how many Deals to delete.
     */
    limit?: number
  }

  /**
   * Deal.lead
   */
  export type Deal$leadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lead
     */
    select?: LeadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lead
     */
    omit?: LeadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeadInclude<ExtArgs> | null
    where?: LeadWhereInput
  }

  /**
   * Deal.interactions
   */
  export type Deal$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    cursor?: InteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Deal.tickets
   */
  export type Deal$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Deal.callLogs
   */
  export type Deal$callLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    cursor?: CallLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * Deal without action
   */
  export type DealDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
  }


  /**
   * Model Interaction
   */

  export type AggregateInteraction = {
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  export type InteractionMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    dealId: string | null
    userId: string | null
    type: $Enums.InteractionType | null
    subject: string | null
    content: string | null
    dateTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InteractionMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    dealId: string | null
    userId: string | null
    type: $Enums.InteractionType | null
    subject: string | null
    content: string | null
    dateTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InteractionCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    dealId: number
    userId: number
    type: number
    subject: number
    content: number
    dateTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InteractionMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    dealId?: true
    userId?: true
    type?: true
    subject?: true
    content?: true
    dateTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InteractionMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    dealId?: true
    userId?: true
    type?: true
    subject?: true
    content?: true
    dateTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InteractionCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    dealId?: true
    userId?: true
    type?: true
    subject?: true
    content?: true
    dateTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interaction to aggregate.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Interactions
    **/
    _count?: true | InteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InteractionMaxAggregateInputType
  }

  export type GetInteractionAggregateType<T extends InteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInteraction[P]>
      : GetScalarType<T[P], AggregateInteraction[P]>
  }




  export type InteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InteractionWhereInput
    orderBy?: InteractionOrderByWithAggregationInput | InteractionOrderByWithAggregationInput[]
    by: InteractionScalarFieldEnum[] | InteractionScalarFieldEnum
    having?: InteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InteractionCountAggregateInputType | true
    _min?: InteractionMinAggregateInputType
    _max?: InteractionMaxAggregateInputType
  }

  export type InteractionGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string
    dealId: string | null
    userId: string | null
    type: $Enums.InteractionType
    subject: string | null
    content: string
    dateTime: Date
    createdAt: Date
    updatedAt: Date
    _count: InteractionCountAggregateOutputType | null
    _min: InteractionMinAggregateOutputType | null
    _max: InteractionMaxAggregateOutputType | null
  }

  type GetInteractionGroupByPayload<T extends InteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InteractionGroupByOutputType[P]>
            : GetScalarType<T[P], InteractionGroupByOutputType[P]>
        }
      >
    >


  export type InteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    dealId?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    dateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    deal?: boolean | Interaction$dealArgs<ExtArgs>
    user?: boolean | Interaction$userArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    dealId?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    dateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    deal?: boolean | Interaction$dealArgs<ExtArgs>
    user?: boolean | Interaction$userArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    dealId?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    dateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    deal?: boolean | Interaction$dealArgs<ExtArgs>
    user?: boolean | Interaction$userArgs<ExtArgs>
  }, ExtArgs["result"]["interaction"]>

  export type InteractionSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    dealId?: boolean
    userId?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    dateTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "dealId" | "userId" | "type" | "subject" | "content" | "dateTime" | "createdAt" | "updatedAt", ExtArgs["result"]["interaction"]>
  export type InteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    deal?: boolean | Interaction$dealArgs<ExtArgs>
    user?: boolean | Interaction$userArgs<ExtArgs>
  }
  export type InteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    deal?: boolean | Interaction$dealArgs<ExtArgs>
    user?: boolean | Interaction$userArgs<ExtArgs>
  }
  export type InteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    deal?: boolean | Interaction$dealArgs<ExtArgs>
    user?: boolean | Interaction$userArgs<ExtArgs>
  }

  export type $InteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Interaction"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      deal: Prisma.$DealPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string
      dealId: string | null
      userId: string | null
      type: $Enums.InteractionType
      subject: string | null
      content: string
      dateTime: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["interaction"]>
    composites: {}
  }

  type InteractionGetPayload<S extends boolean | null | undefined | InteractionDefaultArgs> = $Result.GetResult<Prisma.$InteractionPayload, S>

  type InteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InteractionCountAggregateInputType | true
    }

  export interface InteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Interaction'], meta: { name: 'Interaction' } }
    /**
     * Find zero or one Interaction that matches the filter.
     * @param {InteractionFindUniqueArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InteractionFindUniqueArgs>(args: SelectSubset<T, InteractionFindUniqueArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Interaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InteractionFindUniqueOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InteractionFindFirstArgs>(args?: SelectSubset<T, InteractionFindFirstArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Interaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindFirstOrThrowArgs} args - Arguments to find a Interaction
     * @example
     * // Get one Interaction
     * const interaction = await prisma.interaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Interactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Interactions
     * const interactions = await prisma.interaction.findMany()
     * 
     * // Get first 10 Interactions
     * const interactions = await prisma.interaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const interactionWithIdOnly = await prisma.interaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InteractionFindManyArgs>(args?: SelectSubset<T, InteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Interaction.
     * @param {InteractionCreateArgs} args - Arguments to create a Interaction.
     * @example
     * // Create one Interaction
     * const Interaction = await prisma.interaction.create({
     *   data: {
     *     // ... data to create a Interaction
     *   }
     * })
     * 
     */
    create<T extends InteractionCreateArgs>(args: SelectSubset<T, InteractionCreateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Interactions.
     * @param {InteractionCreateManyArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InteractionCreateManyArgs>(args?: SelectSubset<T, InteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Interactions and returns the data saved in the database.
     * @param {InteractionCreateManyAndReturnArgs} args - Arguments to create many Interactions.
     * @example
     * // Create many Interactions
     * const interaction = await prisma.interaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Interaction.
     * @param {InteractionDeleteArgs} args - Arguments to delete one Interaction.
     * @example
     * // Delete one Interaction
     * const Interaction = await prisma.interaction.delete({
     *   where: {
     *     // ... filter to delete one Interaction
     *   }
     * })
     * 
     */
    delete<T extends InteractionDeleteArgs>(args: SelectSubset<T, InteractionDeleteArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Interaction.
     * @param {InteractionUpdateArgs} args - Arguments to update one Interaction.
     * @example
     * // Update one Interaction
     * const interaction = await prisma.interaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InteractionUpdateArgs>(args: SelectSubset<T, InteractionUpdateArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Interactions.
     * @param {InteractionDeleteManyArgs} args - Arguments to filter Interactions to delete.
     * @example
     * // Delete a few Interactions
     * const { count } = await prisma.interaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InteractionDeleteManyArgs>(args?: SelectSubset<T, InteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InteractionUpdateManyArgs>(args: SelectSubset<T, InteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Interactions and returns the data updated in the database.
     * @param {InteractionUpdateManyAndReturnArgs} args - Arguments to update many Interactions.
     * @example
     * // Update many Interactions
     * const interaction = await prisma.interaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Interactions and only return the `id`
     * const interactionWithIdOnly = await prisma.interaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, InteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Interaction.
     * @param {InteractionUpsertArgs} args - Arguments to update or create a Interaction.
     * @example
     * // Update or create a Interaction
     * const interaction = await prisma.interaction.upsert({
     *   create: {
     *     // ... data to create a Interaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Interaction we want to update
     *   }
     * })
     */
    upsert<T extends InteractionUpsertArgs>(args: SelectSubset<T, InteractionUpsertArgs<ExtArgs>>): Prisma__InteractionClient<$Result.GetResult<Prisma.$InteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Interactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionCountArgs} args - Arguments to filter Interactions to count.
     * @example
     * // Count the number of Interactions
     * const count = await prisma.interaction.count({
     *   where: {
     *     // ... the filter for the Interactions we want to count
     *   }
     * })
    **/
    count<T extends InteractionCountArgs>(
      args?: Subset<T, InteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InteractionAggregateArgs>(args: Subset<T, InteractionAggregateArgs>): Prisma.PrismaPromise<GetInteractionAggregateType<T>>

    /**
     * Group by Interaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InteractionGroupByArgs['orderBy'] }
        : { orderBy?: InteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Interaction model
   */
  readonly fields: InteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Interaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    deal<T extends Interaction$dealArgs<ExtArgs> = {}>(args?: Subset<T, Interaction$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Interaction$userArgs<ExtArgs> = {}>(args?: Subset<T, Interaction$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Interaction model
   */
  interface InteractionFieldRefs {
    readonly id: FieldRef<"Interaction", 'String'>
    readonly tenantId: FieldRef<"Interaction", 'String'>
    readonly contactId: FieldRef<"Interaction", 'String'>
    readonly dealId: FieldRef<"Interaction", 'String'>
    readonly userId: FieldRef<"Interaction", 'String'>
    readonly type: FieldRef<"Interaction", 'InteractionType'>
    readonly subject: FieldRef<"Interaction", 'String'>
    readonly content: FieldRef<"Interaction", 'String'>
    readonly dateTime: FieldRef<"Interaction", 'DateTime'>
    readonly createdAt: FieldRef<"Interaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Interaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Interaction findUnique
   */
  export type InteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findUniqueOrThrow
   */
  export type InteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction findFirst
   */
  export type InteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findFirstOrThrow
   */
  export type InteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interaction to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Interactions.
     */
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction findMany
   */
  export type InteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter, which Interactions to fetch.
     */
    where?: InteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Interactions to fetch.
     */
    orderBy?: InteractionOrderByWithRelationInput | InteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Interactions.
     */
    cursor?: InteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Interactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Interactions.
     */
    skip?: number
    distinct?: InteractionScalarFieldEnum | InteractionScalarFieldEnum[]
  }

  /**
   * Interaction create
   */
  export type InteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Interaction.
     */
    data: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
  }

  /**
   * Interaction createMany
   */
  export type InteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Interaction createManyAndReturn
   */
  export type InteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to create many Interactions.
     */
    data: InteractionCreateManyInput | InteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction update
   */
  export type InteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Interaction.
     */
    data: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
    /**
     * Choose, which Interaction to update.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction updateMany
   */
  export type InteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to update.
     */
    limit?: number
  }

  /**
   * Interaction updateManyAndReturn
   */
  export type InteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * The data used to update Interactions.
     */
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyInput>
    /**
     * Filter which Interactions to update
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Interaction upsert
   */
  export type InteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Interaction to update in case it exists.
     */
    where: InteractionWhereUniqueInput
    /**
     * In case the Interaction found by the `where` argument doesn't exist, create a new Interaction with this data.
     */
    create: XOR<InteractionCreateInput, InteractionUncheckedCreateInput>
    /**
     * In case the Interaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InteractionUpdateInput, InteractionUncheckedUpdateInput>
  }

  /**
   * Interaction delete
   */
  export type InteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
    /**
     * Filter which Interaction to delete.
     */
    where: InteractionWhereUniqueInput
  }

  /**
   * Interaction deleteMany
   */
  export type InteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Interactions to delete
     */
    where?: InteractionWhereInput
    /**
     * Limit how many Interactions to delete.
     */
    limit?: number
  }

  /**
   * Interaction.deal
   */
  export type Interaction$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Interaction.user
   */
  export type Interaction$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Interaction without action
   */
  export type InteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Interaction
     */
    select?: InteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Interaction
     */
    omit?: InteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InteractionInclude<ExtArgs> | null
  }


  /**
   * Model Ticket
   */

  export type AggregateTicket = {
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  export type TicketMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    portalCustomerId: string | null
    dealId: string | null
    externalId: string | null
    externalSystem: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    source: $Enums.TicketSource | null
    submittedByPortalCustomer: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedUserId: string | null
  }

  export type TicketMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    portalCustomerId: string | null
    dealId: string | null
    externalId: string | null
    externalSystem: string | null
    title: string | null
    description: string | null
    status: $Enums.TicketStatus | null
    priority: $Enums.TicketPriority | null
    source: $Enums.TicketSource | null
    submittedByPortalCustomer: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    assignedUserId: string | null
  }

  export type TicketCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    portalCustomerId: number
    dealId: number
    externalId: number
    externalSystem: number
    title: number
    description: number
    status: number
    priority: number
    source: number
    submittedByPortalCustomer: number
    createdAt: number
    updatedAt: number
    assignedUserId: number
    _all: number
  }


  export type TicketMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    portalCustomerId?: true
    dealId?: true
    externalId?: true
    externalSystem?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    source?: true
    submittedByPortalCustomer?: true
    createdAt?: true
    updatedAt?: true
    assignedUserId?: true
  }

  export type TicketMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    portalCustomerId?: true
    dealId?: true
    externalId?: true
    externalSystem?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    source?: true
    submittedByPortalCustomer?: true
    createdAt?: true
    updatedAt?: true
    assignedUserId?: true
  }

  export type TicketCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    portalCustomerId?: true
    dealId?: true
    externalId?: true
    externalSystem?: true
    title?: true
    description?: true
    status?: true
    priority?: true
    source?: true
    submittedByPortalCustomer?: true
    createdAt?: true
    updatedAt?: true
    assignedUserId?: true
    _all?: true
  }

  export type TicketAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Ticket to aggregate.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tickets
    **/
    _count?: true | TicketCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketMaxAggregateInputType
  }

  export type GetTicketAggregateType<T extends TicketAggregateArgs> = {
        [P in keyof T & keyof AggregateTicket]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicket[P]>
      : GetScalarType<T[P], AggregateTicket[P]>
  }




  export type TicketGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithAggregationInput | TicketOrderByWithAggregationInput[]
    by: TicketScalarFieldEnum[] | TicketScalarFieldEnum
    having?: TicketScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCountAggregateInputType | true
    _min?: TicketMinAggregateInputType
    _max?: TicketMaxAggregateInputType
  }

  export type TicketGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string
    portalCustomerId: string | null
    dealId: string | null
    externalId: string | null
    externalSystem: string | null
    title: string
    description: string | null
    status: $Enums.TicketStatus
    priority: $Enums.TicketPriority
    source: $Enums.TicketSource
    submittedByPortalCustomer: boolean
    createdAt: Date
    updatedAt: Date
    assignedUserId: string | null
    _count: TicketCountAggregateOutputType | null
    _min: TicketMinAggregateOutputType | null
    _max: TicketMaxAggregateOutputType | null
  }

  type GetTicketGroupByPayload<T extends TicketGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketGroupByOutputType[P]>
            : GetScalarType<T[P], TicketGroupByOutputType[P]>
        }
      >
    >


  export type TicketSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    portalCustomerId?: boolean
    dealId?: boolean
    externalId?: boolean
    externalSystem?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    source?: boolean
    submittedByPortalCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    portalCustomer?: boolean | Ticket$portalCustomerArgs<ExtArgs>
    deal?: boolean | Ticket$dealArgs<ExtArgs>
    assignedUser?: boolean | Ticket$assignedUserArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    portalCustomerId?: boolean
    dealId?: boolean
    externalId?: boolean
    externalSystem?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    source?: boolean
    submittedByPortalCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    portalCustomer?: boolean | Ticket$portalCustomerArgs<ExtArgs>
    deal?: boolean | Ticket$dealArgs<ExtArgs>
    assignedUser?: boolean | Ticket$assignedUserArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    portalCustomerId?: boolean
    dealId?: boolean
    externalId?: boolean
    externalSystem?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    source?: boolean
    submittedByPortalCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    portalCustomer?: boolean | Ticket$portalCustomerArgs<ExtArgs>
    deal?: boolean | Ticket$dealArgs<ExtArgs>
    assignedUser?: boolean | Ticket$assignedUserArgs<ExtArgs>
  }, ExtArgs["result"]["ticket"]>

  export type TicketSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    portalCustomerId?: boolean
    dealId?: boolean
    externalId?: boolean
    externalSystem?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    source?: boolean
    submittedByPortalCustomer?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    assignedUserId?: boolean
  }

  export type TicketOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "portalCustomerId" | "dealId" | "externalId" | "externalSystem" | "title" | "description" | "status" | "priority" | "source" | "submittedByPortalCustomer" | "createdAt" | "updatedAt" | "assignedUserId", ExtArgs["result"]["ticket"]>
  export type TicketInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    portalCustomer?: boolean | Ticket$portalCustomerArgs<ExtArgs>
    deal?: boolean | Ticket$dealArgs<ExtArgs>
    assignedUser?: boolean | Ticket$assignedUserArgs<ExtArgs>
    comments?: boolean | Ticket$commentsArgs<ExtArgs>
    _count?: boolean | TicketCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TicketIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    portalCustomer?: boolean | Ticket$portalCustomerArgs<ExtArgs>
    deal?: boolean | Ticket$dealArgs<ExtArgs>
    assignedUser?: boolean | Ticket$assignedUserArgs<ExtArgs>
  }
  export type TicketIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | ContactDefaultArgs<ExtArgs>
    portalCustomer?: boolean | Ticket$portalCustomerArgs<ExtArgs>
    deal?: boolean | Ticket$dealArgs<ExtArgs>
    assignedUser?: boolean | Ticket$assignedUserArgs<ExtArgs>
  }

  export type $TicketPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Ticket"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs>
      portalCustomer: Prisma.$PortalCustomerPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
      assignedUser: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$TicketCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string
      portalCustomerId: string | null
      dealId: string | null
      externalId: string | null
      externalSystem: string | null
      title: string
      description: string | null
      status: $Enums.TicketStatus
      priority: $Enums.TicketPriority
      source: $Enums.TicketSource
      submittedByPortalCustomer: boolean
      createdAt: Date
      updatedAt: Date
      assignedUserId: string | null
    }, ExtArgs["result"]["ticket"]>
    composites: {}
  }

  type TicketGetPayload<S extends boolean | null | undefined | TicketDefaultArgs> = $Result.GetResult<Prisma.$TicketPayload, S>

  type TicketCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCountAggregateInputType | true
    }

  export interface TicketDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Ticket'], meta: { name: 'Ticket' } }
    /**
     * Find zero or one Ticket that matches the filter.
     * @param {TicketFindUniqueArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketFindUniqueArgs>(args: SelectSubset<T, TicketFindUniqueArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Ticket that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketFindUniqueOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketFindFirstArgs>(args?: SelectSubset<T, TicketFindFirstArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Ticket that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindFirstOrThrowArgs} args - Arguments to find a Ticket
     * @example
     * // Get one Ticket
     * const ticket = await prisma.ticket.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tickets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tickets
     * const tickets = await prisma.ticket.findMany()
     * 
     * // Get first 10 Tickets
     * const tickets = await prisma.ticket.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketWithIdOnly = await prisma.ticket.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketFindManyArgs>(args?: SelectSubset<T, TicketFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Ticket.
     * @param {TicketCreateArgs} args - Arguments to create a Ticket.
     * @example
     * // Create one Ticket
     * const Ticket = await prisma.ticket.create({
     *   data: {
     *     // ... data to create a Ticket
     *   }
     * })
     * 
     */
    create<T extends TicketCreateArgs>(args: SelectSubset<T, TicketCreateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tickets.
     * @param {TicketCreateManyArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCreateManyArgs>(args?: SelectSubset<T, TicketCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tickets and returns the data saved in the database.
     * @param {TicketCreateManyAndReturnArgs} args - Arguments to create many Tickets.
     * @example
     * // Create many Tickets
     * const ticket = await prisma.ticket.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Ticket.
     * @param {TicketDeleteArgs} args - Arguments to delete one Ticket.
     * @example
     * // Delete one Ticket
     * const Ticket = await prisma.ticket.delete({
     *   where: {
     *     // ... filter to delete one Ticket
     *   }
     * })
     * 
     */
    delete<T extends TicketDeleteArgs>(args: SelectSubset<T, TicketDeleteArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Ticket.
     * @param {TicketUpdateArgs} args - Arguments to update one Ticket.
     * @example
     * // Update one Ticket
     * const ticket = await prisma.ticket.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketUpdateArgs>(args: SelectSubset<T, TicketUpdateArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tickets.
     * @param {TicketDeleteManyArgs} args - Arguments to filter Tickets to delete.
     * @example
     * // Delete a few Tickets
     * const { count } = await prisma.ticket.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketDeleteManyArgs>(args?: SelectSubset<T, TicketDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketUpdateManyArgs>(args: SelectSubset<T, TicketUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tickets and returns the data updated in the database.
     * @param {TicketUpdateManyAndReturnArgs} args - Arguments to update many Tickets.
     * @example
     * // Update many Tickets
     * const ticket = await prisma.ticket.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tickets and only return the `id`
     * const ticketWithIdOnly = await prisma.ticket.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Ticket.
     * @param {TicketUpsertArgs} args - Arguments to update or create a Ticket.
     * @example
     * // Update or create a Ticket
     * const ticket = await prisma.ticket.upsert({
     *   create: {
     *     // ... data to create a Ticket
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Ticket we want to update
     *   }
     * })
     */
    upsert<T extends TicketUpsertArgs>(args: SelectSubset<T, TicketUpsertArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tickets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCountArgs} args - Arguments to filter Tickets to count.
     * @example
     * // Count the number of Tickets
     * const count = await prisma.ticket.count({
     *   where: {
     *     // ... the filter for the Tickets we want to count
     *   }
     * })
    **/
    count<T extends TicketCountArgs>(
      args?: Subset<T, TicketCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketAggregateArgs>(args: Subset<T, TicketAggregateArgs>): Prisma.PrismaPromise<GetTicketAggregateType<T>>

    /**
     * Group by Ticket.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketGroupByArgs['orderBy'] }
        : { orderBy?: TicketGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Ticket model
   */
  readonly fields: TicketFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Ticket.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends ContactDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContactDefaultArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    portalCustomer<T extends Ticket$portalCustomerArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$portalCustomerArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deal<T extends Ticket$dealArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assignedUser<T extends Ticket$assignedUserArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$assignedUserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    comments<T extends Ticket$commentsArgs<ExtArgs> = {}>(args?: Subset<T, Ticket$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Ticket model
   */
  interface TicketFieldRefs {
    readonly id: FieldRef<"Ticket", 'String'>
    readonly tenantId: FieldRef<"Ticket", 'String'>
    readonly contactId: FieldRef<"Ticket", 'String'>
    readonly portalCustomerId: FieldRef<"Ticket", 'String'>
    readonly dealId: FieldRef<"Ticket", 'String'>
    readonly externalId: FieldRef<"Ticket", 'String'>
    readonly externalSystem: FieldRef<"Ticket", 'String'>
    readonly title: FieldRef<"Ticket", 'String'>
    readonly description: FieldRef<"Ticket", 'String'>
    readonly status: FieldRef<"Ticket", 'TicketStatus'>
    readonly priority: FieldRef<"Ticket", 'TicketPriority'>
    readonly source: FieldRef<"Ticket", 'TicketSource'>
    readonly submittedByPortalCustomer: FieldRef<"Ticket", 'Boolean'>
    readonly createdAt: FieldRef<"Ticket", 'DateTime'>
    readonly updatedAt: FieldRef<"Ticket", 'DateTime'>
    readonly assignedUserId: FieldRef<"Ticket", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Ticket findUnique
   */
  export type TicketFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findUniqueOrThrow
   */
  export type TicketFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket findFirst
   */
  export type TicketFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findFirstOrThrow
   */
  export type TicketFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Ticket to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tickets.
     */
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket findMany
   */
  export type TicketFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter, which Tickets to fetch.
     */
    where?: TicketWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tickets to fetch.
     */
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tickets.
     */
    cursor?: TicketWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tickets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tickets.
     */
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * Ticket create
   */
  export type TicketCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to create a Ticket.
     */
    data: XOR<TicketCreateInput, TicketUncheckedCreateInput>
  }

  /**
   * Ticket createMany
   */
  export type TicketCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Ticket createManyAndReturn
   */
  export type TicketCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to create many Tickets.
     */
    data: TicketCreateManyInput | TicketCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket update
   */
  export type TicketUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The data needed to update a Ticket.
     */
    data: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
    /**
     * Choose, which Ticket to update.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket updateMany
   */
  export type TicketUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
  }

  /**
   * Ticket updateManyAndReturn
   */
  export type TicketUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * The data used to update Tickets.
     */
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyInput>
    /**
     * Filter which Tickets to update
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Ticket upsert
   */
  export type TicketUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * The filter to search for the Ticket to update in case it exists.
     */
    where: TicketWhereUniqueInput
    /**
     * In case the Ticket found by the `where` argument doesn't exist, create a new Ticket with this data.
     */
    create: XOR<TicketCreateInput, TicketUncheckedCreateInput>
    /**
     * In case the Ticket was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketUpdateInput, TicketUncheckedUpdateInput>
  }

  /**
   * Ticket delete
   */
  export type TicketDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    /**
     * Filter which Ticket to delete.
     */
    where: TicketWhereUniqueInput
  }

  /**
   * Ticket deleteMany
   */
  export type TicketDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tickets to delete
     */
    where?: TicketWhereInput
    /**
     * Limit how many Tickets to delete.
     */
    limit?: number
  }

  /**
   * Ticket.portalCustomer
   */
  export type Ticket$portalCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    where?: PortalCustomerWhereInput
  }

  /**
   * Ticket.deal
   */
  export type Ticket$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * Ticket.assignedUser
   */
  export type Ticket$assignedUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Ticket.comments
   */
  export type Ticket$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * Ticket without action
   */
  export type TicketDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
  }


  /**
   * Model TicketComment
   */

  export type AggregateTicketComment = {
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  export type TicketCommentMinAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    portalCustomerId: string | null
    content: string | null
    authorName: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCommentMaxAggregateOutputType = {
    id: string | null
    ticketId: string | null
    userId: string | null
    portalCustomerId: string | null
    content: string | null
    authorName: string | null
    isInternal: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TicketCommentCountAggregateOutputType = {
    id: number
    ticketId: number
    userId: number
    portalCustomerId: number
    content: number
    authorName: number
    isInternal: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TicketCommentMinAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    portalCustomerId?: true
    content?: true
    authorName?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCommentMaxAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    portalCustomerId?: true
    content?: true
    authorName?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TicketCommentCountAggregateInputType = {
    id?: true
    ticketId?: true
    userId?: true
    portalCustomerId?: true
    content?: true
    authorName?: true
    isInternal?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TicketCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComment to aggregate.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TicketComments
    **/
    _count?: true | TicketCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TicketCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TicketCommentMaxAggregateInputType
  }

  export type GetTicketCommentAggregateType<T extends TicketCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateTicketComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTicketComment[P]>
      : GetScalarType<T[P], AggregateTicketComment[P]>
  }




  export type TicketCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithAggregationInput | TicketCommentOrderByWithAggregationInput[]
    by: TicketCommentScalarFieldEnum[] | TicketCommentScalarFieldEnum
    having?: TicketCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TicketCommentCountAggregateInputType | true
    _min?: TicketCommentMinAggregateInputType
    _max?: TicketCommentMaxAggregateInputType
  }

  export type TicketCommentGroupByOutputType = {
    id: string
    ticketId: string
    userId: string | null
    portalCustomerId: string | null
    content: string
    authorName: string | null
    isInternal: boolean
    createdAt: Date
    updatedAt: Date
    _count: TicketCommentCountAggregateOutputType | null
    _min: TicketCommentMinAggregateOutputType | null
    _max: TicketCommentMaxAggregateOutputType | null
  }

  type GetTicketCommentGroupByPayload<T extends TicketCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TicketCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TicketCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
            : GetScalarType<T[P], TicketCommentGroupByOutputType[P]>
        }
      >
    >


  export type TicketCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    portalCustomerId?: boolean
    content?: boolean
    authorName?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketComment$userArgs<ExtArgs>
    portalCustomer?: boolean | TicketComment$portalCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    portalCustomerId?: boolean
    content?: boolean
    authorName?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketComment$userArgs<ExtArgs>
    portalCustomer?: boolean | TicketComment$portalCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    portalCustomerId?: boolean
    content?: boolean
    authorName?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketComment$userArgs<ExtArgs>
    portalCustomer?: boolean | TicketComment$portalCustomerArgs<ExtArgs>
  }, ExtArgs["result"]["ticketComment"]>

  export type TicketCommentSelectScalar = {
    id?: boolean
    ticketId?: boolean
    userId?: boolean
    portalCustomerId?: boolean
    content?: boolean
    authorName?: boolean
    isInternal?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TicketCommentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "ticketId" | "userId" | "portalCustomerId" | "content" | "authorName" | "isInternal" | "createdAt" | "updatedAt", ExtArgs["result"]["ticketComment"]>
  export type TicketCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketComment$userArgs<ExtArgs>
    portalCustomer?: boolean | TicketComment$portalCustomerArgs<ExtArgs>
  }
  export type TicketCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketComment$userArgs<ExtArgs>
    portalCustomer?: boolean | TicketComment$portalCustomerArgs<ExtArgs>
  }
  export type TicketCommentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    ticket?: boolean | TicketDefaultArgs<ExtArgs>
    user?: boolean | TicketComment$userArgs<ExtArgs>
    portalCustomer?: boolean | TicketComment$portalCustomerArgs<ExtArgs>
  }

  export type $TicketCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TicketComment"
    objects: {
      ticket: Prisma.$TicketPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      portalCustomer: Prisma.$PortalCustomerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ticketId: string
      userId: string | null
      portalCustomerId: string | null
      content: string
      authorName: string | null
      isInternal: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["ticketComment"]>
    composites: {}
  }

  type TicketCommentGetPayload<S extends boolean | null | undefined | TicketCommentDefaultArgs> = $Result.GetResult<Prisma.$TicketCommentPayload, S>

  type TicketCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TicketCommentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TicketCommentCountAggregateInputType | true
    }

  export interface TicketCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TicketComment'], meta: { name: 'TicketComment' } }
    /**
     * Find zero or one TicketComment that matches the filter.
     * @param {TicketCommentFindUniqueArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TicketCommentFindUniqueArgs>(args: SelectSubset<T, TicketCommentFindUniqueArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TicketComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TicketCommentFindUniqueOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TicketCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, TicketCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TicketCommentFindFirstArgs>(args?: SelectSubset<T, TicketCommentFindFirstArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TicketComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindFirstOrThrowArgs} args - Arguments to find a TicketComment
     * @example
     * // Get one TicketComment
     * const ticketComment = await prisma.ticketComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TicketCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, TicketCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TicketComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TicketComments
     * const ticketComments = await prisma.ticketComment.findMany()
     * 
     * // Get first 10 TicketComments
     * const ticketComments = await prisma.ticketComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TicketCommentFindManyArgs>(args?: SelectSubset<T, TicketCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TicketComment.
     * @param {TicketCommentCreateArgs} args - Arguments to create a TicketComment.
     * @example
     * // Create one TicketComment
     * const TicketComment = await prisma.ticketComment.create({
     *   data: {
     *     // ... data to create a TicketComment
     *   }
     * })
     * 
     */
    create<T extends TicketCommentCreateArgs>(args: SelectSubset<T, TicketCommentCreateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TicketComments.
     * @param {TicketCommentCreateManyArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TicketCommentCreateManyArgs>(args?: SelectSubset<T, TicketCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TicketComments and returns the data saved in the database.
     * @param {TicketCommentCreateManyAndReturnArgs} args - Arguments to create many TicketComments.
     * @example
     * // Create many TicketComments
     * const ticketComment = await prisma.ticketComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TicketCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, TicketCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TicketComment.
     * @param {TicketCommentDeleteArgs} args - Arguments to delete one TicketComment.
     * @example
     * // Delete one TicketComment
     * const TicketComment = await prisma.ticketComment.delete({
     *   where: {
     *     // ... filter to delete one TicketComment
     *   }
     * })
     * 
     */
    delete<T extends TicketCommentDeleteArgs>(args: SelectSubset<T, TicketCommentDeleteArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TicketComment.
     * @param {TicketCommentUpdateArgs} args - Arguments to update one TicketComment.
     * @example
     * // Update one TicketComment
     * const ticketComment = await prisma.ticketComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TicketCommentUpdateArgs>(args: SelectSubset<T, TicketCommentUpdateArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TicketComments.
     * @param {TicketCommentDeleteManyArgs} args - Arguments to filter TicketComments to delete.
     * @example
     * // Delete a few TicketComments
     * const { count } = await prisma.ticketComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TicketCommentDeleteManyArgs>(args?: SelectSubset<T, TicketCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TicketCommentUpdateManyArgs>(args: SelectSubset<T, TicketCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TicketComments and returns the data updated in the database.
     * @param {TicketCommentUpdateManyAndReturnArgs} args - Arguments to update many TicketComments.
     * @example
     * // Update many TicketComments
     * const ticketComment = await prisma.ticketComment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TicketComments and only return the `id`
     * const ticketCommentWithIdOnly = await prisma.ticketComment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TicketCommentUpdateManyAndReturnArgs>(args: SelectSubset<T, TicketCommentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TicketComment.
     * @param {TicketCommentUpsertArgs} args - Arguments to update or create a TicketComment.
     * @example
     * // Update or create a TicketComment
     * const ticketComment = await prisma.ticketComment.upsert({
     *   create: {
     *     // ... data to create a TicketComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TicketComment we want to update
     *   }
     * })
     */
    upsert<T extends TicketCommentUpsertArgs>(args: SelectSubset<T, TicketCommentUpsertArgs<ExtArgs>>): Prisma__TicketCommentClient<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TicketComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentCountArgs} args - Arguments to filter TicketComments to count.
     * @example
     * // Count the number of TicketComments
     * const count = await prisma.ticketComment.count({
     *   where: {
     *     // ... the filter for the TicketComments we want to count
     *   }
     * })
    **/
    count<T extends TicketCommentCountArgs>(
      args?: Subset<T, TicketCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TicketCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TicketCommentAggregateArgs>(args: Subset<T, TicketCommentAggregateArgs>): Prisma.PrismaPromise<GetTicketCommentAggregateType<T>>

    /**
     * Group by TicketComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TicketCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TicketCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TicketCommentGroupByArgs['orderBy'] }
        : { orderBy?: TicketCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TicketCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTicketCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TicketComment model
   */
  readonly fields: TicketCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TicketComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TicketCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    ticket<T extends TicketDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TicketDefaultArgs<ExtArgs>>): Prisma__TicketClient<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends TicketComment$userArgs<ExtArgs> = {}>(args?: Subset<T, TicketComment$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    portalCustomer<T extends TicketComment$portalCustomerArgs<ExtArgs> = {}>(args?: Subset<T, TicketComment$portalCustomerArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TicketComment model
   */
  interface TicketCommentFieldRefs {
    readonly id: FieldRef<"TicketComment", 'String'>
    readonly ticketId: FieldRef<"TicketComment", 'String'>
    readonly userId: FieldRef<"TicketComment", 'String'>
    readonly portalCustomerId: FieldRef<"TicketComment", 'String'>
    readonly content: FieldRef<"TicketComment", 'String'>
    readonly authorName: FieldRef<"TicketComment", 'String'>
    readonly isInternal: FieldRef<"TicketComment", 'Boolean'>
    readonly createdAt: FieldRef<"TicketComment", 'DateTime'>
    readonly updatedAt: FieldRef<"TicketComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TicketComment findUnique
   */
  export type TicketCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findUniqueOrThrow
   */
  export type TicketCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment findFirst
   */
  export type TicketCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findFirstOrThrow
   */
  export type TicketCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComment to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TicketComments.
     */
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment findMany
   */
  export type TicketCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter, which TicketComments to fetch.
     */
    where?: TicketCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TicketComments to fetch.
     */
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TicketComments.
     */
    cursor?: TicketCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TicketComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TicketComments.
     */
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * TicketComment create
   */
  export type TicketCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a TicketComment.
     */
    data: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
  }

  /**
   * TicketComment createMany
   */
  export type TicketCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TicketComment createManyAndReturn
   */
  export type TicketCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to create many TicketComments.
     */
    data: TicketCommentCreateManyInput | TicketCommentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment update
   */
  export type TicketCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a TicketComment.
     */
    data: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
    /**
     * Choose, which TicketComment to update.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment updateMany
   */
  export type TicketCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
  }

  /**
   * TicketComment updateManyAndReturn
   */
  export type TicketCommentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * The data used to update TicketComments.
     */
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyInput>
    /**
     * Filter which TicketComments to update
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TicketComment upsert
   */
  export type TicketCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the TicketComment to update in case it exists.
     */
    where: TicketCommentWhereUniqueInput
    /**
     * In case the TicketComment found by the `where` argument doesn't exist, create a new TicketComment with this data.
     */
    create: XOR<TicketCommentCreateInput, TicketCommentUncheckedCreateInput>
    /**
     * In case the TicketComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TicketCommentUpdateInput, TicketCommentUncheckedUpdateInput>
  }

  /**
   * TicketComment delete
   */
  export type TicketCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    /**
     * Filter which TicketComment to delete.
     */
    where: TicketCommentWhereUniqueInput
  }

  /**
   * TicketComment deleteMany
   */
  export type TicketCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TicketComments to delete
     */
    where?: TicketCommentWhereInput
    /**
     * Limit how many TicketComments to delete.
     */
    limit?: number
  }

  /**
   * TicketComment.user
   */
  export type TicketComment$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TicketComment.portalCustomer
   */
  export type TicketComment$portalCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    where?: PortalCustomerWhereInput
  }

  /**
   * TicketComment without action
   */
  export type TicketCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
  }


  /**
   * Model Integration
   */

  export type AggregateIntegration = {
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  export type IntegrationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceName: string | null
    isActive: boolean | null
    lastSyncAt: Date | null
    syncStatus: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceName: string | null
    isActive: boolean | null
    lastSyncAt: Date | null
    syncStatus: string | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type IntegrationCountAggregateOutputType = {
    id: number
    tenantId: number
    serviceName: number
    isActive: number
    config: number
    lastSyncAt: number
    syncStatus: number
    errorMessage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type IntegrationMinAggregateInputType = {
    id?: true
    tenantId?: true
    serviceName?: true
    isActive?: true
    lastSyncAt?: true
    syncStatus?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    serviceName?: true
    isActive?: true
    lastSyncAt?: true
    syncStatus?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type IntegrationCountAggregateInputType = {
    id?: true
    tenantId?: true
    serviceName?: true
    isActive?: true
    config?: true
    lastSyncAt?: true
    syncStatus?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type IntegrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integration to aggregate.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Integrations
    **/
    _count?: true | IntegrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IntegrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IntegrationMaxAggregateInputType
  }

  export type GetIntegrationAggregateType<T extends IntegrationAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration[P]>
      : GetScalarType<T[P], AggregateIntegration[P]>
  }




  export type IntegrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: IntegrationWhereInput
    orderBy?: IntegrationOrderByWithAggregationInput | IntegrationOrderByWithAggregationInput[]
    by: IntegrationScalarFieldEnum[] | IntegrationScalarFieldEnum
    having?: IntegrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IntegrationCountAggregateInputType | true
    _min?: IntegrationMinAggregateInputType
    _max?: IntegrationMaxAggregateInputType
  }

  export type IntegrationGroupByOutputType = {
    id: string
    tenantId: string
    serviceName: string
    isActive: boolean
    config: JsonValue | null
    lastSyncAt: Date | null
    syncStatus: string | null
    errorMessage: string | null
    createdAt: Date
    updatedAt: Date
    _count: IntegrationCountAggregateOutputType | null
    _min: IntegrationMinAggregateOutputType | null
    _max: IntegrationMaxAggregateOutputType | null
  }

  type GetIntegrationGroupByPayload<T extends IntegrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<IntegrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IntegrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
            : GetScalarType<T[P], IntegrationGroupByOutputType[P]>
        }
      >
    >


  export type IntegrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceName?: boolean
    isActive?: boolean
    config?: boolean
    lastSyncAt?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceName?: boolean
    isActive?: boolean
    config?: boolean
    lastSyncAt?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceName?: boolean
    isActive?: boolean
    config?: boolean
    lastSyncAt?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["integration"]>

  export type IntegrationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    serviceName?: boolean
    isActive?: boolean
    config?: boolean
    lastSyncAt?: boolean
    syncStatus?: boolean
    errorMessage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type IntegrationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "serviceName" | "isActive" | "config" | "lastSyncAt" | "syncStatus" | "errorMessage" | "createdAt" | "updatedAt", ExtArgs["result"]["integration"]>
  export type IntegrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type IntegrationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $IntegrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Integration"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      serviceName: string
      isActive: boolean
      config: Prisma.JsonValue | null
      lastSyncAt: Date | null
      syncStatus: string | null
      errorMessage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["integration"]>
    composites: {}
  }

  type IntegrationGetPayload<S extends boolean | null | undefined | IntegrationDefaultArgs> = $Result.GetResult<Prisma.$IntegrationPayload, S>

  type IntegrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<IntegrationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: IntegrationCountAggregateInputType | true
    }

  export interface IntegrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Integration'], meta: { name: 'Integration' } }
    /**
     * Find zero or one Integration that matches the filter.
     * @param {IntegrationFindUniqueArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends IntegrationFindUniqueArgs>(args: SelectSubset<T, IntegrationFindUniqueArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {IntegrationFindUniqueOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends IntegrationFindUniqueOrThrowArgs>(args: SelectSubset<T, IntegrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends IntegrationFindFirstArgs>(args?: SelectSubset<T, IntegrationFindFirstArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindFirstOrThrowArgs} args - Arguments to find a Integration
     * @example
     * // Get one Integration
     * const integration = await prisma.integration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends IntegrationFindFirstOrThrowArgs>(args?: SelectSubset<T, IntegrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integrations
     * const integrations = await prisma.integration.findMany()
     * 
     * // Get first 10 Integrations
     * const integrations = await prisma.integration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integrationWithIdOnly = await prisma.integration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends IntegrationFindManyArgs>(args?: SelectSubset<T, IntegrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration.
     * @param {IntegrationCreateArgs} args - Arguments to create a Integration.
     * @example
     * // Create one Integration
     * const Integration = await prisma.integration.create({
     *   data: {
     *     // ... data to create a Integration
     *   }
     * })
     * 
     */
    create<T extends IntegrationCreateArgs>(args: SelectSubset<T, IntegrationCreateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integrations.
     * @param {IntegrationCreateManyArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends IntegrationCreateManyArgs>(args?: SelectSubset<T, IntegrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Integrations and returns the data saved in the database.
     * @param {IntegrationCreateManyAndReturnArgs} args - Arguments to create many Integrations.
     * @example
     * // Create many Integrations
     * const integration = await prisma.integration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends IntegrationCreateManyAndReturnArgs>(args?: SelectSubset<T, IntegrationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Integration.
     * @param {IntegrationDeleteArgs} args - Arguments to delete one Integration.
     * @example
     * // Delete one Integration
     * const Integration = await prisma.integration.delete({
     *   where: {
     *     // ... filter to delete one Integration
     *   }
     * })
     * 
     */
    delete<T extends IntegrationDeleteArgs>(args: SelectSubset<T, IntegrationDeleteArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration.
     * @param {IntegrationUpdateArgs} args - Arguments to update one Integration.
     * @example
     * // Update one Integration
     * const integration = await prisma.integration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends IntegrationUpdateArgs>(args: SelectSubset<T, IntegrationUpdateArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integrations.
     * @param {IntegrationDeleteManyArgs} args - Arguments to filter Integrations to delete.
     * @example
     * // Delete a few Integrations
     * const { count } = await prisma.integration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends IntegrationDeleteManyArgs>(args?: SelectSubset<T, IntegrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends IntegrationUpdateManyArgs>(args: SelectSubset<T, IntegrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integrations and returns the data updated in the database.
     * @param {IntegrationUpdateManyAndReturnArgs} args - Arguments to update many Integrations.
     * @example
     * // Update many Integrations
     * const integration = await prisma.integration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Integrations and only return the `id`
     * const integrationWithIdOnly = await prisma.integration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends IntegrationUpdateManyAndReturnArgs>(args: SelectSubset<T, IntegrationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Integration.
     * @param {IntegrationUpsertArgs} args - Arguments to update or create a Integration.
     * @example
     * // Update or create a Integration
     * const integration = await prisma.integration.upsert({
     *   create: {
     *     // ... data to create a Integration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration we want to update
     *   }
     * })
     */
    upsert<T extends IntegrationUpsertArgs>(args: SelectSubset<T, IntegrationUpsertArgs<ExtArgs>>): Prisma__IntegrationClient<$Result.GetResult<Prisma.$IntegrationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationCountArgs} args - Arguments to filter Integrations to count.
     * @example
     * // Count the number of Integrations
     * const count = await prisma.integration.count({
     *   where: {
     *     // ... the filter for the Integrations we want to count
     *   }
     * })
    **/
    count<T extends IntegrationCountArgs>(
      args?: Subset<T, IntegrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IntegrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IntegrationAggregateArgs>(args: Subset<T, IntegrationAggregateArgs>): Prisma.PrismaPromise<GetIntegrationAggregateType<T>>

    /**
     * Group by Integration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IntegrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IntegrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IntegrationGroupByArgs['orderBy'] }
        : { orderBy?: IntegrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IntegrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Integration model
   */
  readonly fields: IntegrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Integration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__IntegrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Integration model
   */
  interface IntegrationFieldRefs {
    readonly id: FieldRef<"Integration", 'String'>
    readonly tenantId: FieldRef<"Integration", 'String'>
    readonly serviceName: FieldRef<"Integration", 'String'>
    readonly isActive: FieldRef<"Integration", 'Boolean'>
    readonly config: FieldRef<"Integration", 'Json'>
    readonly lastSyncAt: FieldRef<"Integration", 'DateTime'>
    readonly syncStatus: FieldRef<"Integration", 'String'>
    readonly errorMessage: FieldRef<"Integration", 'String'>
    readonly createdAt: FieldRef<"Integration", 'DateTime'>
    readonly updatedAt: FieldRef<"Integration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Integration findUnique
   */
  export type IntegrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findUniqueOrThrow
   */
  export type IntegrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration findFirst
   */
  export type IntegrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findFirstOrThrow
   */
  export type IntegrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integration to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Integrations.
     */
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration findMany
   */
  export type IntegrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter, which Integrations to fetch.
     */
    where?: IntegrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Integrations to fetch.
     */
    orderBy?: IntegrationOrderByWithRelationInput | IntegrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Integrations.
     */
    cursor?: IntegrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Integrations.
     */
    skip?: number
    distinct?: IntegrationScalarFieldEnum | IntegrationScalarFieldEnum[]
  }

  /**
   * Integration create
   */
  export type IntegrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to create a Integration.
     */
    data: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
  }

  /**
   * Integration createMany
   */
  export type IntegrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Integration createManyAndReturn
   */
  export type IntegrationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to create many Integrations.
     */
    data: IntegrationCreateManyInput | IntegrationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration update
   */
  export type IntegrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The data needed to update a Integration.
     */
    data: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
    /**
     * Choose, which Integration to update.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration updateMany
   */
  export type IntegrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
  }

  /**
   * Integration updateManyAndReturn
   */
  export type IntegrationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * The data used to update Integrations.
     */
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyInput>
    /**
     * Filter which Integrations to update
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Integration upsert
   */
  export type IntegrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * The filter to search for the Integration to update in case it exists.
     */
    where: IntegrationWhereUniqueInput
    /**
     * In case the Integration found by the `where` argument doesn't exist, create a new Integration with this data.
     */
    create: XOR<IntegrationCreateInput, IntegrationUncheckedCreateInput>
    /**
     * In case the Integration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<IntegrationUpdateInput, IntegrationUncheckedUpdateInput>
  }

  /**
   * Integration delete
   */
  export type IntegrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
    /**
     * Filter which Integration to delete.
     */
    where: IntegrationWhereUniqueInput
  }

  /**
   * Integration deleteMany
   */
  export type IntegrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Integrations to delete
     */
    where?: IntegrationWhereInput
    /**
     * Limit how many Integrations to delete.
     */
    limit?: number
  }

  /**
   * Integration without action
   */
  export type IntegrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Integration
     */
    select?: IntegrationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Integration
     */
    omit?: IntegrationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: IntegrationInclude<ExtArgs> | null
  }


  /**
   * Model CallLog
   */

  export type AggregateCallLog = {
    _count: CallLogCountAggregateOutputType | null
    _avg: CallLogAvgAggregateOutputType | null
    _sum: CallLogSumAggregateOutputType | null
    _min: CallLogMinAggregateOutputType | null
    _max: CallLogMaxAggregateOutputType | null
  }

  export type CallLogAvgAggregateOutputType = {
    duration: number | null
  }

  export type CallLogSumAggregateOutputType = {
    duration: number | null
  }

  export type CallLogMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomName: string | null
    callerSupabaseId: string | null
    calleeSupabaseId: string | null
    direction: $Enums.CallDirection | null
    status: string | null
    duration: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    contactId: string | null
    dealId: string | null
  }

  export type CallLogMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    roomName: string | null
    callerSupabaseId: string | null
    calleeSupabaseId: string | null
    direction: $Enums.CallDirection | null
    status: string | null
    duration: number | null
    startTime: Date | null
    endTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    contactId: string | null
    dealId: string | null
  }

  export type CallLogCountAggregateOutputType = {
    id: number
    tenantId: number
    roomName: number
    callerSupabaseId: number
    calleeSupabaseId: number
    direction: number
    status: number
    duration: number
    startTime: number
    endTime: number
    createdAt: number
    updatedAt: number
    contactId: number
    dealId: number
    _all: number
  }


  export type CallLogAvgAggregateInputType = {
    duration?: true
  }

  export type CallLogSumAggregateInputType = {
    duration?: true
  }

  export type CallLogMinAggregateInputType = {
    id?: true
    tenantId?: true
    roomName?: true
    callerSupabaseId?: true
    calleeSupabaseId?: true
    direction?: true
    status?: true
    duration?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
    dealId?: true
  }

  export type CallLogMaxAggregateInputType = {
    id?: true
    tenantId?: true
    roomName?: true
    callerSupabaseId?: true
    calleeSupabaseId?: true
    direction?: true
    status?: true
    duration?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
    dealId?: true
  }

  export type CallLogCountAggregateInputType = {
    id?: true
    tenantId?: true
    roomName?: true
    callerSupabaseId?: true
    calleeSupabaseId?: true
    direction?: true
    status?: true
    duration?: true
    startTime?: true
    endTime?: true
    createdAt?: true
    updatedAt?: true
    contactId?: true
    dealId?: true
    _all?: true
  }

  export type CallLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallLog to aggregate.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallLogs
    **/
    _count?: true | CallLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallLogMaxAggregateInputType
  }

  export type GetCallLogAggregateType<T extends CallLogAggregateArgs> = {
        [P in keyof T & keyof AggregateCallLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallLog[P]>
      : GetScalarType<T[P], AggregateCallLog[P]>
  }




  export type CallLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallLogWhereInput
    orderBy?: CallLogOrderByWithAggregationInput | CallLogOrderByWithAggregationInput[]
    by: CallLogScalarFieldEnum[] | CallLogScalarFieldEnum
    having?: CallLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallLogCountAggregateInputType | true
    _avg?: CallLogAvgAggregateInputType
    _sum?: CallLogSumAggregateInputType
    _min?: CallLogMinAggregateInputType
    _max?: CallLogMaxAggregateInputType
  }

  export type CallLogGroupByOutputType = {
    id: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction: $Enums.CallDirection
    status: string
    duration: number | null
    startTime: Date
    endTime: Date | null
    createdAt: Date
    updatedAt: Date
    contactId: string | null
    dealId: string | null
    _count: CallLogCountAggregateOutputType | null
    _avg: CallLogAvgAggregateOutputType | null
    _sum: CallLogSumAggregateOutputType | null
    _min: CallLogMinAggregateOutputType | null
    _max: CallLogMaxAggregateOutputType | null
  }

  type GetCallLogGroupByPayload<T extends CallLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallLogGroupByOutputType[P]>
            : GetScalarType<T[P], CallLogGroupByOutputType[P]>
        }
      >
    >


  export type CallLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomName?: boolean
    callerSupabaseId?: boolean
    calleeSupabaseId?: boolean
    direction?: boolean
    status?: boolean
    duration?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
    dealId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | CallLog$contactArgs<ExtArgs>
    deal?: boolean | CallLog$dealArgs<ExtArgs>
    recording?: boolean | CallLog$recordingArgs<ExtArgs>
    transcription?: boolean | CallLog$transcriptionArgs<ExtArgs>
  }, ExtArgs["result"]["callLog"]>

  export type CallLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomName?: boolean
    callerSupabaseId?: boolean
    calleeSupabaseId?: boolean
    direction?: boolean
    status?: boolean
    duration?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
    dealId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | CallLog$contactArgs<ExtArgs>
    deal?: boolean | CallLog$dealArgs<ExtArgs>
  }, ExtArgs["result"]["callLog"]>

  export type CallLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    roomName?: boolean
    callerSupabaseId?: boolean
    calleeSupabaseId?: boolean
    direction?: boolean
    status?: boolean
    duration?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
    dealId?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | CallLog$contactArgs<ExtArgs>
    deal?: boolean | CallLog$dealArgs<ExtArgs>
  }, ExtArgs["result"]["callLog"]>

  export type CallLogSelectScalar = {
    id?: boolean
    tenantId?: boolean
    roomName?: boolean
    callerSupabaseId?: boolean
    calleeSupabaseId?: boolean
    direction?: boolean
    status?: boolean
    duration?: boolean
    startTime?: boolean
    endTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contactId?: boolean
    dealId?: boolean
  }

  export type CallLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "roomName" | "callerSupabaseId" | "calleeSupabaseId" | "direction" | "status" | "duration" | "startTime" | "endTime" | "createdAt" | "updatedAt" | "contactId" | "dealId", ExtArgs["result"]["callLog"]>
  export type CallLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | CallLog$contactArgs<ExtArgs>
    deal?: boolean | CallLog$dealArgs<ExtArgs>
    recording?: boolean | CallLog$recordingArgs<ExtArgs>
    transcription?: boolean | CallLog$transcriptionArgs<ExtArgs>
  }
  export type CallLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | CallLog$contactArgs<ExtArgs>
    deal?: boolean | CallLog$dealArgs<ExtArgs>
  }
  export type CallLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | CallLog$contactArgs<ExtArgs>
    deal?: boolean | CallLog$dealArgs<ExtArgs>
  }

  export type $CallLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallLog"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
      deal: Prisma.$DealPayload<ExtArgs> | null
      recording: Prisma.$CallRecordingPayload<ExtArgs> | null
      transcription: Prisma.$CallTranscriptionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      roomName: string
      callerSupabaseId: string
      calleeSupabaseId: string
      direction: $Enums.CallDirection
      status: string
      duration: number | null
      startTime: Date
      endTime: Date | null
      createdAt: Date
      updatedAt: Date
      contactId: string | null
      dealId: string | null
    }, ExtArgs["result"]["callLog"]>
    composites: {}
  }

  type CallLogGetPayload<S extends boolean | null | undefined | CallLogDefaultArgs> = $Result.GetResult<Prisma.$CallLogPayload, S>

  type CallLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallLogCountAggregateInputType | true
    }

  export interface CallLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallLog'], meta: { name: 'CallLog' } }
    /**
     * Find zero or one CallLog that matches the filter.
     * @param {CallLogFindUniqueArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallLogFindUniqueArgs>(args: SelectSubset<T, CallLogFindUniqueArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CallLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallLogFindUniqueOrThrowArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallLogFindUniqueOrThrowArgs>(args: SelectSubset<T, CallLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogFindFirstArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallLogFindFirstArgs>(args?: SelectSubset<T, CallLogFindFirstArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogFindFirstOrThrowArgs} args - Arguments to find a CallLog
     * @example
     * // Get one CallLog
     * const callLog = await prisma.callLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallLogFindFirstOrThrowArgs>(args?: SelectSubset<T, CallLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CallLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallLogs
     * const callLogs = await prisma.callLog.findMany()
     * 
     * // Get first 10 CallLogs
     * const callLogs = await prisma.callLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callLogWithIdOnly = await prisma.callLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallLogFindManyArgs>(args?: SelectSubset<T, CallLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CallLog.
     * @param {CallLogCreateArgs} args - Arguments to create a CallLog.
     * @example
     * // Create one CallLog
     * const CallLog = await prisma.callLog.create({
     *   data: {
     *     // ... data to create a CallLog
     *   }
     * })
     * 
     */
    create<T extends CallLogCreateArgs>(args: SelectSubset<T, CallLogCreateArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CallLogs.
     * @param {CallLogCreateManyArgs} args - Arguments to create many CallLogs.
     * @example
     * // Create many CallLogs
     * const callLog = await prisma.callLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallLogCreateManyArgs>(args?: SelectSubset<T, CallLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallLogs and returns the data saved in the database.
     * @param {CallLogCreateManyAndReturnArgs} args - Arguments to create many CallLogs.
     * @example
     * // Create many CallLogs
     * const callLog = await prisma.callLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallLogs and only return the `id`
     * const callLogWithIdOnly = await prisma.callLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallLogCreateManyAndReturnArgs>(args?: SelectSubset<T, CallLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CallLog.
     * @param {CallLogDeleteArgs} args - Arguments to delete one CallLog.
     * @example
     * // Delete one CallLog
     * const CallLog = await prisma.callLog.delete({
     *   where: {
     *     // ... filter to delete one CallLog
     *   }
     * })
     * 
     */
    delete<T extends CallLogDeleteArgs>(args: SelectSubset<T, CallLogDeleteArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CallLog.
     * @param {CallLogUpdateArgs} args - Arguments to update one CallLog.
     * @example
     * // Update one CallLog
     * const callLog = await prisma.callLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallLogUpdateArgs>(args: SelectSubset<T, CallLogUpdateArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CallLogs.
     * @param {CallLogDeleteManyArgs} args - Arguments to filter CallLogs to delete.
     * @example
     * // Delete a few CallLogs
     * const { count } = await prisma.callLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallLogDeleteManyArgs>(args?: SelectSubset<T, CallLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallLogs
     * const callLog = await prisma.callLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallLogUpdateManyArgs>(args: SelectSubset<T, CallLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallLogs and returns the data updated in the database.
     * @param {CallLogUpdateManyAndReturnArgs} args - Arguments to update many CallLogs.
     * @example
     * // Update many CallLogs
     * const callLog = await prisma.callLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallLogs and only return the `id`
     * const callLogWithIdOnly = await prisma.callLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallLogUpdateManyAndReturnArgs>(args: SelectSubset<T, CallLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CallLog.
     * @param {CallLogUpsertArgs} args - Arguments to update or create a CallLog.
     * @example
     * // Update or create a CallLog
     * const callLog = await prisma.callLog.upsert({
     *   create: {
     *     // ... data to create a CallLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallLog we want to update
     *   }
     * })
     */
    upsert<T extends CallLogUpsertArgs>(args: SelectSubset<T, CallLogUpsertArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CallLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogCountArgs} args - Arguments to filter CallLogs to count.
     * @example
     * // Count the number of CallLogs
     * const count = await prisma.callLog.count({
     *   where: {
     *     // ... the filter for the CallLogs we want to count
     *   }
     * })
    **/
    count<T extends CallLogCountArgs>(
      args?: Subset<T, CallLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallLogAggregateArgs>(args: Subset<T, CallLogAggregateArgs>): Prisma.PrismaPromise<GetCallLogAggregateType<T>>

    /**
     * Group by CallLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallLogGroupByArgs['orderBy'] }
        : { orderBy?: CallLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallLog model
   */
  readonly fields: CallLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends CallLog$contactArgs<ExtArgs> = {}>(args?: Subset<T, CallLog$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    deal<T extends CallLog$dealArgs<ExtArgs> = {}>(args?: Subset<T, CallLog$dealArgs<ExtArgs>>): Prisma__DealClient<$Result.GetResult<Prisma.$DealPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recording<T extends CallLog$recordingArgs<ExtArgs> = {}>(args?: Subset<T, CallLog$recordingArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transcription<T extends CallLog$transcriptionArgs<ExtArgs> = {}>(args?: Subset<T, CallLog$transcriptionArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallLog model
   */
  interface CallLogFieldRefs {
    readonly id: FieldRef<"CallLog", 'String'>
    readonly tenantId: FieldRef<"CallLog", 'String'>
    readonly roomName: FieldRef<"CallLog", 'String'>
    readonly callerSupabaseId: FieldRef<"CallLog", 'String'>
    readonly calleeSupabaseId: FieldRef<"CallLog", 'String'>
    readonly direction: FieldRef<"CallLog", 'CallDirection'>
    readonly status: FieldRef<"CallLog", 'String'>
    readonly duration: FieldRef<"CallLog", 'Int'>
    readonly startTime: FieldRef<"CallLog", 'DateTime'>
    readonly endTime: FieldRef<"CallLog", 'DateTime'>
    readonly createdAt: FieldRef<"CallLog", 'DateTime'>
    readonly updatedAt: FieldRef<"CallLog", 'DateTime'>
    readonly contactId: FieldRef<"CallLog", 'String'>
    readonly dealId: FieldRef<"CallLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CallLog findUnique
   */
  export type CallLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog findUniqueOrThrow
   */
  export type CallLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog findFirst
   */
  export type CallLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallLogs.
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallLogs.
     */
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * CallLog findFirstOrThrow
   */
  export type CallLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLog to fetch.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallLogs.
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallLogs.
     */
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * CallLog findMany
   */
  export type CallLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter, which CallLogs to fetch.
     */
    where?: CallLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallLogs to fetch.
     */
    orderBy?: CallLogOrderByWithRelationInput | CallLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallLogs.
     */
    cursor?: CallLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallLogs.
     */
    skip?: number
    distinct?: CallLogScalarFieldEnum | CallLogScalarFieldEnum[]
  }

  /**
   * CallLog create
   */
  export type CallLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * The data needed to create a CallLog.
     */
    data: XOR<CallLogCreateInput, CallLogUncheckedCreateInput>
  }

  /**
   * CallLog createMany
   */
  export type CallLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallLogs.
     */
    data: CallLogCreateManyInput | CallLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallLog createManyAndReturn
   */
  export type CallLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * The data used to create many CallLogs.
     */
    data: CallLogCreateManyInput | CallLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallLog update
   */
  export type CallLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * The data needed to update a CallLog.
     */
    data: XOR<CallLogUpdateInput, CallLogUncheckedUpdateInput>
    /**
     * Choose, which CallLog to update.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog updateMany
   */
  export type CallLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallLogs.
     */
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyInput>
    /**
     * Filter which CallLogs to update
     */
    where?: CallLogWhereInput
    /**
     * Limit how many CallLogs to update.
     */
    limit?: number
  }

  /**
   * CallLog updateManyAndReturn
   */
  export type CallLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * The data used to update CallLogs.
     */
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyInput>
    /**
     * Filter which CallLogs to update
     */
    where?: CallLogWhereInput
    /**
     * Limit how many CallLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallLog upsert
   */
  export type CallLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * The filter to search for the CallLog to update in case it exists.
     */
    where: CallLogWhereUniqueInput
    /**
     * In case the CallLog found by the `where` argument doesn't exist, create a new CallLog with this data.
     */
    create: XOR<CallLogCreateInput, CallLogUncheckedCreateInput>
    /**
     * In case the CallLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallLogUpdateInput, CallLogUncheckedUpdateInput>
  }

  /**
   * CallLog delete
   */
  export type CallLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
    /**
     * Filter which CallLog to delete.
     */
    where: CallLogWhereUniqueInput
  }

  /**
   * CallLog deleteMany
   */
  export type CallLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallLogs to delete
     */
    where?: CallLogWhereInput
    /**
     * Limit how many CallLogs to delete.
     */
    limit?: number
  }

  /**
   * CallLog.contact
   */
  export type CallLog$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * CallLog.deal
   */
  export type CallLog$dealArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Deal
     */
    select?: DealSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Deal
     */
    omit?: DealOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DealInclude<ExtArgs> | null
    where?: DealWhereInput
  }

  /**
   * CallLog.recording
   */
  export type CallLog$recordingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    where?: CallRecordingWhereInput
  }

  /**
   * CallLog.transcription
   */
  export type CallLog$transcriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    where?: CallTranscriptionWhereInput
  }

  /**
   * CallLog without action
   */
  export type CallLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallLog
     */
    select?: CallLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallLog
     */
    omit?: CallLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallLogInclude<ExtArgs> | null
  }


  /**
   * Model PortalCustomer
   */

  export type AggregatePortalCustomer = {
    _count: PortalCustomerCountAggregateOutputType | null
    _min: PortalCustomerMinAggregateOutputType | null
    _max: PortalCustomerMaxAggregateOutputType | null
  }

  export type PortalCustomerMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    supabaseUserId: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    accessToken: string | null
    fcmToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortalCustomerMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    contactId: string | null
    supabaseUserId: string | null
    email: string | null
    name: string | null
    avatarUrl: string | null
    accessToken: string | null
    fcmToken: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PortalCustomerCountAggregateOutputType = {
    id: number
    tenantId: number
    contactId: number
    supabaseUserId: number
    email: number
    name: number
    avatarUrl: number
    accessToken: number
    fcmToken: number
    pushSubscription: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PortalCustomerMinAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    supabaseUserId?: true
    email?: true
    name?: true
    avatarUrl?: true
    accessToken?: true
    fcmToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortalCustomerMaxAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    supabaseUserId?: true
    email?: true
    name?: true
    avatarUrl?: true
    accessToken?: true
    fcmToken?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PortalCustomerCountAggregateInputType = {
    id?: true
    tenantId?: true
    contactId?: true
    supabaseUserId?: true
    email?: true
    name?: true
    avatarUrl?: true
    accessToken?: true
    fcmToken?: true
    pushSubscription?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PortalCustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortalCustomer to aggregate.
     */
    where?: PortalCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortalCustomers to fetch.
     */
    orderBy?: PortalCustomerOrderByWithRelationInput | PortalCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PortalCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortalCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortalCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PortalCustomers
    **/
    _count?: true | PortalCustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PortalCustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PortalCustomerMaxAggregateInputType
  }

  export type GetPortalCustomerAggregateType<T extends PortalCustomerAggregateArgs> = {
        [P in keyof T & keyof AggregatePortalCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePortalCustomer[P]>
      : GetScalarType<T[P], AggregatePortalCustomer[P]>
  }




  export type PortalCustomerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PortalCustomerWhereInput
    orderBy?: PortalCustomerOrderByWithAggregationInput | PortalCustomerOrderByWithAggregationInput[]
    by: PortalCustomerScalarFieldEnum[] | PortalCustomerScalarFieldEnum
    having?: PortalCustomerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PortalCustomerCountAggregateInputType | true
    _min?: PortalCustomerMinAggregateInputType
    _max?: PortalCustomerMaxAggregateInputType
  }

  export type PortalCustomerGroupByOutputType = {
    id: string
    tenantId: string
    contactId: string | null
    supabaseUserId: string | null
    email: string
    name: string | null
    avatarUrl: string | null
    accessToken: string | null
    fcmToken: string | null
    pushSubscription: JsonValue | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PortalCustomerCountAggregateOutputType | null
    _min: PortalCustomerMinAggregateOutputType | null
    _max: PortalCustomerMaxAggregateOutputType | null
  }

  type GetPortalCustomerGroupByPayload<T extends PortalCustomerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PortalCustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PortalCustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PortalCustomerGroupByOutputType[P]>
            : GetScalarType<T[P], PortalCustomerGroupByOutputType[P]>
        }
      >
    >


  export type PortalCustomerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | PortalCustomer$contactArgs<ExtArgs>
    tickets?: boolean | PortalCustomer$ticketsArgs<ExtArgs>
    ticketComments?: boolean | PortalCustomer$ticketCommentsArgs<ExtArgs>
    _count?: boolean | PortalCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["portalCustomer"]>

  export type PortalCustomerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | PortalCustomer$contactArgs<ExtArgs>
  }, ExtArgs["result"]["portalCustomer"]>

  export type PortalCustomerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | PortalCustomer$contactArgs<ExtArgs>
  }, ExtArgs["result"]["portalCustomer"]>

  export type PortalCustomerSelectScalar = {
    id?: boolean
    tenantId?: boolean
    contactId?: boolean
    supabaseUserId?: boolean
    email?: boolean
    name?: boolean
    avatarUrl?: boolean
    accessToken?: boolean
    fcmToken?: boolean
    pushSubscription?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PortalCustomerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "contactId" | "supabaseUserId" | "email" | "name" | "avatarUrl" | "accessToken" | "fcmToken" | "pushSubscription" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["portalCustomer"]>
  export type PortalCustomerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | PortalCustomer$contactArgs<ExtArgs>
    tickets?: boolean | PortalCustomer$ticketsArgs<ExtArgs>
    ticketComments?: boolean | PortalCustomer$ticketCommentsArgs<ExtArgs>
    _count?: boolean | PortalCustomerCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PortalCustomerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | PortalCustomer$contactArgs<ExtArgs>
  }
  export type PortalCustomerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    contact?: boolean | PortalCustomer$contactArgs<ExtArgs>
  }

  export type $PortalCustomerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PortalCustomer"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      contact: Prisma.$ContactPayload<ExtArgs> | null
      tickets: Prisma.$TicketPayload<ExtArgs>[]
      ticketComments: Prisma.$TicketCommentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      contactId: string | null
      supabaseUserId: string | null
      email: string
      name: string | null
      avatarUrl: string | null
      accessToken: string | null
      fcmToken: string | null
      pushSubscription: Prisma.JsonValue | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["portalCustomer"]>
    composites: {}
  }

  type PortalCustomerGetPayload<S extends boolean | null | undefined | PortalCustomerDefaultArgs> = $Result.GetResult<Prisma.$PortalCustomerPayload, S>

  type PortalCustomerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PortalCustomerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PortalCustomerCountAggregateInputType | true
    }

  export interface PortalCustomerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PortalCustomer'], meta: { name: 'PortalCustomer' } }
    /**
     * Find zero or one PortalCustomer that matches the filter.
     * @param {PortalCustomerFindUniqueArgs} args - Arguments to find a PortalCustomer
     * @example
     * // Get one PortalCustomer
     * const portalCustomer = await prisma.portalCustomer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PortalCustomerFindUniqueArgs>(args: SelectSubset<T, PortalCustomerFindUniqueArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PortalCustomer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PortalCustomerFindUniqueOrThrowArgs} args - Arguments to find a PortalCustomer
     * @example
     * // Get one PortalCustomer
     * const portalCustomer = await prisma.portalCustomer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PortalCustomerFindUniqueOrThrowArgs>(args: SelectSubset<T, PortalCustomerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortalCustomer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCustomerFindFirstArgs} args - Arguments to find a PortalCustomer
     * @example
     * // Get one PortalCustomer
     * const portalCustomer = await prisma.portalCustomer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PortalCustomerFindFirstArgs>(args?: SelectSubset<T, PortalCustomerFindFirstArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PortalCustomer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCustomerFindFirstOrThrowArgs} args - Arguments to find a PortalCustomer
     * @example
     * // Get one PortalCustomer
     * const portalCustomer = await prisma.portalCustomer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PortalCustomerFindFirstOrThrowArgs>(args?: SelectSubset<T, PortalCustomerFindFirstOrThrowArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PortalCustomers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCustomerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PortalCustomers
     * const portalCustomers = await prisma.portalCustomer.findMany()
     * 
     * // Get first 10 PortalCustomers
     * const portalCustomers = await prisma.portalCustomer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const portalCustomerWithIdOnly = await prisma.portalCustomer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PortalCustomerFindManyArgs>(args?: SelectSubset<T, PortalCustomerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PortalCustomer.
     * @param {PortalCustomerCreateArgs} args - Arguments to create a PortalCustomer.
     * @example
     * // Create one PortalCustomer
     * const PortalCustomer = await prisma.portalCustomer.create({
     *   data: {
     *     // ... data to create a PortalCustomer
     *   }
     * })
     * 
     */
    create<T extends PortalCustomerCreateArgs>(args: SelectSubset<T, PortalCustomerCreateArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PortalCustomers.
     * @param {PortalCustomerCreateManyArgs} args - Arguments to create many PortalCustomers.
     * @example
     * // Create many PortalCustomers
     * const portalCustomer = await prisma.portalCustomer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PortalCustomerCreateManyArgs>(args?: SelectSubset<T, PortalCustomerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PortalCustomers and returns the data saved in the database.
     * @param {PortalCustomerCreateManyAndReturnArgs} args - Arguments to create many PortalCustomers.
     * @example
     * // Create many PortalCustomers
     * const portalCustomer = await prisma.portalCustomer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PortalCustomers and only return the `id`
     * const portalCustomerWithIdOnly = await prisma.portalCustomer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PortalCustomerCreateManyAndReturnArgs>(args?: SelectSubset<T, PortalCustomerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PortalCustomer.
     * @param {PortalCustomerDeleteArgs} args - Arguments to delete one PortalCustomer.
     * @example
     * // Delete one PortalCustomer
     * const PortalCustomer = await prisma.portalCustomer.delete({
     *   where: {
     *     // ... filter to delete one PortalCustomer
     *   }
     * })
     * 
     */
    delete<T extends PortalCustomerDeleteArgs>(args: SelectSubset<T, PortalCustomerDeleteArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PortalCustomer.
     * @param {PortalCustomerUpdateArgs} args - Arguments to update one PortalCustomer.
     * @example
     * // Update one PortalCustomer
     * const portalCustomer = await prisma.portalCustomer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PortalCustomerUpdateArgs>(args: SelectSubset<T, PortalCustomerUpdateArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PortalCustomers.
     * @param {PortalCustomerDeleteManyArgs} args - Arguments to filter PortalCustomers to delete.
     * @example
     * // Delete a few PortalCustomers
     * const { count } = await prisma.portalCustomer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PortalCustomerDeleteManyArgs>(args?: SelectSubset<T, PortalCustomerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortalCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCustomerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PortalCustomers
     * const portalCustomer = await prisma.portalCustomer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PortalCustomerUpdateManyArgs>(args: SelectSubset<T, PortalCustomerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PortalCustomers and returns the data updated in the database.
     * @param {PortalCustomerUpdateManyAndReturnArgs} args - Arguments to update many PortalCustomers.
     * @example
     * // Update many PortalCustomers
     * const portalCustomer = await prisma.portalCustomer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PortalCustomers and only return the `id`
     * const portalCustomerWithIdOnly = await prisma.portalCustomer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PortalCustomerUpdateManyAndReturnArgs>(args: SelectSubset<T, PortalCustomerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PortalCustomer.
     * @param {PortalCustomerUpsertArgs} args - Arguments to update or create a PortalCustomer.
     * @example
     * // Update or create a PortalCustomer
     * const portalCustomer = await prisma.portalCustomer.upsert({
     *   create: {
     *     // ... data to create a PortalCustomer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PortalCustomer we want to update
     *   }
     * })
     */
    upsert<T extends PortalCustomerUpsertArgs>(args: SelectSubset<T, PortalCustomerUpsertArgs<ExtArgs>>): Prisma__PortalCustomerClient<$Result.GetResult<Prisma.$PortalCustomerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PortalCustomers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCustomerCountArgs} args - Arguments to filter PortalCustomers to count.
     * @example
     * // Count the number of PortalCustomers
     * const count = await prisma.portalCustomer.count({
     *   where: {
     *     // ... the filter for the PortalCustomers we want to count
     *   }
     * })
    **/
    count<T extends PortalCustomerCountArgs>(
      args?: Subset<T, PortalCustomerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PortalCustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PortalCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PortalCustomerAggregateArgs>(args: Subset<T, PortalCustomerAggregateArgs>): Prisma.PrismaPromise<GetPortalCustomerAggregateType<T>>

    /**
     * Group by PortalCustomer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PortalCustomerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PortalCustomerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PortalCustomerGroupByArgs['orderBy'] }
        : { orderBy?: PortalCustomerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PortalCustomerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPortalCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PortalCustomer model
   */
  readonly fields: PortalCustomerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PortalCustomer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PortalCustomerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contact<T extends PortalCustomer$contactArgs<ExtArgs> = {}>(args?: Subset<T, PortalCustomer$contactArgs<ExtArgs>>): Prisma__ContactClient<$Result.GetResult<Prisma.$ContactPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tickets<T extends PortalCustomer$ticketsArgs<ExtArgs> = {}>(args?: Subset<T, PortalCustomer$ticketsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ticketComments<T extends PortalCustomer$ticketCommentsArgs<ExtArgs> = {}>(args?: Subset<T, PortalCustomer$ticketCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TicketCommentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PortalCustomer model
   */
  interface PortalCustomerFieldRefs {
    readonly id: FieldRef<"PortalCustomer", 'String'>
    readonly tenantId: FieldRef<"PortalCustomer", 'String'>
    readonly contactId: FieldRef<"PortalCustomer", 'String'>
    readonly supabaseUserId: FieldRef<"PortalCustomer", 'String'>
    readonly email: FieldRef<"PortalCustomer", 'String'>
    readonly name: FieldRef<"PortalCustomer", 'String'>
    readonly avatarUrl: FieldRef<"PortalCustomer", 'String'>
    readonly accessToken: FieldRef<"PortalCustomer", 'String'>
    readonly fcmToken: FieldRef<"PortalCustomer", 'String'>
    readonly pushSubscription: FieldRef<"PortalCustomer", 'Json'>
    readonly isActive: FieldRef<"PortalCustomer", 'Boolean'>
    readonly createdAt: FieldRef<"PortalCustomer", 'DateTime'>
    readonly updatedAt: FieldRef<"PortalCustomer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PortalCustomer findUnique
   */
  export type PortalCustomerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * Filter, which PortalCustomer to fetch.
     */
    where: PortalCustomerWhereUniqueInput
  }

  /**
   * PortalCustomer findUniqueOrThrow
   */
  export type PortalCustomerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * Filter, which PortalCustomer to fetch.
     */
    where: PortalCustomerWhereUniqueInput
  }

  /**
   * PortalCustomer findFirst
   */
  export type PortalCustomerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * Filter, which PortalCustomer to fetch.
     */
    where?: PortalCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortalCustomers to fetch.
     */
    orderBy?: PortalCustomerOrderByWithRelationInput | PortalCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortalCustomers.
     */
    cursor?: PortalCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortalCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortalCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortalCustomers.
     */
    distinct?: PortalCustomerScalarFieldEnum | PortalCustomerScalarFieldEnum[]
  }

  /**
   * PortalCustomer findFirstOrThrow
   */
  export type PortalCustomerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * Filter, which PortalCustomer to fetch.
     */
    where?: PortalCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortalCustomers to fetch.
     */
    orderBy?: PortalCustomerOrderByWithRelationInput | PortalCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PortalCustomers.
     */
    cursor?: PortalCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortalCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortalCustomers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PortalCustomers.
     */
    distinct?: PortalCustomerScalarFieldEnum | PortalCustomerScalarFieldEnum[]
  }

  /**
   * PortalCustomer findMany
   */
  export type PortalCustomerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * Filter, which PortalCustomers to fetch.
     */
    where?: PortalCustomerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PortalCustomers to fetch.
     */
    orderBy?: PortalCustomerOrderByWithRelationInput | PortalCustomerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PortalCustomers.
     */
    cursor?: PortalCustomerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PortalCustomers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PortalCustomers.
     */
    skip?: number
    distinct?: PortalCustomerScalarFieldEnum | PortalCustomerScalarFieldEnum[]
  }

  /**
   * PortalCustomer create
   */
  export type PortalCustomerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * The data needed to create a PortalCustomer.
     */
    data: XOR<PortalCustomerCreateInput, PortalCustomerUncheckedCreateInput>
  }

  /**
   * PortalCustomer createMany
   */
  export type PortalCustomerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PortalCustomers.
     */
    data: PortalCustomerCreateManyInput | PortalCustomerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PortalCustomer createManyAndReturn
   */
  export type PortalCustomerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * The data used to create many PortalCustomers.
     */
    data: PortalCustomerCreateManyInput | PortalCustomerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortalCustomer update
   */
  export type PortalCustomerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * The data needed to update a PortalCustomer.
     */
    data: XOR<PortalCustomerUpdateInput, PortalCustomerUncheckedUpdateInput>
    /**
     * Choose, which PortalCustomer to update.
     */
    where: PortalCustomerWhereUniqueInput
  }

  /**
   * PortalCustomer updateMany
   */
  export type PortalCustomerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PortalCustomers.
     */
    data: XOR<PortalCustomerUpdateManyMutationInput, PortalCustomerUncheckedUpdateManyInput>
    /**
     * Filter which PortalCustomers to update
     */
    where?: PortalCustomerWhereInput
    /**
     * Limit how many PortalCustomers to update.
     */
    limit?: number
  }

  /**
   * PortalCustomer updateManyAndReturn
   */
  export type PortalCustomerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * The data used to update PortalCustomers.
     */
    data: XOR<PortalCustomerUpdateManyMutationInput, PortalCustomerUncheckedUpdateManyInput>
    /**
     * Filter which PortalCustomers to update
     */
    where?: PortalCustomerWhereInput
    /**
     * Limit how many PortalCustomers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PortalCustomer upsert
   */
  export type PortalCustomerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * The filter to search for the PortalCustomer to update in case it exists.
     */
    where: PortalCustomerWhereUniqueInput
    /**
     * In case the PortalCustomer found by the `where` argument doesn't exist, create a new PortalCustomer with this data.
     */
    create: XOR<PortalCustomerCreateInput, PortalCustomerUncheckedCreateInput>
    /**
     * In case the PortalCustomer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PortalCustomerUpdateInput, PortalCustomerUncheckedUpdateInput>
  }

  /**
   * PortalCustomer delete
   */
  export type PortalCustomerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
    /**
     * Filter which PortalCustomer to delete.
     */
    where: PortalCustomerWhereUniqueInput
  }

  /**
   * PortalCustomer deleteMany
   */
  export type PortalCustomerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PortalCustomers to delete
     */
    where?: PortalCustomerWhereInput
    /**
     * Limit how many PortalCustomers to delete.
     */
    limit?: number
  }

  /**
   * PortalCustomer.contact
   */
  export type PortalCustomer$contactArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contact
     */
    select?: ContactSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contact
     */
    omit?: ContactOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContactInclude<ExtArgs> | null
    where?: ContactWhereInput
  }

  /**
   * PortalCustomer.tickets
   */
  export type PortalCustomer$ticketsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Ticket
     */
    select?: TicketSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Ticket
     */
    omit?: TicketOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketInclude<ExtArgs> | null
    where?: TicketWhereInput
    orderBy?: TicketOrderByWithRelationInput | TicketOrderByWithRelationInput[]
    cursor?: TicketWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketScalarFieldEnum | TicketScalarFieldEnum[]
  }

  /**
   * PortalCustomer.ticketComments
   */
  export type PortalCustomer$ticketCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TicketComment
     */
    select?: TicketCommentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TicketComment
     */
    omit?: TicketCommentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TicketCommentInclude<ExtArgs> | null
    where?: TicketCommentWhereInput
    orderBy?: TicketCommentOrderByWithRelationInput | TicketCommentOrderByWithRelationInput[]
    cursor?: TicketCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TicketCommentScalarFieldEnum | TicketCommentScalarFieldEnum[]
  }

  /**
   * PortalCustomer without action
   */
  export type PortalCustomerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PortalCustomer
     */
    select?: PortalCustomerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PortalCustomer
     */
    omit?: PortalCustomerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PortalCustomerInclude<ExtArgs> | null
  }


  /**
   * Model UserInvitation
   */

  export type AggregateUserInvitation = {
    _count: UserInvitationCountAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  export type UserInvitationMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    role: $Enums.UserRole | null
    invitedBy: string | null
    token: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInvitationMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    email: string | null
    role: $Enums.UserRole | null
    invitedBy: string | null
    token: string | null
    expiresAt: Date | null
    acceptedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserInvitationCountAggregateOutputType = {
    id: number
    tenantId: number
    email: number
    role: number
    invitedBy: number
    token: number
    expiresAt: number
    acceptedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserInvitationMinAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    role?: true
    invitedBy?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInvitationMaxAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    role?: true
    invitedBy?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserInvitationCountAggregateInputType = {
    id?: true
    tenantId?: true
    email?: true
    role?: true
    invitedBy?: true
    token?: true
    expiresAt?: true
    acceptedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserInvitationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitation to aggregate.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInvitations
    **/
    _count?: true | UserInvitationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInvitationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInvitationMaxAggregateInputType
  }

  export type GetUserInvitationAggregateType<T extends UserInvitationAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInvitation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInvitation[P]>
      : GetScalarType<T[P], AggregateUserInvitation[P]>
  }




  export type UserInvitationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInvitationWhereInput
    orderBy?: UserInvitationOrderByWithAggregationInput | UserInvitationOrderByWithAggregationInput[]
    by: UserInvitationScalarFieldEnum[] | UserInvitationScalarFieldEnum
    having?: UserInvitationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInvitationCountAggregateInputType | true
    _min?: UserInvitationMinAggregateInputType
    _max?: UserInvitationMaxAggregateInputType
  }

  export type UserInvitationGroupByOutputType = {
    id: string
    tenantId: string
    email: string
    role: $Enums.UserRole
    invitedBy: string
    token: string
    expiresAt: Date
    acceptedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserInvitationCountAggregateOutputType | null
    _min: UserInvitationMinAggregateOutputType | null
    _max: UserInvitationMaxAggregateOutputType | null
  }

  type GetUserInvitationGroupByPayload<T extends UserInvitationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInvitationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInvitationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
            : GetScalarType<T[P], UserInvitationGroupByOutputType[P]>
        }
      >
    >


  export type UserInvitationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    role?: boolean
    invitedBy?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    role?: boolean
    invitedBy?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    email?: boolean
    role?: boolean
    invitedBy?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInvitation"]>

  export type UserInvitationSelectScalar = {
    id?: boolean
    tenantId?: boolean
    email?: boolean
    role?: boolean
    invitedBy?: boolean
    token?: boolean
    expiresAt?: boolean
    acceptedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInvitationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "email" | "role" | "invitedBy" | "token" | "expiresAt" | "acceptedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["userInvitation"]>
  export type UserInvitationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInvitationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserInvitationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    invitedByUser?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserInvitationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInvitation"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
      invitedByUser: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      email: string
      role: $Enums.UserRole
      invitedBy: string
      token: string
      expiresAt: Date
      acceptedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userInvitation"]>
    composites: {}
  }

  type UserInvitationGetPayload<S extends boolean | null | undefined | UserInvitationDefaultArgs> = $Result.GetResult<Prisma.$UserInvitationPayload, S>

  type UserInvitationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInvitationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInvitationCountAggregateInputType | true
    }

  export interface UserInvitationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInvitation'], meta: { name: 'UserInvitation' } }
    /**
     * Find zero or one UserInvitation that matches the filter.
     * @param {UserInvitationFindUniqueArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInvitationFindUniqueArgs>(args: SelectSubset<T, UserInvitationFindUniqueArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInvitation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInvitationFindUniqueOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInvitationFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInvitationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInvitation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInvitationFindFirstArgs>(args?: SelectSubset<T, UserInvitationFindFirstArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInvitation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindFirstOrThrowArgs} args - Arguments to find a UserInvitation
     * @example
     * // Get one UserInvitation
     * const userInvitation = await prisma.userInvitation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInvitationFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInvitationFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInvitations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany()
     * 
     * // Get first 10 UserInvitations
     * const userInvitations = await prisma.userInvitation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInvitationFindManyArgs>(args?: SelectSubset<T, UserInvitationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInvitation.
     * @param {UserInvitationCreateArgs} args - Arguments to create a UserInvitation.
     * @example
     * // Create one UserInvitation
     * const UserInvitation = await prisma.userInvitation.create({
     *   data: {
     *     // ... data to create a UserInvitation
     *   }
     * })
     * 
     */
    create<T extends UserInvitationCreateArgs>(args: SelectSubset<T, UserInvitationCreateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInvitations.
     * @param {UserInvitationCreateManyArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInvitationCreateManyArgs>(args?: SelectSubset<T, UserInvitationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInvitations and returns the data saved in the database.
     * @param {UserInvitationCreateManyAndReturnArgs} args - Arguments to create many UserInvitations.
     * @example
     * // Create many UserInvitations
     * const userInvitation = await prisma.userInvitation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInvitations and only return the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInvitationCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInvitationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInvitation.
     * @param {UserInvitationDeleteArgs} args - Arguments to delete one UserInvitation.
     * @example
     * // Delete one UserInvitation
     * const UserInvitation = await prisma.userInvitation.delete({
     *   where: {
     *     // ... filter to delete one UserInvitation
     *   }
     * })
     * 
     */
    delete<T extends UserInvitationDeleteArgs>(args: SelectSubset<T, UserInvitationDeleteArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInvitation.
     * @param {UserInvitationUpdateArgs} args - Arguments to update one UserInvitation.
     * @example
     * // Update one UserInvitation
     * const userInvitation = await prisma.userInvitation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInvitationUpdateArgs>(args: SelectSubset<T, UserInvitationUpdateArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInvitations.
     * @param {UserInvitationDeleteManyArgs} args - Arguments to filter UserInvitations to delete.
     * @example
     * // Delete a few UserInvitations
     * const { count } = await prisma.userInvitation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInvitationDeleteManyArgs>(args?: SelectSubset<T, UserInvitationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInvitations
     * const userInvitation = await prisma.userInvitation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInvitationUpdateManyArgs>(args: SelectSubset<T, UserInvitationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInvitations and returns the data updated in the database.
     * @param {UserInvitationUpdateManyAndReturnArgs} args - Arguments to update many UserInvitations.
     * @example
     * // Update many UserInvitations
     * const userInvitation = await prisma.userInvitation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInvitations and only return the `id`
     * const userInvitationWithIdOnly = await prisma.userInvitation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInvitationUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInvitationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInvitation.
     * @param {UserInvitationUpsertArgs} args - Arguments to update or create a UserInvitation.
     * @example
     * // Update or create a UserInvitation
     * const userInvitation = await prisma.userInvitation.upsert({
     *   create: {
     *     // ... data to create a UserInvitation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInvitation we want to update
     *   }
     * })
     */
    upsert<T extends UserInvitationUpsertArgs>(args: SelectSubset<T, UserInvitationUpsertArgs<ExtArgs>>): Prisma__UserInvitationClient<$Result.GetResult<Prisma.$UserInvitationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInvitations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationCountArgs} args - Arguments to filter UserInvitations to count.
     * @example
     * // Count the number of UserInvitations
     * const count = await prisma.userInvitation.count({
     *   where: {
     *     // ... the filter for the UserInvitations we want to count
     *   }
     * })
    **/
    count<T extends UserInvitationCountArgs>(
      args?: Subset<T, UserInvitationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInvitationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInvitationAggregateArgs>(args: Subset<T, UserInvitationAggregateArgs>): Prisma.PrismaPromise<GetUserInvitationAggregateType<T>>

    /**
     * Group by UserInvitation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInvitationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInvitationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInvitationGroupByArgs['orderBy'] }
        : { orderBy?: UserInvitationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInvitationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInvitationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInvitation model
   */
  readonly fields: UserInvitationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInvitation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInvitationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    invitedByUser<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInvitation model
   */
  interface UserInvitationFieldRefs {
    readonly id: FieldRef<"UserInvitation", 'String'>
    readonly tenantId: FieldRef<"UserInvitation", 'String'>
    readonly email: FieldRef<"UserInvitation", 'String'>
    readonly role: FieldRef<"UserInvitation", 'UserRole'>
    readonly invitedBy: FieldRef<"UserInvitation", 'String'>
    readonly token: FieldRef<"UserInvitation", 'String'>
    readonly expiresAt: FieldRef<"UserInvitation", 'DateTime'>
    readonly acceptedAt: FieldRef<"UserInvitation", 'DateTime'>
    readonly createdAt: FieldRef<"UserInvitation", 'DateTime'>
    readonly updatedAt: FieldRef<"UserInvitation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserInvitation findUnique
   */
  export type UserInvitationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findUniqueOrThrow
   */
  export type UserInvitationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation findFirst
   */
  export type UserInvitationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findFirstOrThrow
   */
  export type UserInvitationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitation to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInvitations.
     */
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation findMany
   */
  export type UserInvitationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter, which UserInvitations to fetch.
     */
    where?: UserInvitationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInvitations to fetch.
     */
    orderBy?: UserInvitationOrderByWithRelationInput | UserInvitationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInvitations.
     */
    cursor?: UserInvitationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserInvitations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInvitations.
     */
    skip?: number
    distinct?: UserInvitationScalarFieldEnum | UserInvitationScalarFieldEnum[]
  }

  /**
   * UserInvitation create
   */
  export type UserInvitationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInvitation.
     */
    data: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
  }

  /**
   * UserInvitation createMany
   */
  export type UserInvitationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInvitation createManyAndReturn
   */
  export type UserInvitationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * The data used to create many UserInvitations.
     */
    data: UserInvitationCreateManyInput | UserInvitationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInvitation update
   */
  export type UserInvitationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInvitation.
     */
    data: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
    /**
     * Choose, which UserInvitation to update.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation updateMany
   */
  export type UserInvitationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInvitations.
     */
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which UserInvitations to update
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to update.
     */
    limit?: number
  }

  /**
   * UserInvitation updateManyAndReturn
   */
  export type UserInvitationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * The data used to update UserInvitations.
     */
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyInput>
    /**
     * Filter which UserInvitations to update
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInvitation upsert
   */
  export type UserInvitationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInvitation to update in case it exists.
     */
    where: UserInvitationWhereUniqueInput
    /**
     * In case the UserInvitation found by the `where` argument doesn't exist, create a new UserInvitation with this data.
     */
    create: XOR<UserInvitationCreateInput, UserInvitationUncheckedCreateInput>
    /**
     * In case the UserInvitation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInvitationUpdateInput, UserInvitationUncheckedUpdateInput>
  }

  /**
   * UserInvitation delete
   */
  export type UserInvitationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
    /**
     * Filter which UserInvitation to delete.
     */
    where: UserInvitationWhereUniqueInput
  }

  /**
   * UserInvitation deleteMany
   */
  export type UserInvitationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInvitations to delete
     */
    where?: UserInvitationWhereInput
    /**
     * Limit how many UserInvitations to delete.
     */
    limit?: number
  }

  /**
   * UserInvitation without action
   */
  export type UserInvitationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInvitation
     */
    select?: UserInvitationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInvitation
     */
    omit?: UserInvitationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInvitationInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tenantId: string | null
    title: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    userId: number
    tenantId: number
    title: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    userId?: true
    tenantId?: true
    title?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    userId: string
    tenantId: string
    title: string | null
    createdAt: Date
    updatedAt: Date
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    userId?: boolean
    tenantId?: boolean
    title?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tenantId" | "title" | "createdAt" | "updatedAt", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | Conversation$messagesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      messages: Prisma.$MessagePayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      tenantId: string
      title: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    messages<T extends Conversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly userId: FieldRef<"Conversation", 'String'>
    readonly tenantId: FieldRef<"Conversation", 'String'>
    readonly title: FieldRef<"Conversation", 'String'>
    readonly createdAt: FieldRef<"Conversation", 'DateTime'>
    readonly updatedAt: FieldRef<"Conversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.messages
   */
  export type Conversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    conversationId: string
    role: string
    content: string
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "role" | "content" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly conversationId: FieldRef<"Message", 'String'>
    readonly role: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model TelegramLinkRequest
   */

  export type AggregateTelegramLinkRequest = {
    _count: TelegramLinkRequestCountAggregateOutputType | null
    _min: TelegramLinkRequestMinAggregateOutputType | null
    _max: TelegramLinkRequestMaxAggregateOutputType | null
  }

  export type TelegramLinkRequestMinAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type TelegramLinkRequestMaxAggregateOutputType = {
    id: string | null
    code: string | null
    userId: string | null
    expiresAt: Date | null
    usedAt: Date | null
    createdAt: Date | null
  }

  export type TelegramLinkRequestCountAggregateOutputType = {
    id: number
    code: number
    userId: number
    expiresAt: number
    usedAt: number
    createdAt: number
    _all: number
  }


  export type TelegramLinkRequestMinAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type TelegramLinkRequestMaxAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
  }

  export type TelegramLinkRequestCountAggregateInputType = {
    id?: true
    code?: true
    userId?: true
    expiresAt?: true
    usedAt?: true
    createdAt?: true
    _all?: true
  }

  export type TelegramLinkRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramLinkRequest to aggregate.
     */
    where?: TelegramLinkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramLinkRequests to fetch.
     */
    orderBy?: TelegramLinkRequestOrderByWithRelationInput | TelegramLinkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramLinkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramLinkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramLinkRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramLinkRequests
    **/
    _count?: true | TelegramLinkRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramLinkRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramLinkRequestMaxAggregateInputType
  }

  export type GetTelegramLinkRequestAggregateType<T extends TelegramLinkRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramLinkRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramLinkRequest[P]>
      : GetScalarType<T[P], AggregateTelegramLinkRequest[P]>
  }




  export type TelegramLinkRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramLinkRequestWhereInput
    orderBy?: TelegramLinkRequestOrderByWithAggregationInput | TelegramLinkRequestOrderByWithAggregationInput[]
    by: TelegramLinkRequestScalarFieldEnum[] | TelegramLinkRequestScalarFieldEnum
    having?: TelegramLinkRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramLinkRequestCountAggregateInputType | true
    _min?: TelegramLinkRequestMinAggregateInputType
    _max?: TelegramLinkRequestMaxAggregateInputType
  }

  export type TelegramLinkRequestGroupByOutputType = {
    id: string
    code: string
    userId: string
    expiresAt: Date
    usedAt: Date | null
    createdAt: Date
    _count: TelegramLinkRequestCountAggregateOutputType | null
    _min: TelegramLinkRequestMinAggregateOutputType | null
    _max: TelegramLinkRequestMaxAggregateOutputType | null
  }

  type GetTelegramLinkRequestGroupByPayload<T extends TelegramLinkRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramLinkRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramLinkRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramLinkRequestGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramLinkRequestGroupByOutputType[P]>
        }
      >
    >


  export type TelegramLinkRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramLinkRequest"]>

  export type TelegramLinkRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramLinkRequest"]>

  export type TelegramLinkRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramLinkRequest"]>

  export type TelegramLinkRequestSelectScalar = {
    id?: boolean
    code?: boolean
    userId?: boolean
    expiresAt?: boolean
    usedAt?: boolean
    createdAt?: boolean
  }

  export type TelegramLinkRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "userId" | "expiresAt" | "usedAt" | "createdAt", ExtArgs["result"]["telegramLinkRequest"]>
  export type TelegramLinkRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramLinkRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramLinkRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TelegramLinkRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramLinkRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      userId: string
      expiresAt: Date
      usedAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["telegramLinkRequest"]>
    composites: {}
  }

  type TelegramLinkRequestGetPayload<S extends boolean | null | undefined | TelegramLinkRequestDefaultArgs> = $Result.GetResult<Prisma.$TelegramLinkRequestPayload, S>

  type TelegramLinkRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelegramLinkRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelegramLinkRequestCountAggregateInputType | true
    }

  export interface TelegramLinkRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramLinkRequest'], meta: { name: 'TelegramLinkRequest' } }
    /**
     * Find zero or one TelegramLinkRequest that matches the filter.
     * @param {TelegramLinkRequestFindUniqueArgs} args - Arguments to find a TelegramLinkRequest
     * @example
     * // Get one TelegramLinkRequest
     * const telegramLinkRequest = await prisma.telegramLinkRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelegramLinkRequestFindUniqueArgs>(args: SelectSubset<T, TelegramLinkRequestFindUniqueArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelegramLinkRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelegramLinkRequestFindUniqueOrThrowArgs} args - Arguments to find a TelegramLinkRequest
     * @example
     * // Get one TelegramLinkRequest
     * const telegramLinkRequest = await prisma.telegramLinkRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelegramLinkRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, TelegramLinkRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramLinkRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramLinkRequestFindFirstArgs} args - Arguments to find a TelegramLinkRequest
     * @example
     * // Get one TelegramLinkRequest
     * const telegramLinkRequest = await prisma.telegramLinkRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelegramLinkRequestFindFirstArgs>(args?: SelectSubset<T, TelegramLinkRequestFindFirstArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramLinkRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramLinkRequestFindFirstOrThrowArgs} args - Arguments to find a TelegramLinkRequest
     * @example
     * // Get one TelegramLinkRequest
     * const telegramLinkRequest = await prisma.telegramLinkRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelegramLinkRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, TelegramLinkRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelegramLinkRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramLinkRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramLinkRequests
     * const telegramLinkRequests = await prisma.telegramLinkRequest.findMany()
     * 
     * // Get first 10 TelegramLinkRequests
     * const telegramLinkRequests = await prisma.telegramLinkRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramLinkRequestWithIdOnly = await prisma.telegramLinkRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelegramLinkRequestFindManyArgs>(args?: SelectSubset<T, TelegramLinkRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelegramLinkRequest.
     * @param {TelegramLinkRequestCreateArgs} args - Arguments to create a TelegramLinkRequest.
     * @example
     * // Create one TelegramLinkRequest
     * const TelegramLinkRequest = await prisma.telegramLinkRequest.create({
     *   data: {
     *     // ... data to create a TelegramLinkRequest
     *   }
     * })
     * 
     */
    create<T extends TelegramLinkRequestCreateArgs>(args: SelectSubset<T, TelegramLinkRequestCreateArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelegramLinkRequests.
     * @param {TelegramLinkRequestCreateManyArgs} args - Arguments to create many TelegramLinkRequests.
     * @example
     * // Create many TelegramLinkRequests
     * const telegramLinkRequest = await prisma.telegramLinkRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelegramLinkRequestCreateManyArgs>(args?: SelectSubset<T, TelegramLinkRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelegramLinkRequests and returns the data saved in the database.
     * @param {TelegramLinkRequestCreateManyAndReturnArgs} args - Arguments to create many TelegramLinkRequests.
     * @example
     * // Create many TelegramLinkRequests
     * const telegramLinkRequest = await prisma.telegramLinkRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelegramLinkRequests and only return the `id`
     * const telegramLinkRequestWithIdOnly = await prisma.telegramLinkRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelegramLinkRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, TelegramLinkRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelegramLinkRequest.
     * @param {TelegramLinkRequestDeleteArgs} args - Arguments to delete one TelegramLinkRequest.
     * @example
     * // Delete one TelegramLinkRequest
     * const TelegramLinkRequest = await prisma.telegramLinkRequest.delete({
     *   where: {
     *     // ... filter to delete one TelegramLinkRequest
     *   }
     * })
     * 
     */
    delete<T extends TelegramLinkRequestDeleteArgs>(args: SelectSubset<T, TelegramLinkRequestDeleteArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelegramLinkRequest.
     * @param {TelegramLinkRequestUpdateArgs} args - Arguments to update one TelegramLinkRequest.
     * @example
     * // Update one TelegramLinkRequest
     * const telegramLinkRequest = await prisma.telegramLinkRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelegramLinkRequestUpdateArgs>(args: SelectSubset<T, TelegramLinkRequestUpdateArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelegramLinkRequests.
     * @param {TelegramLinkRequestDeleteManyArgs} args - Arguments to filter TelegramLinkRequests to delete.
     * @example
     * // Delete a few TelegramLinkRequests
     * const { count } = await prisma.telegramLinkRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelegramLinkRequestDeleteManyArgs>(args?: SelectSubset<T, TelegramLinkRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramLinkRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramLinkRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramLinkRequests
     * const telegramLinkRequest = await prisma.telegramLinkRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelegramLinkRequestUpdateManyArgs>(args: SelectSubset<T, TelegramLinkRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramLinkRequests and returns the data updated in the database.
     * @param {TelegramLinkRequestUpdateManyAndReturnArgs} args - Arguments to update many TelegramLinkRequests.
     * @example
     * // Update many TelegramLinkRequests
     * const telegramLinkRequest = await prisma.telegramLinkRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelegramLinkRequests and only return the `id`
     * const telegramLinkRequestWithIdOnly = await prisma.telegramLinkRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelegramLinkRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, TelegramLinkRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelegramLinkRequest.
     * @param {TelegramLinkRequestUpsertArgs} args - Arguments to update or create a TelegramLinkRequest.
     * @example
     * // Update or create a TelegramLinkRequest
     * const telegramLinkRequest = await prisma.telegramLinkRequest.upsert({
     *   create: {
     *     // ... data to create a TelegramLinkRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramLinkRequest we want to update
     *   }
     * })
     */
    upsert<T extends TelegramLinkRequestUpsertArgs>(args: SelectSubset<T, TelegramLinkRequestUpsertArgs<ExtArgs>>): Prisma__TelegramLinkRequestClient<$Result.GetResult<Prisma.$TelegramLinkRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelegramLinkRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramLinkRequestCountArgs} args - Arguments to filter TelegramLinkRequests to count.
     * @example
     * // Count the number of TelegramLinkRequests
     * const count = await prisma.telegramLinkRequest.count({
     *   where: {
     *     // ... the filter for the TelegramLinkRequests we want to count
     *   }
     * })
    **/
    count<T extends TelegramLinkRequestCountArgs>(
      args?: Subset<T, TelegramLinkRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramLinkRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramLinkRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramLinkRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramLinkRequestAggregateArgs>(args: Subset<T, TelegramLinkRequestAggregateArgs>): Prisma.PrismaPromise<GetTelegramLinkRequestAggregateType<T>>

    /**
     * Group by TelegramLinkRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramLinkRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramLinkRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramLinkRequestGroupByArgs['orderBy'] }
        : { orderBy?: TelegramLinkRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramLinkRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramLinkRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramLinkRequest model
   */
  readonly fields: TelegramLinkRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramLinkRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramLinkRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelegramLinkRequest model
   */
  interface TelegramLinkRequestFieldRefs {
    readonly id: FieldRef<"TelegramLinkRequest", 'String'>
    readonly code: FieldRef<"TelegramLinkRequest", 'String'>
    readonly userId: FieldRef<"TelegramLinkRequest", 'String'>
    readonly expiresAt: FieldRef<"TelegramLinkRequest", 'DateTime'>
    readonly usedAt: FieldRef<"TelegramLinkRequest", 'DateTime'>
    readonly createdAt: FieldRef<"TelegramLinkRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelegramLinkRequest findUnique
   */
  export type TelegramLinkRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * Filter, which TelegramLinkRequest to fetch.
     */
    where: TelegramLinkRequestWhereUniqueInput
  }

  /**
   * TelegramLinkRequest findUniqueOrThrow
   */
  export type TelegramLinkRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * Filter, which TelegramLinkRequest to fetch.
     */
    where: TelegramLinkRequestWhereUniqueInput
  }

  /**
   * TelegramLinkRequest findFirst
   */
  export type TelegramLinkRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * Filter, which TelegramLinkRequest to fetch.
     */
    where?: TelegramLinkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramLinkRequests to fetch.
     */
    orderBy?: TelegramLinkRequestOrderByWithRelationInput | TelegramLinkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramLinkRequests.
     */
    cursor?: TelegramLinkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramLinkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramLinkRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramLinkRequests.
     */
    distinct?: TelegramLinkRequestScalarFieldEnum | TelegramLinkRequestScalarFieldEnum[]
  }

  /**
   * TelegramLinkRequest findFirstOrThrow
   */
  export type TelegramLinkRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * Filter, which TelegramLinkRequest to fetch.
     */
    where?: TelegramLinkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramLinkRequests to fetch.
     */
    orderBy?: TelegramLinkRequestOrderByWithRelationInput | TelegramLinkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramLinkRequests.
     */
    cursor?: TelegramLinkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramLinkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramLinkRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramLinkRequests.
     */
    distinct?: TelegramLinkRequestScalarFieldEnum | TelegramLinkRequestScalarFieldEnum[]
  }

  /**
   * TelegramLinkRequest findMany
   */
  export type TelegramLinkRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * Filter, which TelegramLinkRequests to fetch.
     */
    where?: TelegramLinkRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramLinkRequests to fetch.
     */
    orderBy?: TelegramLinkRequestOrderByWithRelationInput | TelegramLinkRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramLinkRequests.
     */
    cursor?: TelegramLinkRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramLinkRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramLinkRequests.
     */
    skip?: number
    distinct?: TelegramLinkRequestScalarFieldEnum | TelegramLinkRequestScalarFieldEnum[]
  }

  /**
   * TelegramLinkRequest create
   */
  export type TelegramLinkRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramLinkRequest.
     */
    data: XOR<TelegramLinkRequestCreateInput, TelegramLinkRequestUncheckedCreateInput>
  }

  /**
   * TelegramLinkRequest createMany
   */
  export type TelegramLinkRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramLinkRequests.
     */
    data: TelegramLinkRequestCreateManyInput | TelegramLinkRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramLinkRequest createManyAndReturn
   */
  export type TelegramLinkRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * The data used to create many TelegramLinkRequests.
     */
    data: TelegramLinkRequestCreateManyInput | TelegramLinkRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramLinkRequest update
   */
  export type TelegramLinkRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramLinkRequest.
     */
    data: XOR<TelegramLinkRequestUpdateInput, TelegramLinkRequestUncheckedUpdateInput>
    /**
     * Choose, which TelegramLinkRequest to update.
     */
    where: TelegramLinkRequestWhereUniqueInput
  }

  /**
   * TelegramLinkRequest updateMany
   */
  export type TelegramLinkRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramLinkRequests.
     */
    data: XOR<TelegramLinkRequestUpdateManyMutationInput, TelegramLinkRequestUncheckedUpdateManyInput>
    /**
     * Filter which TelegramLinkRequests to update
     */
    where?: TelegramLinkRequestWhereInput
    /**
     * Limit how many TelegramLinkRequests to update.
     */
    limit?: number
  }

  /**
   * TelegramLinkRequest updateManyAndReturn
   */
  export type TelegramLinkRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * The data used to update TelegramLinkRequests.
     */
    data: XOR<TelegramLinkRequestUpdateManyMutationInput, TelegramLinkRequestUncheckedUpdateManyInput>
    /**
     * Filter which TelegramLinkRequests to update
     */
    where?: TelegramLinkRequestWhereInput
    /**
     * Limit how many TelegramLinkRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramLinkRequest upsert
   */
  export type TelegramLinkRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramLinkRequest to update in case it exists.
     */
    where: TelegramLinkRequestWhereUniqueInput
    /**
     * In case the TelegramLinkRequest found by the `where` argument doesn't exist, create a new TelegramLinkRequest with this data.
     */
    create: XOR<TelegramLinkRequestCreateInput, TelegramLinkRequestUncheckedCreateInput>
    /**
     * In case the TelegramLinkRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramLinkRequestUpdateInput, TelegramLinkRequestUncheckedUpdateInput>
  }

  /**
   * TelegramLinkRequest delete
   */
  export type TelegramLinkRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
    /**
     * Filter which TelegramLinkRequest to delete.
     */
    where: TelegramLinkRequestWhereUniqueInput
  }

  /**
   * TelegramLinkRequest deleteMany
   */
  export type TelegramLinkRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramLinkRequests to delete
     */
    where?: TelegramLinkRequestWhereInput
    /**
     * Limit how many TelegramLinkRequests to delete.
     */
    limit?: number
  }

  /**
   * TelegramLinkRequest without action
   */
  export type TelegramLinkRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramLinkRequest
     */
    select?: TelegramLinkRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramLinkRequest
     */
    omit?: TelegramLinkRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramLinkRequestInclude<ExtArgs> | null
  }


  /**
   * Model TelegramUser
   */

  export type AggregateTelegramUser = {
    _count: TelegramUserCountAggregateOutputType | null
    _min: TelegramUserMinAggregateOutputType | null
    _max: TelegramUserMaxAggregateOutputType | null
  }

  export type TelegramUserMinAggregateOutputType = {
    id: string | null
    telegramId: string | null
    userId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramUserMaxAggregateOutputType = {
    id: string | null
    telegramId: string | null
    userId: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TelegramUserCountAggregateOutputType = {
    id: number
    telegramId: number
    userId: number
    username: number
    firstName: number
    lastName: number
    avatarUrl: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TelegramUserMinAggregateInputType = {
    id?: true
    telegramId?: true
    userId?: true
    username?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramUserMaxAggregateInputType = {
    id?: true
    telegramId?: true
    userId?: true
    username?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TelegramUserCountAggregateInputType = {
    id?: true
    telegramId?: true
    userId?: true
    username?: true
    firstName?: true
    lastName?: true
    avatarUrl?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TelegramUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramUser to aggregate.
     */
    where?: TelegramUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUsers to fetch.
     */
    orderBy?: TelegramUserOrderByWithRelationInput | TelegramUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TelegramUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TelegramUsers
    **/
    _count?: true | TelegramUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TelegramUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TelegramUserMaxAggregateInputType
  }

  export type GetTelegramUserAggregateType<T extends TelegramUserAggregateArgs> = {
        [P in keyof T & keyof AggregateTelegramUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTelegramUser[P]>
      : GetScalarType<T[P], AggregateTelegramUser[P]>
  }




  export type TelegramUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TelegramUserWhereInput
    orderBy?: TelegramUserOrderByWithAggregationInput | TelegramUserOrderByWithAggregationInput[]
    by: TelegramUserScalarFieldEnum[] | TelegramUserScalarFieldEnum
    having?: TelegramUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TelegramUserCountAggregateInputType | true
    _min?: TelegramUserMinAggregateInputType
    _max?: TelegramUserMaxAggregateInputType
  }

  export type TelegramUserGroupByOutputType = {
    id: string
    telegramId: string
    userId: string
    username: string | null
    firstName: string | null
    lastName: string | null
    avatarUrl: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TelegramUserCountAggregateOutputType | null
    _min: TelegramUserMinAggregateOutputType | null
    _max: TelegramUserMaxAggregateOutputType | null
  }

  type GetTelegramUserGroupByPayload<T extends TelegramUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TelegramUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TelegramUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TelegramUserGroupByOutputType[P]>
            : GetScalarType<T[P], TelegramUserGroupByOutputType[P]>
        }
      >
    >


  export type TelegramUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    userId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramUser"]>

  export type TelegramUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    userId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramUser"]>

  export type TelegramUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    telegramId?: boolean
    userId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["telegramUser"]>

  export type TelegramUserSelectScalar = {
    id?: boolean
    telegramId?: boolean
    userId?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    avatarUrl?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TelegramUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "telegramId" | "userId" | "username" | "firstName" | "lastName" | "avatarUrl" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["telegramUser"]>
  export type TelegramUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TelegramUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TelegramUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TelegramUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      telegramId: string
      userId: string
      username: string | null
      firstName: string | null
      lastName: string | null
      avatarUrl: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["telegramUser"]>
    composites: {}
  }

  type TelegramUserGetPayload<S extends boolean | null | undefined | TelegramUserDefaultArgs> = $Result.GetResult<Prisma.$TelegramUserPayload, S>

  type TelegramUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TelegramUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TelegramUserCountAggregateInputType | true
    }

  export interface TelegramUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TelegramUser'], meta: { name: 'TelegramUser' } }
    /**
     * Find zero or one TelegramUser that matches the filter.
     * @param {TelegramUserFindUniqueArgs} args - Arguments to find a TelegramUser
     * @example
     * // Get one TelegramUser
     * const telegramUser = await prisma.telegramUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TelegramUserFindUniqueArgs>(args: SelectSubset<T, TelegramUserFindUniqueArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TelegramUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TelegramUserFindUniqueOrThrowArgs} args - Arguments to find a TelegramUser
     * @example
     * // Get one TelegramUser
     * const telegramUser = await prisma.telegramUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TelegramUserFindUniqueOrThrowArgs>(args: SelectSubset<T, TelegramUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserFindFirstArgs} args - Arguments to find a TelegramUser
     * @example
     * // Get one TelegramUser
     * const telegramUser = await prisma.telegramUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TelegramUserFindFirstArgs>(args?: SelectSubset<T, TelegramUserFindFirstArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TelegramUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserFindFirstOrThrowArgs} args - Arguments to find a TelegramUser
     * @example
     * // Get one TelegramUser
     * const telegramUser = await prisma.telegramUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TelegramUserFindFirstOrThrowArgs>(args?: SelectSubset<T, TelegramUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TelegramUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TelegramUsers
     * const telegramUsers = await prisma.telegramUser.findMany()
     * 
     * // Get first 10 TelegramUsers
     * const telegramUsers = await prisma.telegramUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const telegramUserWithIdOnly = await prisma.telegramUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TelegramUserFindManyArgs>(args?: SelectSubset<T, TelegramUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TelegramUser.
     * @param {TelegramUserCreateArgs} args - Arguments to create a TelegramUser.
     * @example
     * // Create one TelegramUser
     * const TelegramUser = await prisma.telegramUser.create({
     *   data: {
     *     // ... data to create a TelegramUser
     *   }
     * })
     * 
     */
    create<T extends TelegramUserCreateArgs>(args: SelectSubset<T, TelegramUserCreateArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TelegramUsers.
     * @param {TelegramUserCreateManyArgs} args - Arguments to create many TelegramUsers.
     * @example
     * // Create many TelegramUsers
     * const telegramUser = await prisma.telegramUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TelegramUserCreateManyArgs>(args?: SelectSubset<T, TelegramUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TelegramUsers and returns the data saved in the database.
     * @param {TelegramUserCreateManyAndReturnArgs} args - Arguments to create many TelegramUsers.
     * @example
     * // Create many TelegramUsers
     * const telegramUser = await prisma.telegramUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TelegramUsers and only return the `id`
     * const telegramUserWithIdOnly = await prisma.telegramUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TelegramUserCreateManyAndReturnArgs>(args?: SelectSubset<T, TelegramUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TelegramUser.
     * @param {TelegramUserDeleteArgs} args - Arguments to delete one TelegramUser.
     * @example
     * // Delete one TelegramUser
     * const TelegramUser = await prisma.telegramUser.delete({
     *   where: {
     *     // ... filter to delete one TelegramUser
     *   }
     * })
     * 
     */
    delete<T extends TelegramUserDeleteArgs>(args: SelectSubset<T, TelegramUserDeleteArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TelegramUser.
     * @param {TelegramUserUpdateArgs} args - Arguments to update one TelegramUser.
     * @example
     * // Update one TelegramUser
     * const telegramUser = await prisma.telegramUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TelegramUserUpdateArgs>(args: SelectSubset<T, TelegramUserUpdateArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TelegramUsers.
     * @param {TelegramUserDeleteManyArgs} args - Arguments to filter TelegramUsers to delete.
     * @example
     * // Delete a few TelegramUsers
     * const { count } = await prisma.telegramUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TelegramUserDeleteManyArgs>(args?: SelectSubset<T, TelegramUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TelegramUsers
     * const telegramUser = await prisma.telegramUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TelegramUserUpdateManyArgs>(args: SelectSubset<T, TelegramUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TelegramUsers and returns the data updated in the database.
     * @param {TelegramUserUpdateManyAndReturnArgs} args - Arguments to update many TelegramUsers.
     * @example
     * // Update many TelegramUsers
     * const telegramUser = await prisma.telegramUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TelegramUsers and only return the `id`
     * const telegramUserWithIdOnly = await prisma.telegramUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TelegramUserUpdateManyAndReturnArgs>(args: SelectSubset<T, TelegramUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TelegramUser.
     * @param {TelegramUserUpsertArgs} args - Arguments to update or create a TelegramUser.
     * @example
     * // Update or create a TelegramUser
     * const telegramUser = await prisma.telegramUser.upsert({
     *   create: {
     *     // ... data to create a TelegramUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TelegramUser we want to update
     *   }
     * })
     */
    upsert<T extends TelegramUserUpsertArgs>(args: SelectSubset<T, TelegramUserUpsertArgs<ExtArgs>>): Prisma__TelegramUserClient<$Result.GetResult<Prisma.$TelegramUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TelegramUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserCountArgs} args - Arguments to filter TelegramUsers to count.
     * @example
     * // Count the number of TelegramUsers
     * const count = await prisma.telegramUser.count({
     *   where: {
     *     // ... the filter for the TelegramUsers we want to count
     *   }
     * })
    **/
    count<T extends TelegramUserCountArgs>(
      args?: Subset<T, TelegramUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TelegramUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TelegramUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TelegramUserAggregateArgs>(args: Subset<T, TelegramUserAggregateArgs>): Prisma.PrismaPromise<GetTelegramUserAggregateType<T>>

    /**
     * Group by TelegramUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TelegramUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TelegramUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TelegramUserGroupByArgs['orderBy'] }
        : { orderBy?: TelegramUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TelegramUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTelegramUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TelegramUser model
   */
  readonly fields: TelegramUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TelegramUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TelegramUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TelegramUser model
   */
  interface TelegramUserFieldRefs {
    readonly id: FieldRef<"TelegramUser", 'String'>
    readonly telegramId: FieldRef<"TelegramUser", 'String'>
    readonly userId: FieldRef<"TelegramUser", 'String'>
    readonly username: FieldRef<"TelegramUser", 'String'>
    readonly firstName: FieldRef<"TelegramUser", 'String'>
    readonly lastName: FieldRef<"TelegramUser", 'String'>
    readonly avatarUrl: FieldRef<"TelegramUser", 'String'>
    readonly isActive: FieldRef<"TelegramUser", 'Boolean'>
    readonly createdAt: FieldRef<"TelegramUser", 'DateTime'>
    readonly updatedAt: FieldRef<"TelegramUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TelegramUser findUnique
   */
  export type TelegramUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUser to fetch.
     */
    where: TelegramUserWhereUniqueInput
  }

  /**
   * TelegramUser findUniqueOrThrow
   */
  export type TelegramUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUser to fetch.
     */
    where: TelegramUserWhereUniqueInput
  }

  /**
   * TelegramUser findFirst
   */
  export type TelegramUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUser to fetch.
     */
    where?: TelegramUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUsers to fetch.
     */
    orderBy?: TelegramUserOrderByWithRelationInput | TelegramUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramUsers.
     */
    cursor?: TelegramUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramUsers.
     */
    distinct?: TelegramUserScalarFieldEnum | TelegramUserScalarFieldEnum[]
  }

  /**
   * TelegramUser findFirstOrThrow
   */
  export type TelegramUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUser to fetch.
     */
    where?: TelegramUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUsers to fetch.
     */
    orderBy?: TelegramUserOrderByWithRelationInput | TelegramUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TelegramUsers.
     */
    cursor?: TelegramUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TelegramUsers.
     */
    distinct?: TelegramUserScalarFieldEnum | TelegramUserScalarFieldEnum[]
  }

  /**
   * TelegramUser findMany
   */
  export type TelegramUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * Filter, which TelegramUsers to fetch.
     */
    where?: TelegramUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TelegramUsers to fetch.
     */
    orderBy?: TelegramUserOrderByWithRelationInput | TelegramUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TelegramUsers.
     */
    cursor?: TelegramUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TelegramUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TelegramUsers.
     */
    skip?: number
    distinct?: TelegramUserScalarFieldEnum | TelegramUserScalarFieldEnum[]
  }

  /**
   * TelegramUser create
   */
  export type TelegramUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * The data needed to create a TelegramUser.
     */
    data: XOR<TelegramUserCreateInput, TelegramUserUncheckedCreateInput>
  }

  /**
   * TelegramUser createMany
   */
  export type TelegramUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TelegramUsers.
     */
    data: TelegramUserCreateManyInput | TelegramUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TelegramUser createManyAndReturn
   */
  export type TelegramUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * The data used to create many TelegramUsers.
     */
    data: TelegramUserCreateManyInput | TelegramUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramUser update
   */
  export type TelegramUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * The data needed to update a TelegramUser.
     */
    data: XOR<TelegramUserUpdateInput, TelegramUserUncheckedUpdateInput>
    /**
     * Choose, which TelegramUser to update.
     */
    where: TelegramUserWhereUniqueInput
  }

  /**
   * TelegramUser updateMany
   */
  export type TelegramUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TelegramUsers.
     */
    data: XOR<TelegramUserUpdateManyMutationInput, TelegramUserUncheckedUpdateManyInput>
    /**
     * Filter which TelegramUsers to update
     */
    where?: TelegramUserWhereInput
    /**
     * Limit how many TelegramUsers to update.
     */
    limit?: number
  }

  /**
   * TelegramUser updateManyAndReturn
   */
  export type TelegramUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * The data used to update TelegramUsers.
     */
    data: XOR<TelegramUserUpdateManyMutationInput, TelegramUserUncheckedUpdateManyInput>
    /**
     * Filter which TelegramUsers to update
     */
    where?: TelegramUserWhereInput
    /**
     * Limit how many TelegramUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TelegramUser upsert
   */
  export type TelegramUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * The filter to search for the TelegramUser to update in case it exists.
     */
    where: TelegramUserWhereUniqueInput
    /**
     * In case the TelegramUser found by the `where` argument doesn't exist, create a new TelegramUser with this data.
     */
    create: XOR<TelegramUserCreateInput, TelegramUserUncheckedCreateInput>
    /**
     * In case the TelegramUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TelegramUserUpdateInput, TelegramUserUncheckedUpdateInput>
  }

  /**
   * TelegramUser delete
   */
  export type TelegramUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
    /**
     * Filter which TelegramUser to delete.
     */
    where: TelegramUserWhereUniqueInput
  }

  /**
   * TelegramUser deleteMany
   */
  export type TelegramUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TelegramUsers to delete
     */
    where?: TelegramUserWhereInput
    /**
     * Limit how many TelegramUsers to delete.
     */
    limit?: number
  }

  /**
   * TelegramUser without action
   */
  export type TelegramUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TelegramUser
     */
    select?: TelegramUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TelegramUser
     */
    omit?: TelegramUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TelegramUserInclude<ExtArgs> | null
  }


  /**
   * Model CallEvent
   */

  export type AggregateCallEvent = {
    _count: CallEventCountAggregateOutputType | null
    _min: CallEventMinAggregateOutputType | null
    _max: CallEventMaxAggregateOutputType | null
  }

  export type CallEventMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    callerId: string | null
    calleeId: string | null
    roomName: string | null
    eventType: $Enums.CallEventType | null
    createdAt: Date | null
  }

  export type CallEventMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    callerId: string | null
    calleeId: string | null
    roomName: string | null
    eventType: $Enums.CallEventType | null
    createdAt: Date | null
  }

  export type CallEventCountAggregateOutputType = {
    id: number
    tenantId: number
    callerId: number
    calleeId: number
    roomName: number
    eventType: number
    payload: number
    createdAt: number
    _all: number
  }


  export type CallEventMinAggregateInputType = {
    id?: true
    tenantId?: true
    callerId?: true
    calleeId?: true
    roomName?: true
    eventType?: true
    createdAt?: true
  }

  export type CallEventMaxAggregateInputType = {
    id?: true
    tenantId?: true
    callerId?: true
    calleeId?: true
    roomName?: true
    eventType?: true
    createdAt?: true
  }

  export type CallEventCountAggregateInputType = {
    id?: true
    tenantId?: true
    callerId?: true
    calleeId?: true
    roomName?: true
    eventType?: true
    payload?: true
    createdAt?: true
    _all?: true
  }

  export type CallEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallEvent to aggregate.
     */
    where?: CallEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallEvents to fetch.
     */
    orderBy?: CallEventOrderByWithRelationInput | CallEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallEvents
    **/
    _count?: true | CallEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallEventMaxAggregateInputType
  }

  export type GetCallEventAggregateType<T extends CallEventAggregateArgs> = {
        [P in keyof T & keyof AggregateCallEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallEvent[P]>
      : GetScalarType<T[P], AggregateCallEvent[P]>
  }




  export type CallEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallEventWhereInput
    orderBy?: CallEventOrderByWithAggregationInput | CallEventOrderByWithAggregationInput[]
    by: CallEventScalarFieldEnum[] | CallEventScalarFieldEnum
    having?: CallEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallEventCountAggregateInputType | true
    _min?: CallEventMinAggregateInputType
    _max?: CallEventMaxAggregateInputType
  }

  export type CallEventGroupByOutputType = {
    id: string
    tenantId: string
    callerId: string | null
    calleeId: string | null
    roomName: string
    eventType: $Enums.CallEventType
    payload: JsonValue
    createdAt: Date
    _count: CallEventCountAggregateOutputType | null
    _min: CallEventMinAggregateOutputType | null
    _max: CallEventMaxAggregateOutputType | null
  }

  type GetCallEventGroupByPayload<T extends CallEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallEventGroupByOutputType[P]>
            : GetScalarType<T[P], CallEventGroupByOutputType[P]>
        }
      >
    >


  export type CallEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    callerId?: boolean
    calleeId?: boolean
    roomName?: boolean
    eventType?: boolean
    payload?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callEvent"]>

  export type CallEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    callerId?: boolean
    calleeId?: boolean
    roomName?: boolean
    eventType?: boolean
    payload?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callEvent"]>

  export type CallEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    callerId?: boolean
    calleeId?: boolean
    roomName?: boolean
    eventType?: boolean
    payload?: boolean
    createdAt?: boolean
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callEvent"]>

  export type CallEventSelectScalar = {
    id?: boolean
    tenantId?: boolean
    callerId?: boolean
    calleeId?: boolean
    roomName?: boolean
    eventType?: boolean
    payload?: boolean
    createdAt?: boolean
  }

  export type CallEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "callerId" | "calleeId" | "roomName" | "eventType" | "payload" | "createdAt", ExtArgs["result"]["callEvent"]>
  export type CallEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CallEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CallEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CallEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallEvent"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string
      callerId: string | null
      calleeId: string | null
      roomName: string
      eventType: $Enums.CallEventType
      payload: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["callEvent"]>
    composites: {}
  }

  type CallEventGetPayload<S extends boolean | null | undefined | CallEventDefaultArgs> = $Result.GetResult<Prisma.$CallEventPayload, S>

  type CallEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallEventCountAggregateInputType | true
    }

  export interface CallEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallEvent'], meta: { name: 'CallEvent' } }
    /**
     * Find zero or one CallEvent that matches the filter.
     * @param {CallEventFindUniqueArgs} args - Arguments to find a CallEvent
     * @example
     * // Get one CallEvent
     * const callEvent = await prisma.callEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallEventFindUniqueArgs>(args: SelectSubset<T, CallEventFindUniqueArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CallEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallEventFindUniqueOrThrowArgs} args - Arguments to find a CallEvent
     * @example
     * // Get one CallEvent
     * const callEvent = await prisma.callEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallEventFindUniqueOrThrowArgs>(args: SelectSubset<T, CallEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallEventFindFirstArgs} args - Arguments to find a CallEvent
     * @example
     * // Get one CallEvent
     * const callEvent = await prisma.callEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallEventFindFirstArgs>(args?: SelectSubset<T, CallEventFindFirstArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallEventFindFirstOrThrowArgs} args - Arguments to find a CallEvent
     * @example
     * // Get one CallEvent
     * const callEvent = await prisma.callEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallEventFindFirstOrThrowArgs>(args?: SelectSubset<T, CallEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CallEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallEvents
     * const callEvents = await prisma.callEvent.findMany()
     * 
     * // Get first 10 CallEvents
     * const callEvents = await prisma.callEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callEventWithIdOnly = await prisma.callEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallEventFindManyArgs>(args?: SelectSubset<T, CallEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CallEvent.
     * @param {CallEventCreateArgs} args - Arguments to create a CallEvent.
     * @example
     * // Create one CallEvent
     * const CallEvent = await prisma.callEvent.create({
     *   data: {
     *     // ... data to create a CallEvent
     *   }
     * })
     * 
     */
    create<T extends CallEventCreateArgs>(args: SelectSubset<T, CallEventCreateArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CallEvents.
     * @param {CallEventCreateManyArgs} args - Arguments to create many CallEvents.
     * @example
     * // Create many CallEvents
     * const callEvent = await prisma.callEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallEventCreateManyArgs>(args?: SelectSubset<T, CallEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallEvents and returns the data saved in the database.
     * @param {CallEventCreateManyAndReturnArgs} args - Arguments to create many CallEvents.
     * @example
     * // Create many CallEvents
     * const callEvent = await prisma.callEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallEvents and only return the `id`
     * const callEventWithIdOnly = await prisma.callEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallEventCreateManyAndReturnArgs>(args?: SelectSubset<T, CallEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CallEvent.
     * @param {CallEventDeleteArgs} args - Arguments to delete one CallEvent.
     * @example
     * // Delete one CallEvent
     * const CallEvent = await prisma.callEvent.delete({
     *   where: {
     *     // ... filter to delete one CallEvent
     *   }
     * })
     * 
     */
    delete<T extends CallEventDeleteArgs>(args: SelectSubset<T, CallEventDeleteArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CallEvent.
     * @param {CallEventUpdateArgs} args - Arguments to update one CallEvent.
     * @example
     * // Update one CallEvent
     * const callEvent = await prisma.callEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallEventUpdateArgs>(args: SelectSubset<T, CallEventUpdateArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CallEvents.
     * @param {CallEventDeleteManyArgs} args - Arguments to filter CallEvents to delete.
     * @example
     * // Delete a few CallEvents
     * const { count } = await prisma.callEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallEventDeleteManyArgs>(args?: SelectSubset<T, CallEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallEvents
     * const callEvent = await prisma.callEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallEventUpdateManyArgs>(args: SelectSubset<T, CallEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallEvents and returns the data updated in the database.
     * @param {CallEventUpdateManyAndReturnArgs} args - Arguments to update many CallEvents.
     * @example
     * // Update many CallEvents
     * const callEvent = await prisma.callEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallEvents and only return the `id`
     * const callEventWithIdOnly = await prisma.callEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallEventUpdateManyAndReturnArgs>(args: SelectSubset<T, CallEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CallEvent.
     * @param {CallEventUpsertArgs} args - Arguments to update or create a CallEvent.
     * @example
     * // Update or create a CallEvent
     * const callEvent = await prisma.callEvent.upsert({
     *   create: {
     *     // ... data to create a CallEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallEvent we want to update
     *   }
     * })
     */
    upsert<T extends CallEventUpsertArgs>(args: SelectSubset<T, CallEventUpsertArgs<ExtArgs>>): Prisma__CallEventClient<$Result.GetResult<Prisma.$CallEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CallEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallEventCountArgs} args - Arguments to filter CallEvents to count.
     * @example
     * // Count the number of CallEvents
     * const count = await prisma.callEvent.count({
     *   where: {
     *     // ... the filter for the CallEvents we want to count
     *   }
     * })
    **/
    count<T extends CallEventCountArgs>(
      args?: Subset<T, CallEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallEventAggregateArgs>(args: Subset<T, CallEventAggregateArgs>): Prisma.PrismaPromise<GetCallEventAggregateType<T>>

    /**
     * Group by CallEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallEventGroupByArgs['orderBy'] }
        : { orderBy?: CallEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallEvent model
   */
  readonly fields: CallEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallEvent model
   */
  interface CallEventFieldRefs {
    readonly id: FieldRef<"CallEvent", 'String'>
    readonly tenantId: FieldRef<"CallEvent", 'String'>
    readonly callerId: FieldRef<"CallEvent", 'String'>
    readonly calleeId: FieldRef<"CallEvent", 'String'>
    readonly roomName: FieldRef<"CallEvent", 'String'>
    readonly eventType: FieldRef<"CallEvent", 'CallEventType'>
    readonly payload: FieldRef<"CallEvent", 'Json'>
    readonly createdAt: FieldRef<"CallEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallEvent findUnique
   */
  export type CallEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * Filter, which CallEvent to fetch.
     */
    where: CallEventWhereUniqueInput
  }

  /**
   * CallEvent findUniqueOrThrow
   */
  export type CallEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * Filter, which CallEvent to fetch.
     */
    where: CallEventWhereUniqueInput
  }

  /**
   * CallEvent findFirst
   */
  export type CallEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * Filter, which CallEvent to fetch.
     */
    where?: CallEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallEvents to fetch.
     */
    orderBy?: CallEventOrderByWithRelationInput | CallEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallEvents.
     */
    cursor?: CallEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallEvents.
     */
    distinct?: CallEventScalarFieldEnum | CallEventScalarFieldEnum[]
  }

  /**
   * CallEvent findFirstOrThrow
   */
  export type CallEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * Filter, which CallEvent to fetch.
     */
    where?: CallEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallEvents to fetch.
     */
    orderBy?: CallEventOrderByWithRelationInput | CallEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallEvents.
     */
    cursor?: CallEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallEvents.
     */
    distinct?: CallEventScalarFieldEnum | CallEventScalarFieldEnum[]
  }

  /**
   * CallEvent findMany
   */
  export type CallEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * Filter, which CallEvents to fetch.
     */
    where?: CallEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallEvents to fetch.
     */
    orderBy?: CallEventOrderByWithRelationInput | CallEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallEvents.
     */
    cursor?: CallEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallEvents.
     */
    skip?: number
    distinct?: CallEventScalarFieldEnum | CallEventScalarFieldEnum[]
  }

  /**
   * CallEvent create
   */
  export type CallEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * The data needed to create a CallEvent.
     */
    data: XOR<CallEventCreateInput, CallEventUncheckedCreateInput>
  }

  /**
   * CallEvent createMany
   */
  export type CallEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallEvents.
     */
    data: CallEventCreateManyInput | CallEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallEvent createManyAndReturn
   */
  export type CallEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * The data used to create many CallEvents.
     */
    data: CallEventCreateManyInput | CallEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallEvent update
   */
  export type CallEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * The data needed to update a CallEvent.
     */
    data: XOR<CallEventUpdateInput, CallEventUncheckedUpdateInput>
    /**
     * Choose, which CallEvent to update.
     */
    where: CallEventWhereUniqueInput
  }

  /**
   * CallEvent updateMany
   */
  export type CallEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallEvents.
     */
    data: XOR<CallEventUpdateManyMutationInput, CallEventUncheckedUpdateManyInput>
    /**
     * Filter which CallEvents to update
     */
    where?: CallEventWhereInput
    /**
     * Limit how many CallEvents to update.
     */
    limit?: number
  }

  /**
   * CallEvent updateManyAndReturn
   */
  export type CallEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * The data used to update CallEvents.
     */
    data: XOR<CallEventUpdateManyMutationInput, CallEventUncheckedUpdateManyInput>
    /**
     * Filter which CallEvents to update
     */
    where?: CallEventWhereInput
    /**
     * Limit how many CallEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallEvent upsert
   */
  export type CallEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * The filter to search for the CallEvent to update in case it exists.
     */
    where: CallEventWhereUniqueInput
    /**
     * In case the CallEvent found by the `where` argument doesn't exist, create a new CallEvent with this data.
     */
    create: XOR<CallEventCreateInput, CallEventUncheckedCreateInput>
    /**
     * In case the CallEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallEventUpdateInput, CallEventUncheckedUpdateInput>
  }

  /**
   * CallEvent delete
   */
  export type CallEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
    /**
     * Filter which CallEvent to delete.
     */
    where: CallEventWhereUniqueInput
  }

  /**
   * CallEvent deleteMany
   */
  export type CallEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallEvents to delete
     */
    where?: CallEventWhereInput
    /**
     * Limit how many CallEvents to delete.
     */
    limit?: number
  }

  /**
   * CallEvent without action
   */
  export type CallEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallEvent
     */
    select?: CallEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallEvent
     */
    omit?: CallEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallEventInclude<ExtArgs> | null
  }


  /**
   * Model CallRecording
   */

  export type AggregateCallRecording = {
    _count: CallRecordingCountAggregateOutputType | null
    _avg: CallRecordingAvgAggregateOutputType | null
    _sum: CallRecordingSumAggregateOutputType | null
    _min: CallRecordingMinAggregateOutputType | null
    _max: CallRecordingMaxAggregateOutputType | null
  }

  export type CallRecordingAvgAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type CallRecordingSumAggregateOutputType = {
    fileSize: number | null
    duration: number | null
  }

  export type CallRecordingMinAggregateOutputType = {
    id: string | null
    callLogId: string | null
    tenantId: string | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    format: string | null
    duration: number | null
    provider: $Enums.RecordingProvider | null
    providerId: string | null
    status: $Enums.RecordingStatus | null
    recordingStartTime: Date | null
    recordingEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallRecordingMaxAggregateOutputType = {
    id: string | null
    callLogId: string | null
    tenantId: string | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    format: string | null
    duration: number | null
    provider: $Enums.RecordingProvider | null
    providerId: string | null
    status: $Enums.RecordingStatus | null
    recordingStartTime: Date | null
    recordingEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallRecordingCountAggregateOutputType = {
    id: number
    callLogId: number
    tenantId: number
    fileUrl: number
    fileName: number
    fileSize: number
    format: number
    duration: number
    provider: number
    providerId: number
    status: number
    recordingStartTime: number
    recordingEndTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CallRecordingAvgAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type CallRecordingSumAggregateInputType = {
    fileSize?: true
    duration?: true
  }

  export type CallRecordingMinAggregateInputType = {
    id?: true
    callLogId?: true
    tenantId?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    format?: true
    duration?: true
    provider?: true
    providerId?: true
    status?: true
    recordingStartTime?: true
    recordingEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallRecordingMaxAggregateInputType = {
    id?: true
    callLogId?: true
    tenantId?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    format?: true
    duration?: true
    provider?: true
    providerId?: true
    status?: true
    recordingStartTime?: true
    recordingEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallRecordingCountAggregateInputType = {
    id?: true
    callLogId?: true
    tenantId?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    format?: true
    duration?: true
    provider?: true
    providerId?: true
    status?: true
    recordingStartTime?: true
    recordingEndTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CallRecordingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallRecording to aggregate.
     */
    where?: CallRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRecordings to fetch.
     */
    orderBy?: CallRecordingOrderByWithRelationInput | CallRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallRecordings
    **/
    _count?: true | CallRecordingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallRecordingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallRecordingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallRecordingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallRecordingMaxAggregateInputType
  }

  export type GetCallRecordingAggregateType<T extends CallRecordingAggregateArgs> = {
        [P in keyof T & keyof AggregateCallRecording]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallRecording[P]>
      : GetScalarType<T[P], AggregateCallRecording[P]>
  }




  export type CallRecordingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallRecordingWhereInput
    orderBy?: CallRecordingOrderByWithAggregationInput | CallRecordingOrderByWithAggregationInput[]
    by: CallRecordingScalarFieldEnum[] | CallRecordingScalarFieldEnum
    having?: CallRecordingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallRecordingCountAggregateInputType | true
    _avg?: CallRecordingAvgAggregateInputType
    _sum?: CallRecordingSumAggregateInputType
    _min?: CallRecordingMinAggregateInputType
    _max?: CallRecordingMaxAggregateInputType
  }

  export type CallRecordingGroupByOutputType = {
    id: string
    callLogId: string
    tenantId: string
    fileUrl: string
    fileName: string
    fileSize: number | null
    format: string
    duration: number | null
    provider: $Enums.RecordingProvider
    providerId: string | null
    status: $Enums.RecordingStatus
    recordingStartTime: Date | null
    recordingEndTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: CallRecordingCountAggregateOutputType | null
    _avg: CallRecordingAvgAggregateOutputType | null
    _sum: CallRecordingSumAggregateOutputType | null
    _min: CallRecordingMinAggregateOutputType | null
    _max: CallRecordingMaxAggregateOutputType | null
  }

  type GetCallRecordingGroupByPayload<T extends CallRecordingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallRecordingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallRecordingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallRecordingGroupByOutputType[P]>
            : GetScalarType<T[P], CallRecordingGroupByOutputType[P]>
        }
      >
    >


  export type CallRecordingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    format?: boolean
    duration?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    recordingStartTime?: boolean
    recordingEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callRecording"]>

  export type CallRecordingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    format?: boolean
    duration?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    recordingStartTime?: boolean
    recordingEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callRecording"]>

  export type CallRecordingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    format?: boolean
    duration?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    recordingStartTime?: boolean
    recordingEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callRecording"]>

  export type CallRecordingSelectScalar = {
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    format?: boolean
    duration?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    recordingStartTime?: boolean
    recordingEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CallRecordingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "callLogId" | "tenantId" | "fileUrl" | "fileName" | "fileSize" | "format" | "duration" | "provider" | "providerId" | "status" | "recordingStartTime" | "recordingEndTime" | "createdAt" | "updatedAt", ExtArgs["result"]["callRecording"]>
  export type CallRecordingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CallRecordingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CallRecordingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CallRecordingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallRecording"
    objects: {
      callLog: Prisma.$CallLogPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      callLogId: string
      tenantId: string
      fileUrl: string
      fileName: string
      fileSize: number | null
      format: string
      duration: number | null
      provider: $Enums.RecordingProvider
      providerId: string | null
      status: $Enums.RecordingStatus
      recordingStartTime: Date | null
      recordingEndTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["callRecording"]>
    composites: {}
  }

  type CallRecordingGetPayload<S extends boolean | null | undefined | CallRecordingDefaultArgs> = $Result.GetResult<Prisma.$CallRecordingPayload, S>

  type CallRecordingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallRecordingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallRecordingCountAggregateInputType | true
    }

  export interface CallRecordingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallRecording'], meta: { name: 'CallRecording' } }
    /**
     * Find zero or one CallRecording that matches the filter.
     * @param {CallRecordingFindUniqueArgs} args - Arguments to find a CallRecording
     * @example
     * // Get one CallRecording
     * const callRecording = await prisma.callRecording.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallRecordingFindUniqueArgs>(args: SelectSubset<T, CallRecordingFindUniqueArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CallRecording that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallRecordingFindUniqueOrThrowArgs} args - Arguments to find a CallRecording
     * @example
     * // Get one CallRecording
     * const callRecording = await prisma.callRecording.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallRecordingFindUniqueOrThrowArgs>(args: SelectSubset<T, CallRecordingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallRecording that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRecordingFindFirstArgs} args - Arguments to find a CallRecording
     * @example
     * // Get one CallRecording
     * const callRecording = await prisma.callRecording.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallRecordingFindFirstArgs>(args?: SelectSubset<T, CallRecordingFindFirstArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallRecording that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRecordingFindFirstOrThrowArgs} args - Arguments to find a CallRecording
     * @example
     * // Get one CallRecording
     * const callRecording = await prisma.callRecording.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallRecordingFindFirstOrThrowArgs>(args?: SelectSubset<T, CallRecordingFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CallRecordings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRecordingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallRecordings
     * const callRecordings = await prisma.callRecording.findMany()
     * 
     * // Get first 10 CallRecordings
     * const callRecordings = await prisma.callRecording.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callRecordingWithIdOnly = await prisma.callRecording.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallRecordingFindManyArgs>(args?: SelectSubset<T, CallRecordingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CallRecording.
     * @param {CallRecordingCreateArgs} args - Arguments to create a CallRecording.
     * @example
     * // Create one CallRecording
     * const CallRecording = await prisma.callRecording.create({
     *   data: {
     *     // ... data to create a CallRecording
     *   }
     * })
     * 
     */
    create<T extends CallRecordingCreateArgs>(args: SelectSubset<T, CallRecordingCreateArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CallRecordings.
     * @param {CallRecordingCreateManyArgs} args - Arguments to create many CallRecordings.
     * @example
     * // Create many CallRecordings
     * const callRecording = await prisma.callRecording.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallRecordingCreateManyArgs>(args?: SelectSubset<T, CallRecordingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallRecordings and returns the data saved in the database.
     * @param {CallRecordingCreateManyAndReturnArgs} args - Arguments to create many CallRecordings.
     * @example
     * // Create many CallRecordings
     * const callRecording = await prisma.callRecording.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallRecordings and only return the `id`
     * const callRecordingWithIdOnly = await prisma.callRecording.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallRecordingCreateManyAndReturnArgs>(args?: SelectSubset<T, CallRecordingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CallRecording.
     * @param {CallRecordingDeleteArgs} args - Arguments to delete one CallRecording.
     * @example
     * // Delete one CallRecording
     * const CallRecording = await prisma.callRecording.delete({
     *   where: {
     *     // ... filter to delete one CallRecording
     *   }
     * })
     * 
     */
    delete<T extends CallRecordingDeleteArgs>(args: SelectSubset<T, CallRecordingDeleteArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CallRecording.
     * @param {CallRecordingUpdateArgs} args - Arguments to update one CallRecording.
     * @example
     * // Update one CallRecording
     * const callRecording = await prisma.callRecording.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallRecordingUpdateArgs>(args: SelectSubset<T, CallRecordingUpdateArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CallRecordings.
     * @param {CallRecordingDeleteManyArgs} args - Arguments to filter CallRecordings to delete.
     * @example
     * // Delete a few CallRecordings
     * const { count } = await prisma.callRecording.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallRecordingDeleteManyArgs>(args?: SelectSubset<T, CallRecordingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallRecordings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRecordingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallRecordings
     * const callRecording = await prisma.callRecording.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallRecordingUpdateManyArgs>(args: SelectSubset<T, CallRecordingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallRecordings and returns the data updated in the database.
     * @param {CallRecordingUpdateManyAndReturnArgs} args - Arguments to update many CallRecordings.
     * @example
     * // Update many CallRecordings
     * const callRecording = await prisma.callRecording.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallRecordings and only return the `id`
     * const callRecordingWithIdOnly = await prisma.callRecording.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallRecordingUpdateManyAndReturnArgs>(args: SelectSubset<T, CallRecordingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CallRecording.
     * @param {CallRecordingUpsertArgs} args - Arguments to update or create a CallRecording.
     * @example
     * // Update or create a CallRecording
     * const callRecording = await prisma.callRecording.upsert({
     *   create: {
     *     // ... data to create a CallRecording
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallRecording we want to update
     *   }
     * })
     */
    upsert<T extends CallRecordingUpsertArgs>(args: SelectSubset<T, CallRecordingUpsertArgs<ExtArgs>>): Prisma__CallRecordingClient<$Result.GetResult<Prisma.$CallRecordingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CallRecordings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRecordingCountArgs} args - Arguments to filter CallRecordings to count.
     * @example
     * // Count the number of CallRecordings
     * const count = await prisma.callRecording.count({
     *   where: {
     *     // ... the filter for the CallRecordings we want to count
     *   }
     * })
    **/
    count<T extends CallRecordingCountArgs>(
      args?: Subset<T, CallRecordingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallRecordingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallRecording.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRecordingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallRecordingAggregateArgs>(args: Subset<T, CallRecordingAggregateArgs>): Prisma.PrismaPromise<GetCallRecordingAggregateType<T>>

    /**
     * Group by CallRecording.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallRecordingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallRecordingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallRecordingGroupByArgs['orderBy'] }
        : { orderBy?: CallRecordingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallRecordingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallRecordingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallRecording model
   */
  readonly fields: CallRecordingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallRecording.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallRecordingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    callLog<T extends CallLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallLogDefaultArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallRecording model
   */
  interface CallRecordingFieldRefs {
    readonly id: FieldRef<"CallRecording", 'String'>
    readonly callLogId: FieldRef<"CallRecording", 'String'>
    readonly tenantId: FieldRef<"CallRecording", 'String'>
    readonly fileUrl: FieldRef<"CallRecording", 'String'>
    readonly fileName: FieldRef<"CallRecording", 'String'>
    readonly fileSize: FieldRef<"CallRecording", 'Int'>
    readonly format: FieldRef<"CallRecording", 'String'>
    readonly duration: FieldRef<"CallRecording", 'Int'>
    readonly provider: FieldRef<"CallRecording", 'RecordingProvider'>
    readonly providerId: FieldRef<"CallRecording", 'String'>
    readonly status: FieldRef<"CallRecording", 'RecordingStatus'>
    readonly recordingStartTime: FieldRef<"CallRecording", 'DateTime'>
    readonly recordingEndTime: FieldRef<"CallRecording", 'DateTime'>
    readonly createdAt: FieldRef<"CallRecording", 'DateTime'>
    readonly updatedAt: FieldRef<"CallRecording", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallRecording findUnique
   */
  export type CallRecordingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * Filter, which CallRecording to fetch.
     */
    where: CallRecordingWhereUniqueInput
  }

  /**
   * CallRecording findUniqueOrThrow
   */
  export type CallRecordingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * Filter, which CallRecording to fetch.
     */
    where: CallRecordingWhereUniqueInput
  }

  /**
   * CallRecording findFirst
   */
  export type CallRecordingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * Filter, which CallRecording to fetch.
     */
    where?: CallRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRecordings to fetch.
     */
    orderBy?: CallRecordingOrderByWithRelationInput | CallRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallRecordings.
     */
    cursor?: CallRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallRecordings.
     */
    distinct?: CallRecordingScalarFieldEnum | CallRecordingScalarFieldEnum[]
  }

  /**
   * CallRecording findFirstOrThrow
   */
  export type CallRecordingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * Filter, which CallRecording to fetch.
     */
    where?: CallRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRecordings to fetch.
     */
    orderBy?: CallRecordingOrderByWithRelationInput | CallRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallRecordings.
     */
    cursor?: CallRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRecordings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallRecordings.
     */
    distinct?: CallRecordingScalarFieldEnum | CallRecordingScalarFieldEnum[]
  }

  /**
   * CallRecording findMany
   */
  export type CallRecordingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * Filter, which CallRecordings to fetch.
     */
    where?: CallRecordingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallRecordings to fetch.
     */
    orderBy?: CallRecordingOrderByWithRelationInput | CallRecordingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallRecordings.
     */
    cursor?: CallRecordingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallRecordings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallRecordings.
     */
    skip?: number
    distinct?: CallRecordingScalarFieldEnum | CallRecordingScalarFieldEnum[]
  }

  /**
   * CallRecording create
   */
  export type CallRecordingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * The data needed to create a CallRecording.
     */
    data: XOR<CallRecordingCreateInput, CallRecordingUncheckedCreateInput>
  }

  /**
   * CallRecording createMany
   */
  export type CallRecordingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallRecordings.
     */
    data: CallRecordingCreateManyInput | CallRecordingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallRecording createManyAndReturn
   */
  export type CallRecordingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * The data used to create many CallRecordings.
     */
    data: CallRecordingCreateManyInput | CallRecordingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallRecording update
   */
  export type CallRecordingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * The data needed to update a CallRecording.
     */
    data: XOR<CallRecordingUpdateInput, CallRecordingUncheckedUpdateInput>
    /**
     * Choose, which CallRecording to update.
     */
    where: CallRecordingWhereUniqueInput
  }

  /**
   * CallRecording updateMany
   */
  export type CallRecordingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallRecordings.
     */
    data: XOR<CallRecordingUpdateManyMutationInput, CallRecordingUncheckedUpdateManyInput>
    /**
     * Filter which CallRecordings to update
     */
    where?: CallRecordingWhereInput
    /**
     * Limit how many CallRecordings to update.
     */
    limit?: number
  }

  /**
   * CallRecording updateManyAndReturn
   */
  export type CallRecordingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * The data used to update CallRecordings.
     */
    data: XOR<CallRecordingUpdateManyMutationInput, CallRecordingUncheckedUpdateManyInput>
    /**
     * Filter which CallRecordings to update
     */
    where?: CallRecordingWhereInput
    /**
     * Limit how many CallRecordings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallRecording upsert
   */
  export type CallRecordingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * The filter to search for the CallRecording to update in case it exists.
     */
    where: CallRecordingWhereUniqueInput
    /**
     * In case the CallRecording found by the `where` argument doesn't exist, create a new CallRecording with this data.
     */
    create: XOR<CallRecordingCreateInput, CallRecordingUncheckedCreateInput>
    /**
     * In case the CallRecording was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallRecordingUpdateInput, CallRecordingUncheckedUpdateInput>
  }

  /**
   * CallRecording delete
   */
  export type CallRecordingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
    /**
     * Filter which CallRecording to delete.
     */
    where: CallRecordingWhereUniqueInput
  }

  /**
   * CallRecording deleteMany
   */
  export type CallRecordingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallRecordings to delete
     */
    where?: CallRecordingWhereInput
    /**
     * Limit how many CallRecordings to delete.
     */
    limit?: number
  }

  /**
   * CallRecording without action
   */
  export type CallRecordingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallRecording
     */
    select?: CallRecordingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallRecording
     */
    omit?: CallRecordingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallRecordingInclude<ExtArgs> | null
  }


  /**
   * Model CallTranscription
   */

  export type AggregateCallTranscription = {
    _count: CallTranscriptionCountAggregateOutputType | null
    _avg: CallTranscriptionAvgAggregateOutputType | null
    _sum: CallTranscriptionSumAggregateOutputType | null
    _min: CallTranscriptionMinAggregateOutputType | null
    _max: CallTranscriptionMaxAggregateOutputType | null
  }

  export type CallTranscriptionAvgAggregateOutputType = {
    confidence: number | null
    wordCount: number | null
  }

  export type CallTranscriptionSumAggregateOutputType = {
    confidence: number | null
    wordCount: number | null
  }

  export type CallTranscriptionMinAggregateOutputType = {
    id: string | null
    callLogId: string | null
    tenantId: string | null
    fullText: string | null
    language: string | null
    confidence: number | null
    wordCount: number | null
    summary: string | null
    sentiment: string | null
    provider: $Enums.TranscriptionProvider | null
    providerId: string | null
    status: $Enums.TranscriptionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallTranscriptionMaxAggregateOutputType = {
    id: string | null
    callLogId: string | null
    tenantId: string | null
    fullText: string | null
    language: string | null
    confidence: number | null
    wordCount: number | null
    summary: string | null
    sentiment: string | null
    provider: $Enums.TranscriptionProvider | null
    providerId: string | null
    status: $Enums.TranscriptionStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CallTranscriptionCountAggregateOutputType = {
    id: number
    callLogId: number
    tenantId: number
    fullText: number
    segments: number
    language: number
    confidence: number
    wordCount: number
    summary: number
    keywords: number
    sentiment: number
    provider: number
    providerId: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CallTranscriptionAvgAggregateInputType = {
    confidence?: true
    wordCount?: true
  }

  export type CallTranscriptionSumAggregateInputType = {
    confidence?: true
    wordCount?: true
  }

  export type CallTranscriptionMinAggregateInputType = {
    id?: true
    callLogId?: true
    tenantId?: true
    fullText?: true
    language?: true
    confidence?: true
    wordCount?: true
    summary?: true
    sentiment?: true
    provider?: true
    providerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallTranscriptionMaxAggregateInputType = {
    id?: true
    callLogId?: true
    tenantId?: true
    fullText?: true
    language?: true
    confidence?: true
    wordCount?: true
    summary?: true
    sentiment?: true
    provider?: true
    providerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CallTranscriptionCountAggregateInputType = {
    id?: true
    callLogId?: true
    tenantId?: true
    fullText?: true
    segments?: true
    language?: true
    confidence?: true
    wordCount?: true
    summary?: true
    keywords?: true
    sentiment?: true
    provider?: true
    providerId?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CallTranscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallTranscription to aggregate.
     */
    where?: CallTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallTranscriptions to fetch.
     */
    orderBy?: CallTranscriptionOrderByWithRelationInput | CallTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallTranscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallTranscriptions
    **/
    _count?: true | CallTranscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallTranscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallTranscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallTranscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallTranscriptionMaxAggregateInputType
  }

  export type GetCallTranscriptionAggregateType<T extends CallTranscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateCallTranscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallTranscription[P]>
      : GetScalarType<T[P], AggregateCallTranscription[P]>
  }




  export type CallTranscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallTranscriptionWhereInput
    orderBy?: CallTranscriptionOrderByWithAggregationInput | CallTranscriptionOrderByWithAggregationInput[]
    by: CallTranscriptionScalarFieldEnum[] | CallTranscriptionScalarFieldEnum
    having?: CallTranscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallTranscriptionCountAggregateInputType | true
    _avg?: CallTranscriptionAvgAggregateInputType
    _sum?: CallTranscriptionSumAggregateInputType
    _min?: CallTranscriptionMinAggregateInputType
    _max?: CallTranscriptionMaxAggregateInputType
  }

  export type CallTranscriptionGroupByOutputType = {
    id: string
    callLogId: string
    tenantId: string
    fullText: string
    segments: JsonValue
    language: string
    confidence: number | null
    wordCount: number | null
    summary: string | null
    keywords: string[]
    sentiment: string | null
    provider: $Enums.TranscriptionProvider
    providerId: string | null
    status: $Enums.TranscriptionStatus
    createdAt: Date
    updatedAt: Date
    _count: CallTranscriptionCountAggregateOutputType | null
    _avg: CallTranscriptionAvgAggregateOutputType | null
    _sum: CallTranscriptionSumAggregateOutputType | null
    _min: CallTranscriptionMinAggregateOutputType | null
    _max: CallTranscriptionMaxAggregateOutputType | null
  }

  type GetCallTranscriptionGroupByPayload<T extends CallTranscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallTranscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallTranscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallTranscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], CallTranscriptionGroupByOutputType[P]>
        }
      >
    >


  export type CallTranscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fullText?: boolean
    segments?: boolean
    language?: boolean
    confidence?: boolean
    wordCount?: boolean
    summary?: boolean
    keywords?: boolean
    sentiment?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callTranscription"]>

  export type CallTranscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fullText?: boolean
    segments?: boolean
    language?: boolean
    confidence?: boolean
    wordCount?: boolean
    summary?: boolean
    keywords?: boolean
    sentiment?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callTranscription"]>

  export type CallTranscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fullText?: boolean
    segments?: boolean
    language?: boolean
    confidence?: boolean
    wordCount?: boolean
    summary?: boolean
    keywords?: boolean
    sentiment?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callTranscription"]>

  export type CallTranscriptionSelectScalar = {
    id?: boolean
    callLogId?: boolean
    tenantId?: boolean
    fullText?: boolean
    segments?: boolean
    language?: boolean
    confidence?: boolean
    wordCount?: boolean
    summary?: boolean
    keywords?: boolean
    sentiment?: boolean
    provider?: boolean
    providerId?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CallTranscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "callLogId" | "tenantId" | "fullText" | "segments" | "language" | "confidence" | "wordCount" | "summary" | "keywords" | "sentiment" | "provider" | "providerId" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["callTranscription"]>
  export type CallTranscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CallTranscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }
  export type CallTranscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    callLog?: boolean | CallLogDefaultArgs<ExtArgs>
    tenant?: boolean | TenantDefaultArgs<ExtArgs>
  }

  export type $CallTranscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallTranscription"
    objects: {
      callLog: Prisma.$CallLogPayload<ExtArgs>
      tenant: Prisma.$TenantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      callLogId: string
      tenantId: string
      fullText: string
      segments: Prisma.JsonValue
      language: string
      confidence: number | null
      wordCount: number | null
      summary: string | null
      keywords: string[]
      sentiment: string | null
      provider: $Enums.TranscriptionProvider
      providerId: string | null
      status: $Enums.TranscriptionStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["callTranscription"]>
    composites: {}
  }

  type CallTranscriptionGetPayload<S extends boolean | null | undefined | CallTranscriptionDefaultArgs> = $Result.GetResult<Prisma.$CallTranscriptionPayload, S>

  type CallTranscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CallTranscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CallTranscriptionCountAggregateInputType | true
    }

  export interface CallTranscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallTranscription'], meta: { name: 'CallTranscription' } }
    /**
     * Find zero or one CallTranscription that matches the filter.
     * @param {CallTranscriptionFindUniqueArgs} args - Arguments to find a CallTranscription
     * @example
     * // Get one CallTranscription
     * const callTranscription = await prisma.callTranscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallTranscriptionFindUniqueArgs>(args: SelectSubset<T, CallTranscriptionFindUniqueArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CallTranscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CallTranscriptionFindUniqueOrThrowArgs} args - Arguments to find a CallTranscription
     * @example
     * // Get one CallTranscription
     * const callTranscription = await prisma.callTranscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallTranscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, CallTranscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallTranscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallTranscriptionFindFirstArgs} args - Arguments to find a CallTranscription
     * @example
     * // Get one CallTranscription
     * const callTranscription = await prisma.callTranscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallTranscriptionFindFirstArgs>(args?: SelectSubset<T, CallTranscriptionFindFirstArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CallTranscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallTranscriptionFindFirstOrThrowArgs} args - Arguments to find a CallTranscription
     * @example
     * // Get one CallTranscription
     * const callTranscription = await prisma.callTranscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallTranscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, CallTranscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CallTranscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallTranscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallTranscriptions
     * const callTranscriptions = await prisma.callTranscription.findMany()
     * 
     * // Get first 10 CallTranscriptions
     * const callTranscriptions = await prisma.callTranscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callTranscriptionWithIdOnly = await prisma.callTranscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallTranscriptionFindManyArgs>(args?: SelectSubset<T, CallTranscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CallTranscription.
     * @param {CallTranscriptionCreateArgs} args - Arguments to create a CallTranscription.
     * @example
     * // Create one CallTranscription
     * const CallTranscription = await prisma.callTranscription.create({
     *   data: {
     *     // ... data to create a CallTranscription
     *   }
     * })
     * 
     */
    create<T extends CallTranscriptionCreateArgs>(args: SelectSubset<T, CallTranscriptionCreateArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CallTranscriptions.
     * @param {CallTranscriptionCreateManyArgs} args - Arguments to create many CallTranscriptions.
     * @example
     * // Create many CallTranscriptions
     * const callTranscription = await prisma.callTranscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallTranscriptionCreateManyArgs>(args?: SelectSubset<T, CallTranscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallTranscriptions and returns the data saved in the database.
     * @param {CallTranscriptionCreateManyAndReturnArgs} args - Arguments to create many CallTranscriptions.
     * @example
     * // Create many CallTranscriptions
     * const callTranscription = await prisma.callTranscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallTranscriptions and only return the `id`
     * const callTranscriptionWithIdOnly = await prisma.callTranscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallTranscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, CallTranscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CallTranscription.
     * @param {CallTranscriptionDeleteArgs} args - Arguments to delete one CallTranscription.
     * @example
     * // Delete one CallTranscription
     * const CallTranscription = await prisma.callTranscription.delete({
     *   where: {
     *     // ... filter to delete one CallTranscription
     *   }
     * })
     * 
     */
    delete<T extends CallTranscriptionDeleteArgs>(args: SelectSubset<T, CallTranscriptionDeleteArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CallTranscription.
     * @param {CallTranscriptionUpdateArgs} args - Arguments to update one CallTranscription.
     * @example
     * // Update one CallTranscription
     * const callTranscription = await prisma.callTranscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallTranscriptionUpdateArgs>(args: SelectSubset<T, CallTranscriptionUpdateArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CallTranscriptions.
     * @param {CallTranscriptionDeleteManyArgs} args - Arguments to filter CallTranscriptions to delete.
     * @example
     * // Delete a few CallTranscriptions
     * const { count } = await prisma.callTranscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallTranscriptionDeleteManyArgs>(args?: SelectSubset<T, CallTranscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallTranscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallTranscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallTranscriptions
     * const callTranscription = await prisma.callTranscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallTranscriptionUpdateManyArgs>(args: SelectSubset<T, CallTranscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallTranscriptions and returns the data updated in the database.
     * @param {CallTranscriptionUpdateManyAndReturnArgs} args - Arguments to update many CallTranscriptions.
     * @example
     * // Update many CallTranscriptions
     * const callTranscription = await prisma.callTranscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CallTranscriptions and only return the `id`
     * const callTranscriptionWithIdOnly = await prisma.callTranscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CallTranscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, CallTranscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CallTranscription.
     * @param {CallTranscriptionUpsertArgs} args - Arguments to update or create a CallTranscription.
     * @example
     * // Update or create a CallTranscription
     * const callTranscription = await prisma.callTranscription.upsert({
     *   create: {
     *     // ... data to create a CallTranscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallTranscription we want to update
     *   }
     * })
     */
    upsert<T extends CallTranscriptionUpsertArgs>(args: SelectSubset<T, CallTranscriptionUpsertArgs<ExtArgs>>): Prisma__CallTranscriptionClient<$Result.GetResult<Prisma.$CallTranscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CallTranscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallTranscriptionCountArgs} args - Arguments to filter CallTranscriptions to count.
     * @example
     * // Count the number of CallTranscriptions
     * const count = await prisma.callTranscription.count({
     *   where: {
     *     // ... the filter for the CallTranscriptions we want to count
     *   }
     * })
    **/
    count<T extends CallTranscriptionCountArgs>(
      args?: Subset<T, CallTranscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallTranscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallTranscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallTranscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallTranscriptionAggregateArgs>(args: Subset<T, CallTranscriptionAggregateArgs>): Prisma.PrismaPromise<GetCallTranscriptionAggregateType<T>>

    /**
     * Group by CallTranscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallTranscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallTranscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallTranscriptionGroupByArgs['orderBy'] }
        : { orderBy?: CallTranscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallTranscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallTranscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallTranscription model
   */
  readonly fields: CallTranscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallTranscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallTranscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    callLog<T extends CallLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CallLogDefaultArgs<ExtArgs>>): Prisma__CallLogClient<$Result.GetResult<Prisma.$CallLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tenant<T extends TenantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TenantDefaultArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallTranscription model
   */
  interface CallTranscriptionFieldRefs {
    readonly id: FieldRef<"CallTranscription", 'String'>
    readonly callLogId: FieldRef<"CallTranscription", 'String'>
    readonly tenantId: FieldRef<"CallTranscription", 'String'>
    readonly fullText: FieldRef<"CallTranscription", 'String'>
    readonly segments: FieldRef<"CallTranscription", 'Json'>
    readonly language: FieldRef<"CallTranscription", 'String'>
    readonly confidence: FieldRef<"CallTranscription", 'Float'>
    readonly wordCount: FieldRef<"CallTranscription", 'Int'>
    readonly summary: FieldRef<"CallTranscription", 'String'>
    readonly keywords: FieldRef<"CallTranscription", 'String[]'>
    readonly sentiment: FieldRef<"CallTranscription", 'String'>
    readonly provider: FieldRef<"CallTranscription", 'TranscriptionProvider'>
    readonly providerId: FieldRef<"CallTranscription", 'String'>
    readonly status: FieldRef<"CallTranscription", 'TranscriptionStatus'>
    readonly createdAt: FieldRef<"CallTranscription", 'DateTime'>
    readonly updatedAt: FieldRef<"CallTranscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallTranscription findUnique
   */
  export type CallTranscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CallTranscription to fetch.
     */
    where: CallTranscriptionWhereUniqueInput
  }

  /**
   * CallTranscription findUniqueOrThrow
   */
  export type CallTranscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CallTranscription to fetch.
     */
    where: CallTranscriptionWhereUniqueInput
  }

  /**
   * CallTranscription findFirst
   */
  export type CallTranscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CallTranscription to fetch.
     */
    where?: CallTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallTranscriptions to fetch.
     */
    orderBy?: CallTranscriptionOrderByWithRelationInput | CallTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallTranscriptions.
     */
    cursor?: CallTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallTranscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallTranscriptions.
     */
    distinct?: CallTranscriptionScalarFieldEnum | CallTranscriptionScalarFieldEnum[]
  }

  /**
   * CallTranscription findFirstOrThrow
   */
  export type CallTranscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CallTranscription to fetch.
     */
    where?: CallTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallTranscriptions to fetch.
     */
    orderBy?: CallTranscriptionOrderByWithRelationInput | CallTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallTranscriptions.
     */
    cursor?: CallTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallTranscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallTranscriptions.
     */
    distinct?: CallTranscriptionScalarFieldEnum | CallTranscriptionScalarFieldEnum[]
  }

  /**
   * CallTranscription findMany
   */
  export type CallTranscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * Filter, which CallTranscriptions to fetch.
     */
    where?: CallTranscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallTranscriptions to fetch.
     */
    orderBy?: CallTranscriptionOrderByWithRelationInput | CallTranscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallTranscriptions.
     */
    cursor?: CallTranscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallTranscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallTranscriptions.
     */
    skip?: number
    distinct?: CallTranscriptionScalarFieldEnum | CallTranscriptionScalarFieldEnum[]
  }

  /**
   * CallTranscription create
   */
  export type CallTranscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a CallTranscription.
     */
    data: XOR<CallTranscriptionCreateInput, CallTranscriptionUncheckedCreateInput>
  }

  /**
   * CallTranscription createMany
   */
  export type CallTranscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallTranscriptions.
     */
    data: CallTranscriptionCreateManyInput | CallTranscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CallTranscription createManyAndReturn
   */
  export type CallTranscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many CallTranscriptions.
     */
    data: CallTranscriptionCreateManyInput | CallTranscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallTranscription update
   */
  export type CallTranscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a CallTranscription.
     */
    data: XOR<CallTranscriptionUpdateInput, CallTranscriptionUncheckedUpdateInput>
    /**
     * Choose, which CallTranscription to update.
     */
    where: CallTranscriptionWhereUniqueInput
  }

  /**
   * CallTranscription updateMany
   */
  export type CallTranscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallTranscriptions.
     */
    data: XOR<CallTranscriptionUpdateManyMutationInput, CallTranscriptionUncheckedUpdateManyInput>
    /**
     * Filter which CallTranscriptions to update
     */
    where?: CallTranscriptionWhereInput
    /**
     * Limit how many CallTranscriptions to update.
     */
    limit?: number
  }

  /**
   * CallTranscription updateManyAndReturn
   */
  export type CallTranscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * The data used to update CallTranscriptions.
     */
    data: XOR<CallTranscriptionUpdateManyMutationInput, CallTranscriptionUncheckedUpdateManyInput>
    /**
     * Filter which CallTranscriptions to update
     */
    where?: CallTranscriptionWhereInput
    /**
     * Limit how many CallTranscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallTranscription upsert
   */
  export type CallTranscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the CallTranscription to update in case it exists.
     */
    where: CallTranscriptionWhereUniqueInput
    /**
     * In case the CallTranscription found by the `where` argument doesn't exist, create a new CallTranscription with this data.
     */
    create: XOR<CallTranscriptionCreateInput, CallTranscriptionUncheckedCreateInput>
    /**
     * In case the CallTranscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallTranscriptionUpdateInput, CallTranscriptionUncheckedUpdateInput>
  }

  /**
   * CallTranscription delete
   */
  export type CallTranscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
    /**
     * Filter which CallTranscription to delete.
     */
    where: CallTranscriptionWhereUniqueInput
  }

  /**
   * CallTranscription deleteMany
   */
  export type CallTranscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallTranscriptions to delete
     */
    where?: CallTranscriptionWhereInput
    /**
     * Limit how many CallTranscriptions to delete.
     */
    limit?: number
  }

  /**
   * CallTranscription without action
   */
  export type CallTranscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallTranscription
     */
    select?: CallTranscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CallTranscription
     */
    omit?: CallTranscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallTranscriptionInclude<ExtArgs> | null
  }


  /**
   * Model UserPresence
   */

  export type AggregateUserPresence = {
    _count: UserPresenceCountAggregateOutputType | null
    _min: UserPresenceMinAggregateOutputType | null
    _max: UserPresenceMaxAggregateOutputType | null
  }

  export type UserPresenceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.PresenceStatus | null
    lastSeen: Date | null
    currentRoom: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPresenceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    status: $Enums.PresenceStatus | null
    lastSeen: Date | null
    currentRoom: string | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserPresenceCountAggregateOutputType = {
    id: number
    userId: number
    status: number
    lastSeen: number
    currentRoom: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserPresenceMinAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    lastSeen?: true
    currentRoom?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPresenceMaxAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    lastSeen?: true
    currentRoom?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserPresenceCountAggregateInputType = {
    id?: true
    userId?: true
    status?: true
    lastSeen?: true
    currentRoom?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserPresenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPresence to aggregate.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserPresences
    **/
    _count?: true | UserPresenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserPresenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserPresenceMaxAggregateInputType
  }

  export type GetUserPresenceAggregateType<T extends UserPresenceAggregateArgs> = {
        [P in keyof T & keyof AggregateUserPresence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserPresence[P]>
      : GetScalarType<T[P], AggregateUserPresence[P]>
  }




  export type UserPresenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserPresenceWhereInput
    orderBy?: UserPresenceOrderByWithAggregationInput | UserPresenceOrderByWithAggregationInput[]
    by: UserPresenceScalarFieldEnum[] | UserPresenceScalarFieldEnum
    having?: UserPresenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserPresenceCountAggregateInputType | true
    _min?: UserPresenceMinAggregateInputType
    _max?: UserPresenceMaxAggregateInputType
  }

  export type UserPresenceGroupByOutputType = {
    id: string
    userId: string
    status: $Enums.PresenceStatus
    lastSeen: Date
    currentRoom: string | null
    tenantId: string
    createdAt: Date
    updatedAt: Date
    _count: UserPresenceCountAggregateOutputType | null
    _min: UserPresenceMinAggregateOutputType | null
    _max: UserPresenceMaxAggregateOutputType | null
  }

  type GetUserPresenceGroupByPayload<T extends UserPresenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserPresenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserPresenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserPresenceGroupByOutputType[P]>
            : GetScalarType<T[P], UserPresenceGroupByOutputType[P]>
        }
      >
    >


  export type UserPresenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    lastSeen?: boolean
    currentRoom?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    lastSeen?: boolean
    currentRoom?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    status?: boolean
    lastSeen?: boolean
    currentRoom?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["userPresence"]>

  export type UserPresenceSelectScalar = {
    id?: boolean
    userId?: boolean
    status?: boolean
    lastSeen?: boolean
    currentRoom?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserPresenceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "status" | "lastSeen" | "currentRoom" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["userPresence"]>

  export type $UserPresencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserPresence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      status: $Enums.PresenceStatus
      lastSeen: Date
      currentRoom: string | null
      tenantId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userPresence"]>
    composites: {}
  }

  type UserPresenceGetPayload<S extends boolean | null | undefined | UserPresenceDefaultArgs> = $Result.GetResult<Prisma.$UserPresencePayload, S>

  type UserPresenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserPresenceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserPresenceCountAggregateInputType | true
    }

  export interface UserPresenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserPresence'], meta: { name: 'UserPresence' } }
    /**
     * Find zero or one UserPresence that matches the filter.
     * @param {UserPresenceFindUniqueArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserPresenceFindUniqueArgs>(args: SelectSubset<T, UserPresenceFindUniqueArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserPresence that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserPresenceFindUniqueOrThrowArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserPresenceFindUniqueOrThrowArgs>(args: SelectSubset<T, UserPresenceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPresence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindFirstArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserPresenceFindFirstArgs>(args?: SelectSubset<T, UserPresenceFindFirstArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserPresence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindFirstOrThrowArgs} args - Arguments to find a UserPresence
     * @example
     * // Get one UserPresence
     * const userPresence = await prisma.userPresence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserPresenceFindFirstOrThrowArgs>(args?: SelectSubset<T, UserPresenceFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserPresences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserPresences
     * const userPresences = await prisma.userPresence.findMany()
     * 
     * // Get first 10 UserPresences
     * const userPresences = await prisma.userPresence.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userPresenceWithIdOnly = await prisma.userPresence.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserPresenceFindManyArgs>(args?: SelectSubset<T, UserPresenceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserPresence.
     * @param {UserPresenceCreateArgs} args - Arguments to create a UserPresence.
     * @example
     * // Create one UserPresence
     * const UserPresence = await prisma.userPresence.create({
     *   data: {
     *     // ... data to create a UserPresence
     *   }
     * })
     * 
     */
    create<T extends UserPresenceCreateArgs>(args: SelectSubset<T, UserPresenceCreateArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserPresences.
     * @param {UserPresenceCreateManyArgs} args - Arguments to create many UserPresences.
     * @example
     * // Create many UserPresences
     * const userPresence = await prisma.userPresence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserPresenceCreateManyArgs>(args?: SelectSubset<T, UserPresenceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserPresences and returns the data saved in the database.
     * @param {UserPresenceCreateManyAndReturnArgs} args - Arguments to create many UserPresences.
     * @example
     * // Create many UserPresences
     * const userPresence = await prisma.userPresence.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserPresences and only return the `id`
     * const userPresenceWithIdOnly = await prisma.userPresence.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserPresenceCreateManyAndReturnArgs>(args?: SelectSubset<T, UserPresenceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserPresence.
     * @param {UserPresenceDeleteArgs} args - Arguments to delete one UserPresence.
     * @example
     * // Delete one UserPresence
     * const UserPresence = await prisma.userPresence.delete({
     *   where: {
     *     // ... filter to delete one UserPresence
     *   }
     * })
     * 
     */
    delete<T extends UserPresenceDeleteArgs>(args: SelectSubset<T, UserPresenceDeleteArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserPresence.
     * @param {UserPresenceUpdateArgs} args - Arguments to update one UserPresence.
     * @example
     * // Update one UserPresence
     * const userPresence = await prisma.userPresence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserPresenceUpdateArgs>(args: SelectSubset<T, UserPresenceUpdateArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserPresences.
     * @param {UserPresenceDeleteManyArgs} args - Arguments to filter UserPresences to delete.
     * @example
     * // Delete a few UserPresences
     * const { count } = await prisma.userPresence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserPresenceDeleteManyArgs>(args?: SelectSubset<T, UserPresenceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserPresences
     * const userPresence = await prisma.userPresence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserPresenceUpdateManyArgs>(args: SelectSubset<T, UserPresenceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserPresences and returns the data updated in the database.
     * @param {UserPresenceUpdateManyAndReturnArgs} args - Arguments to update many UserPresences.
     * @example
     * // Update many UserPresences
     * const userPresence = await prisma.userPresence.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserPresences and only return the `id`
     * const userPresenceWithIdOnly = await prisma.userPresence.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserPresenceUpdateManyAndReturnArgs>(args: SelectSubset<T, UserPresenceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserPresence.
     * @param {UserPresenceUpsertArgs} args - Arguments to update or create a UserPresence.
     * @example
     * // Update or create a UserPresence
     * const userPresence = await prisma.userPresence.upsert({
     *   create: {
     *     // ... data to create a UserPresence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserPresence we want to update
     *   }
     * })
     */
    upsert<T extends UserPresenceUpsertArgs>(args: SelectSubset<T, UserPresenceUpsertArgs<ExtArgs>>): Prisma__UserPresenceClient<$Result.GetResult<Prisma.$UserPresencePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserPresences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceCountArgs} args - Arguments to filter UserPresences to count.
     * @example
     * // Count the number of UserPresences
     * const count = await prisma.userPresence.count({
     *   where: {
     *     // ... the filter for the UserPresences we want to count
     *   }
     * })
    **/
    count<T extends UserPresenceCountArgs>(
      args?: Subset<T, UserPresenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserPresenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserPresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserPresenceAggregateArgs>(args: Subset<T, UserPresenceAggregateArgs>): Prisma.PrismaPromise<GetUserPresenceAggregateType<T>>

    /**
     * Group by UserPresence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserPresenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserPresenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserPresenceGroupByArgs['orderBy'] }
        : { orderBy?: UserPresenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserPresenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserPresenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserPresence model
   */
  readonly fields: UserPresenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserPresence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserPresenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserPresence model
   */
  interface UserPresenceFieldRefs {
    readonly id: FieldRef<"UserPresence", 'String'>
    readonly userId: FieldRef<"UserPresence", 'String'>
    readonly status: FieldRef<"UserPresence", 'PresenceStatus'>
    readonly lastSeen: FieldRef<"UserPresence", 'DateTime'>
    readonly currentRoom: FieldRef<"UserPresence", 'String'>
    readonly tenantId: FieldRef<"UserPresence", 'String'>
    readonly createdAt: FieldRef<"UserPresence", 'DateTime'>
    readonly updatedAt: FieldRef<"UserPresence", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserPresence findUnique
   */
  export type UserPresenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence findUniqueOrThrow
   */
  export type UserPresenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence findFirst
   */
  export type UserPresenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPresences.
     */
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence findFirstOrThrow
   */
  export type UserPresenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Filter, which UserPresence to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserPresences.
     */
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence findMany
   */
  export type UserPresenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Filter, which UserPresences to fetch.
     */
    where?: UserPresenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserPresences to fetch.
     */
    orderBy?: UserPresenceOrderByWithRelationInput | UserPresenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserPresences.
     */
    cursor?: UserPresenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserPresences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserPresences.
     */
    skip?: number
    distinct?: UserPresenceScalarFieldEnum | UserPresenceScalarFieldEnum[]
  }

  /**
   * UserPresence create
   */
  export type UserPresenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * The data needed to create a UserPresence.
     */
    data: XOR<UserPresenceCreateInput, UserPresenceUncheckedCreateInput>
  }

  /**
   * UserPresence createMany
   */
  export type UserPresenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserPresences.
     */
    data: UserPresenceCreateManyInput | UserPresenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPresence createManyAndReturn
   */
  export type UserPresenceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * The data used to create many UserPresences.
     */
    data: UserPresenceCreateManyInput | UserPresenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserPresence update
   */
  export type UserPresenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * The data needed to update a UserPresence.
     */
    data: XOR<UserPresenceUpdateInput, UserPresenceUncheckedUpdateInput>
    /**
     * Choose, which UserPresence to update.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence updateMany
   */
  export type UserPresenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserPresences.
     */
    data: XOR<UserPresenceUpdateManyMutationInput, UserPresenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPresences to update
     */
    where?: UserPresenceWhereInput
    /**
     * Limit how many UserPresences to update.
     */
    limit?: number
  }

  /**
   * UserPresence updateManyAndReturn
   */
  export type UserPresenceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * The data used to update UserPresences.
     */
    data: XOR<UserPresenceUpdateManyMutationInput, UserPresenceUncheckedUpdateManyInput>
    /**
     * Filter which UserPresences to update
     */
    where?: UserPresenceWhereInput
    /**
     * Limit how many UserPresences to update.
     */
    limit?: number
  }

  /**
   * UserPresence upsert
   */
  export type UserPresenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * The filter to search for the UserPresence to update in case it exists.
     */
    where: UserPresenceWhereUniqueInput
    /**
     * In case the UserPresence found by the `where` argument doesn't exist, create a new UserPresence with this data.
     */
    create: XOR<UserPresenceCreateInput, UserPresenceUncheckedCreateInput>
    /**
     * In case the UserPresence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserPresenceUpdateInput, UserPresenceUncheckedUpdateInput>
  }

  /**
   * UserPresence delete
   */
  export type UserPresenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
    /**
     * Filter which UserPresence to delete.
     */
    where: UserPresenceWhereUniqueInput
  }

  /**
   * UserPresence deleteMany
   */
  export type UserPresenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserPresences to delete
     */
    where?: UserPresenceWhereInput
    /**
     * Limit how many UserPresences to delete.
     */
    limit?: number
  }

  /**
   * UserPresence without action
   */
  export type UserPresenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserPresence
     */
    select?: UserPresenceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserPresence
     */
    omit?: UserPresenceOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    domain: 'domain',
    type: 'type',
    settings: 'settings',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    supabaseUserId: 'supabaseUserId',
    email: 'email',
    firstName: 'firstName',
    lastName: 'lastName',
    name: 'name',
    avatarUrl: 'avatarUrl',
    role: 'role',
    isActive: 'isActive',
    fcmToken: 'fcmToken',
    pushSubscription: 'pushSubscription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ContactScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    company: 'company',
    jobTitle: 'jobTitle',
    source: 'source',
    notes: 'notes',
    customFields: 'customFields',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContactScalarFieldEnum = (typeof ContactScalarFieldEnum)[keyof typeof ContactScalarFieldEnum]


  export const LeadScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    title: 'title',
    source: 'source',
    status: 'status',
    value: 'value',
    notes: 'notes',
    convertedAt: 'convertedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeadScalarFieldEnum = (typeof LeadScalarFieldEnum)[keyof typeof LeadScalarFieldEnum]


  export const PipelineScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    name: 'name',
    description: 'description',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PipelineScalarFieldEnum = (typeof PipelineScalarFieldEnum)[keyof typeof PipelineScalarFieldEnum]


  export const StageScalarFieldEnum: {
    id: 'id',
    pipelineId: 'pipelineId',
    name: 'name',
    order: 'order',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StageScalarFieldEnum = (typeof StageScalarFieldEnum)[keyof typeof StageScalarFieldEnum]


  export const DealScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    leadId: 'leadId',
    pipelineId: 'pipelineId',
    stageId: 'stageId',
    title: 'title',
    description: 'description',
    value: 'value',
    probability: 'probability',
    expectedCloseDate: 'expectedCloseDate',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DealScalarFieldEnum = (typeof DealScalarFieldEnum)[keyof typeof DealScalarFieldEnum]


  export const InteractionScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    dealId: 'dealId',
    userId: 'userId',
    type: 'type',
    subject: 'subject',
    content: 'content',
    dateTime: 'dateTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InteractionScalarFieldEnum = (typeof InteractionScalarFieldEnum)[keyof typeof InteractionScalarFieldEnum]


  export const TicketScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    portalCustomerId: 'portalCustomerId',
    dealId: 'dealId',
    externalId: 'externalId',
    externalSystem: 'externalSystem',
    title: 'title',
    description: 'description',
    status: 'status',
    priority: 'priority',
    source: 'source',
    submittedByPortalCustomer: 'submittedByPortalCustomer',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    assignedUserId: 'assignedUserId'
  };

  export type TicketScalarFieldEnum = (typeof TicketScalarFieldEnum)[keyof typeof TicketScalarFieldEnum]


  export const TicketCommentScalarFieldEnum: {
    id: 'id',
    ticketId: 'ticketId',
    userId: 'userId',
    portalCustomerId: 'portalCustomerId',
    content: 'content',
    authorName: 'authorName',
    isInternal: 'isInternal',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TicketCommentScalarFieldEnum = (typeof TicketCommentScalarFieldEnum)[keyof typeof TicketCommentScalarFieldEnum]


  export const IntegrationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    serviceName: 'serviceName',
    isActive: 'isActive',
    config: 'config',
    lastSyncAt: 'lastSyncAt',
    syncStatus: 'syncStatus',
    errorMessage: 'errorMessage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type IntegrationScalarFieldEnum = (typeof IntegrationScalarFieldEnum)[keyof typeof IntegrationScalarFieldEnum]


  export const CallLogScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    roomName: 'roomName',
    callerSupabaseId: 'callerSupabaseId',
    calleeSupabaseId: 'calleeSupabaseId',
    direction: 'direction',
    status: 'status',
    duration: 'duration',
    startTime: 'startTime',
    endTime: 'endTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    contactId: 'contactId',
    dealId: 'dealId'
  };

  export type CallLogScalarFieldEnum = (typeof CallLogScalarFieldEnum)[keyof typeof CallLogScalarFieldEnum]


  export const PortalCustomerScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    contactId: 'contactId',
    supabaseUserId: 'supabaseUserId',
    email: 'email',
    name: 'name',
    avatarUrl: 'avatarUrl',
    accessToken: 'accessToken',
    fcmToken: 'fcmToken',
    pushSubscription: 'pushSubscription',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PortalCustomerScalarFieldEnum = (typeof PortalCustomerScalarFieldEnum)[keyof typeof PortalCustomerScalarFieldEnum]


  export const UserInvitationScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    email: 'email',
    role: 'role',
    invitedBy: 'invitedBy',
    token: 'token',
    expiresAt: 'expiresAt',
    acceptedAt: 'acceptedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserInvitationScalarFieldEnum = (typeof UserInvitationScalarFieldEnum)[keyof typeof UserInvitationScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tenantId: 'tenantId',
    title: 'title',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const TelegramLinkRequestScalarFieldEnum: {
    id: 'id',
    code: 'code',
    userId: 'userId',
    expiresAt: 'expiresAt',
    usedAt: 'usedAt',
    createdAt: 'createdAt'
  };

  export type TelegramLinkRequestScalarFieldEnum = (typeof TelegramLinkRequestScalarFieldEnum)[keyof typeof TelegramLinkRequestScalarFieldEnum]


  export const TelegramUserScalarFieldEnum: {
    id: 'id',
    telegramId: 'telegramId',
    userId: 'userId',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    avatarUrl: 'avatarUrl',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TelegramUserScalarFieldEnum = (typeof TelegramUserScalarFieldEnum)[keyof typeof TelegramUserScalarFieldEnum]


  export const CallEventScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    callerId: 'callerId',
    calleeId: 'calleeId',
    roomName: 'roomName',
    eventType: 'eventType',
    payload: 'payload',
    createdAt: 'createdAt'
  };

  export type CallEventScalarFieldEnum = (typeof CallEventScalarFieldEnum)[keyof typeof CallEventScalarFieldEnum]


  export const CallRecordingScalarFieldEnum: {
    id: 'id',
    callLogId: 'callLogId',
    tenantId: 'tenantId',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    fileSize: 'fileSize',
    format: 'format',
    duration: 'duration',
    provider: 'provider',
    providerId: 'providerId',
    status: 'status',
    recordingStartTime: 'recordingStartTime',
    recordingEndTime: 'recordingEndTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CallRecordingScalarFieldEnum = (typeof CallRecordingScalarFieldEnum)[keyof typeof CallRecordingScalarFieldEnum]


  export const CallTranscriptionScalarFieldEnum: {
    id: 'id',
    callLogId: 'callLogId',
    tenantId: 'tenantId',
    fullText: 'fullText',
    segments: 'segments',
    language: 'language',
    confidence: 'confidence',
    wordCount: 'wordCount',
    summary: 'summary',
    keywords: 'keywords',
    sentiment: 'sentiment',
    provider: 'provider',
    providerId: 'providerId',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CallTranscriptionScalarFieldEnum = (typeof CallTranscriptionScalarFieldEnum)[keyof typeof CallTranscriptionScalarFieldEnum]


  export const UserPresenceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    status: 'status',
    lastSeen: 'lastSeen',
    currentRoom: 'currentRoom',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserPresenceScalarFieldEnum = (typeof UserPresenceScalarFieldEnum)[keyof typeof UserPresenceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'TenantType'
   */
  export type EnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType'>
    


  /**
   * Reference to a field of type 'TenantType[]'
   */
  export type ListEnumTenantTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TenantType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'LeadStatus'
   */
  export type EnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus'>
    


  /**
   * Reference to a field of type 'LeadStatus[]'
   */
  export type ListEnumLeadStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LeadStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'InteractionType'
   */
  export type EnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType'>
    


  /**
   * Reference to a field of type 'InteractionType[]'
   */
  export type ListEnumInteractionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionType[]'>
    


  /**
   * Reference to a field of type 'TicketStatus'
   */
  export type EnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus'>
    


  /**
   * Reference to a field of type 'TicketStatus[]'
   */
  export type ListEnumTicketStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketStatus[]'>
    


  /**
   * Reference to a field of type 'TicketPriority'
   */
  export type EnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority'>
    


  /**
   * Reference to a field of type 'TicketPriority[]'
   */
  export type ListEnumTicketPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketPriority[]'>
    


  /**
   * Reference to a field of type 'TicketSource'
   */
  export type EnumTicketSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketSource'>
    


  /**
   * Reference to a field of type 'TicketSource[]'
   */
  export type ListEnumTicketSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TicketSource[]'>
    


  /**
   * Reference to a field of type 'CallDirection'
   */
  export type EnumCallDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallDirection'>
    


  /**
   * Reference to a field of type 'CallDirection[]'
   */
  export type ListEnumCallDirectionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallDirection[]'>
    


  /**
   * Reference to a field of type 'CallEventType'
   */
  export type EnumCallEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallEventType'>
    


  /**
   * Reference to a field of type 'CallEventType[]'
   */
  export type ListEnumCallEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CallEventType[]'>
    


  /**
   * Reference to a field of type 'RecordingProvider'
   */
  export type EnumRecordingProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingProvider'>
    


  /**
   * Reference to a field of type 'RecordingProvider[]'
   */
  export type ListEnumRecordingProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingProvider[]'>
    


  /**
   * Reference to a field of type 'RecordingStatus'
   */
  export type EnumRecordingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingStatus'>
    


  /**
   * Reference to a field of type 'RecordingStatus[]'
   */
  export type ListEnumRecordingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RecordingStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TranscriptionProvider'
   */
  export type EnumTranscriptionProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptionProvider'>
    


  /**
   * Reference to a field of type 'TranscriptionProvider[]'
   */
  export type ListEnumTranscriptionProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptionProvider[]'>
    


  /**
   * Reference to a field of type 'TranscriptionStatus'
   */
  export type EnumTranscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptionStatus'>
    


  /**
   * Reference to a field of type 'TranscriptionStatus[]'
   */
  export type ListEnumTranscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TranscriptionStatus[]'>
    


  /**
   * Reference to a field of type 'PresenceStatus'
   */
  export type EnumPresenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PresenceStatus'>
    


  /**
   * Reference to a field of type 'PresenceStatus[]'
   */
  export type ListEnumPresenceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PresenceStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    pipelines?: PipelineListRelationFilter
    deals?: DealListRelationFilter
    interactions?: InteractionListRelationFilter
    tickets?: TicketListRelationFilter
    integrations?: IntegrationListRelationFilter
    callLogs?: CallLogListRelationFilter
    portalCustomers?: PortalCustomerListRelationFilter
    userInvitations?: UserInvitationListRelationFilter
    conversations?: ConversationListRelationFilter
    callEvents?: CallEventListRelationFilter
    callRecordings?: CallRecordingListRelationFilter
    callTranscriptions?: CallTranscriptionListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrderInput | SortOrder
    type?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    contacts?: ContactOrderByRelationAggregateInput
    leads?: LeadOrderByRelationAggregateInput
    pipelines?: PipelineOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    interactions?: InteractionOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    integrations?: IntegrationOrderByRelationAggregateInput
    callLogs?: CallLogOrderByRelationAggregateInput
    portalCustomers?: PortalCustomerOrderByRelationAggregateInput
    userInvitations?: UserInvitationOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    callEvents?: CallEventOrderByRelationAggregateInput
    callRecordings?: CallRecordingOrderByRelationAggregateInput
    callTranscriptions?: CallTranscriptionOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    domain?: StringNullableFilter<"Tenant"> | string | null
    type?: EnumTenantTypeFilter<"Tenant"> | $Enums.TenantType
    settings?: JsonNullableFilter<"Tenant">
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    users?: UserListRelationFilter
    contacts?: ContactListRelationFilter
    leads?: LeadListRelationFilter
    pipelines?: PipelineListRelationFilter
    deals?: DealListRelationFilter
    interactions?: InteractionListRelationFilter
    tickets?: TicketListRelationFilter
    integrations?: IntegrationListRelationFilter
    callLogs?: CallLogListRelationFilter
    portalCustomers?: PortalCustomerListRelationFilter
    userInvitations?: UserInvitationListRelationFilter
    conversations?: ConversationListRelationFilter
    callEvents?: CallEventListRelationFilter
    callRecordings?: CallRecordingListRelationFilter
    callTranscriptions?: CallTranscriptionListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrderInput | SortOrder
    type?: SortOrder
    settings?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    domain?: StringNullableWithAggregatesFilter<"Tenant"> | string | null
    type?: EnumTenantTypeWithAggregatesFilter<"Tenant"> | $Enums.TenantType
    settings?: JsonNullableWithAggregatesFilter<"Tenant">
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    supabaseUserId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    fcmToken?: StringNullableFilter<"User"> | string | null
    pushSubscription?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    interactions?: InteractionListRelationFilter
    ticketsAssigned?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    invitations?: UserInvitationListRelationFilter
    conversations?: ConversationListRelationFilter
    telegramUsers?: TelegramUserListRelationFilter
    telegramLinkRequests?: TelegramLinkRequestListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrderInput | SortOrder
    pushSubscription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    interactions?: InteractionOrderByRelationAggregateInput
    ticketsAssigned?: TicketOrderByRelationAggregateInput
    ticketComments?: TicketCommentOrderByRelationAggregateInput
    invitations?: UserInvitationOrderByRelationAggregateInput
    conversations?: ConversationOrderByRelationAggregateInput
    telegramUsers?: TelegramUserOrderByRelationAggregateInput
    telegramLinkRequests?: TelegramLinkRequestOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    supabaseUserId?: string
    email?: string
    tenantId_supabaseUserId?: UserTenantIdSupabaseUserIdCompoundUniqueInput
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    tenantId?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    fcmToken?: StringNullableFilter<"User"> | string | null
    pushSubscription?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    interactions?: InteractionListRelationFilter
    ticketsAssigned?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
    invitations?: UserInvitationListRelationFilter
    conversations?: ConversationListRelationFilter
    telegramUsers?: TelegramUserListRelationFilter
    telegramLinkRequests?: TelegramLinkRequestListRelationFilter
  }, "id" | "supabaseUserId" | "email" | "tenantId_supabaseUserId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrderInput | SortOrder
    pushSubscription?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringWithAggregatesFilter<"User"> | string
    supabaseUserId?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    fcmToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    pushSubscription?: JsonNullableWithAggregatesFilter<"User">
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ContactWhereInput = {
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    id?: StringFilter<"Contact"> | string
    tenantId?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    source?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    customFields?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    leads?: LeadListRelationFilter
    interactions?: InteractionListRelationFilter
    deals?: DealListRelationFilter
    tickets?: TicketListRelationFilter
    callLogs?: CallLogListRelationFilter
    portalCustomers?: PortalCustomerListRelationFilter
  }

  export type ContactOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    leads?: LeadOrderByRelationAggregateInput
    interactions?: InteractionOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    callLogs?: CallLogOrderByRelationAggregateInput
    portalCustomers?: PortalCustomerOrderByRelationAggregateInput
  }

  export type ContactWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContactWhereInput | ContactWhereInput[]
    OR?: ContactWhereInput[]
    NOT?: ContactWhereInput | ContactWhereInput[]
    tenantId?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    source?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    customFields?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    leads?: LeadListRelationFilter
    interactions?: InteractionListRelationFilter
    deals?: DealListRelationFilter
    tickets?: TicketListRelationFilter
    callLogs?: CallLogListRelationFilter
    portalCustomers?: PortalCustomerListRelationFilter
  }, "id">

  export type ContactOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    company?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    customFields?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContactCountOrderByAggregateInput
    _max?: ContactMaxOrderByAggregateInput
    _min?: ContactMinOrderByAggregateInput
  }

  export type ContactScalarWhereWithAggregatesInput = {
    AND?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    OR?: ContactScalarWhereWithAggregatesInput[]
    NOT?: ContactScalarWhereWithAggregatesInput | ContactScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contact"> | string
    tenantId?: StringWithAggregatesFilter<"Contact"> | string
    firstName?: StringWithAggregatesFilter<"Contact"> | string
    lastName?: StringWithAggregatesFilter<"Contact"> | string
    email?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    company?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    source?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Contact"> | string | null
    customFields?: JsonNullableWithAggregatesFilter<"Contact">
    createdAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contact"> | Date | string
  }

  export type LeadWhereInput = {
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    contactId?: StringNullableFilter<"Lead"> | string | null
    title?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    value?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    deals?: DealListRelationFilter
  }

  export type LeadOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    title?: SortOrder
    source?: SortOrder
    status?: SortOrder
    value?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    deals?: DealOrderByRelationAggregateInput
  }

  export type LeadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeadWhereInput | LeadWhereInput[]
    OR?: LeadWhereInput[]
    NOT?: LeadWhereInput | LeadWhereInput[]
    tenantId?: StringFilter<"Lead"> | string
    contactId?: StringNullableFilter<"Lead"> | string | null
    title?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    value?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    deals?: DealListRelationFilter
  }, "id">

  export type LeadOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    title?: SortOrder
    source?: SortOrder
    status?: SortOrder
    value?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    convertedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeadCountOrderByAggregateInput
    _avg?: LeadAvgOrderByAggregateInput
    _max?: LeadMaxOrderByAggregateInput
    _min?: LeadMinOrderByAggregateInput
    _sum?: LeadSumOrderByAggregateInput
  }

  export type LeadScalarWhereWithAggregatesInput = {
    AND?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    OR?: LeadScalarWhereWithAggregatesInput[]
    NOT?: LeadScalarWhereWithAggregatesInput | LeadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lead"> | string
    tenantId?: StringWithAggregatesFilter<"Lead"> | string
    contactId?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    title?: StringWithAggregatesFilter<"Lead"> | string
    source?: StringWithAggregatesFilter<"Lead"> | string
    status?: EnumLeadStatusWithAggregatesFilter<"Lead"> | $Enums.LeadStatus
    value?: DecimalNullableWithAggregatesFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableWithAggregatesFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableWithAggregatesFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lead"> | Date | string
  }

  export type PipelineWhereInput = {
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    tenantId?: StringFilter<"Pipeline"> | string
    name?: StringFilter<"Pipeline"> | string
    description?: StringNullableFilter<"Pipeline"> | string | null
    isActive?: BoolFilter<"Pipeline"> | boolean
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    stages?: StageListRelationFilter
    deals?: DealListRelationFilter
  }

  export type PipelineOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    stages?: StageOrderByRelationAggregateInput
    deals?: DealOrderByRelationAggregateInput
  }

  export type PipelineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PipelineWhereInput | PipelineWhereInput[]
    OR?: PipelineWhereInput[]
    NOT?: PipelineWhereInput | PipelineWhereInput[]
    tenantId?: StringFilter<"Pipeline"> | string
    name?: StringFilter<"Pipeline"> | string
    description?: StringNullableFilter<"Pipeline"> | string | null
    isActive?: BoolFilter<"Pipeline"> | boolean
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    stages?: StageListRelationFilter
    deals?: DealListRelationFilter
  }, "id">

  export type PipelineOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PipelineCountOrderByAggregateInput
    _max?: PipelineMaxOrderByAggregateInput
    _min?: PipelineMinOrderByAggregateInput
  }

  export type PipelineScalarWhereWithAggregatesInput = {
    AND?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    OR?: PipelineScalarWhereWithAggregatesInput[]
    NOT?: PipelineScalarWhereWithAggregatesInput | PipelineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pipeline"> | string
    tenantId?: StringWithAggregatesFilter<"Pipeline"> | string
    name?: StringWithAggregatesFilter<"Pipeline"> | string
    description?: StringNullableWithAggregatesFilter<"Pipeline"> | string | null
    isActive?: BoolWithAggregatesFilter<"Pipeline"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Pipeline"> | Date | string
  }

  export type StageWhereInput = {
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    id?: StringFilter<"Stage"> | string
    pipelineId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    deals?: DealListRelationFilter
  }

  export type StageOrderByWithRelationInput = {
    id?: SortOrder
    pipelineId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    pipeline?: PipelineOrderByWithRelationInput
    deals?: DealOrderByRelationAggregateInput
  }

  export type StageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    pipelineId_order?: StagePipelineIdOrderCompoundUniqueInput
    AND?: StageWhereInput | StageWhereInput[]
    OR?: StageWhereInput[]
    NOT?: StageWhereInput | StageWhereInput[]
    pipelineId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
    pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    deals?: DealListRelationFilter
  }, "id" | "pipelineId_order">

  export type StageOrderByWithAggregationInput = {
    id?: SortOrder
    pipelineId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StageCountOrderByAggregateInput
    _avg?: StageAvgOrderByAggregateInput
    _max?: StageMaxOrderByAggregateInput
    _min?: StageMinOrderByAggregateInput
    _sum?: StageSumOrderByAggregateInput
  }

  export type StageScalarWhereWithAggregatesInput = {
    AND?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    OR?: StageScalarWhereWithAggregatesInput[]
    NOT?: StageScalarWhereWithAggregatesInput | StageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Stage"> | string
    pipelineId?: StringWithAggregatesFilter<"Stage"> | string
    name?: StringWithAggregatesFilter<"Stage"> | string
    order?: IntWithAggregatesFilter<"Stage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Stage"> | Date | string
  }

  export type DealWhereInput = {
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    contactId?: StringFilter<"Deal"> | string
    leadId?: StringNullableFilter<"Deal"> | string | null
    pipelineId?: StringFilter<"Deal"> | string
    stageId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    value?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    probability?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    notes?: StringNullableFilter<"Deal"> | string | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    stage?: XOR<StageScalarRelationFilter, StageWhereInput>
    interactions?: InteractionListRelationFilter
    tickets?: TicketListRelationFilter
    callLogs?: CallLogListRelationFilter
  }

  export type DealOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    pipelineId?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    probability?: SortOrderInput | SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    lead?: LeadOrderByWithRelationInput
    pipeline?: PipelineOrderByWithRelationInput
    stage?: StageOrderByWithRelationInput
    interactions?: InteractionOrderByRelationAggregateInput
    tickets?: TicketOrderByRelationAggregateInput
    callLogs?: CallLogOrderByRelationAggregateInput
  }

  export type DealWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DealWhereInput | DealWhereInput[]
    OR?: DealWhereInput[]
    NOT?: DealWhereInput | DealWhereInput[]
    tenantId?: StringFilter<"Deal"> | string
    contactId?: StringFilter<"Deal"> | string
    leadId?: StringNullableFilter<"Deal"> | string | null
    pipelineId?: StringFilter<"Deal"> | string
    stageId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    value?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    probability?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    notes?: StringNullableFilter<"Deal"> | string | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    lead?: XOR<LeadNullableScalarRelationFilter, LeadWhereInput> | null
    pipeline?: XOR<PipelineScalarRelationFilter, PipelineWhereInput>
    stage?: XOR<StageScalarRelationFilter, StageWhereInput>
    interactions?: InteractionListRelationFilter
    tickets?: TicketListRelationFilter
    callLogs?: CallLogListRelationFilter
  }, "id">

  export type DealOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrderInput | SortOrder
    pipelineId?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    probability?: SortOrderInput | SortOrder
    expectedCloseDate?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DealCountOrderByAggregateInput
    _avg?: DealAvgOrderByAggregateInput
    _max?: DealMaxOrderByAggregateInput
    _min?: DealMinOrderByAggregateInput
    _sum?: DealSumOrderByAggregateInput
  }

  export type DealScalarWhereWithAggregatesInput = {
    AND?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    OR?: DealScalarWhereWithAggregatesInput[]
    NOT?: DealScalarWhereWithAggregatesInput | DealScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Deal"> | string
    tenantId?: StringWithAggregatesFilter<"Deal"> | string
    contactId?: StringWithAggregatesFilter<"Deal"> | string
    leadId?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    pipelineId?: StringWithAggregatesFilter<"Deal"> | string
    stageId?: StringWithAggregatesFilter<"Deal"> | string
    title?: StringWithAggregatesFilter<"Deal"> | string
    description?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    value?: DecimalNullableWithAggregatesFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    probability?: DecimalNullableWithAggregatesFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: DateTimeNullableWithAggregatesFilter<"Deal"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Deal"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Deal"> | Date | string
  }

  export type InteractionWhereInput = {
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    id?: StringFilter<"Interaction"> | string
    tenantId?: StringFilter<"Interaction"> | string
    contactId?: StringFilter<"Interaction"> | string
    dealId?: StringNullableFilter<"Interaction"> | string | null
    userId?: StringNullableFilter<"Interaction"> | string | null
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    subject?: StringNullableFilter<"Interaction"> | string | null
    content?: StringFilter<"Interaction"> | string
    dateTime?: DateTimeFilter<"Interaction"> | Date | string
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeFilter<"Interaction"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InteractionOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InteractionWhereInput | InteractionWhereInput[]
    OR?: InteractionWhereInput[]
    NOT?: InteractionWhereInput | InteractionWhereInput[]
    tenantId?: StringFilter<"Interaction"> | string
    contactId?: StringFilter<"Interaction"> | string
    dealId?: StringNullableFilter<"Interaction"> | string | null
    userId?: StringNullableFilter<"Interaction"> | string | null
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    subject?: StringNullableFilter<"Interaction"> | string | null
    content?: StringFilter<"Interaction"> | string
    dateTime?: DateTimeFilter<"Interaction"> | Date | string
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeFilter<"Interaction"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type InteractionOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InteractionCountOrderByAggregateInput
    _max?: InteractionMaxOrderByAggregateInput
    _min?: InteractionMinOrderByAggregateInput
  }

  export type InteractionScalarWhereWithAggregatesInput = {
    AND?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    OR?: InteractionScalarWhereWithAggregatesInput[]
    NOT?: InteractionScalarWhereWithAggregatesInput | InteractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Interaction"> | string
    tenantId?: StringWithAggregatesFilter<"Interaction"> | string
    contactId?: StringWithAggregatesFilter<"Interaction"> | string
    dealId?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    type?: EnumInteractionTypeWithAggregatesFilter<"Interaction"> | $Enums.InteractionType
    subject?: StringNullableWithAggregatesFilter<"Interaction"> | string | null
    content?: StringWithAggregatesFilter<"Interaction"> | string
    dateTime?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Interaction"> | Date | string
  }

  export type TicketWhereInput = {
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    id?: StringFilter<"Ticket"> | string
    tenantId?: StringFilter<"Ticket"> | string
    contactId?: StringFilter<"Ticket"> | string
    portalCustomerId?: StringNullableFilter<"Ticket"> | string | null
    dealId?: StringNullableFilter<"Ticket"> | string | null
    externalId?: StringNullableFilter<"Ticket"> | string | null
    externalSystem?: StringNullableFilter<"Ticket"> | string | null
    title?: StringFilter<"Ticket"> | string
    description?: StringNullableFilter<"Ticket"> | string | null
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    source?: EnumTicketSourceFilter<"Ticket"> | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedUserId?: StringNullableFilter<"Ticket"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    portalCustomer?: XOR<PortalCustomerNullableScalarRelationFilter, PortalCustomerWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    assignedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: TicketCommentListRelationFilter
  }

  export type TicketOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    portalCustomerId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    externalSystem?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    submittedByPortalCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    portalCustomer?: PortalCustomerOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    assignedUser?: UserOrderByWithRelationInput
    comments?: TicketCommentOrderByRelationAggregateInput
  }

  export type TicketWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_externalId_externalSystem?: TicketTenantIdExternalIdExternalSystemCompoundUniqueInput
    AND?: TicketWhereInput | TicketWhereInput[]
    OR?: TicketWhereInput[]
    NOT?: TicketWhereInput | TicketWhereInput[]
    tenantId?: StringFilter<"Ticket"> | string
    contactId?: StringFilter<"Ticket"> | string
    portalCustomerId?: StringNullableFilter<"Ticket"> | string | null
    dealId?: StringNullableFilter<"Ticket"> | string | null
    externalId?: StringNullableFilter<"Ticket"> | string | null
    externalSystem?: StringNullableFilter<"Ticket"> | string | null
    title?: StringFilter<"Ticket"> | string
    description?: StringNullableFilter<"Ticket"> | string | null
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    source?: EnumTicketSourceFilter<"Ticket"> | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedUserId?: StringNullableFilter<"Ticket"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactScalarRelationFilter, ContactWhereInput>
    portalCustomer?: XOR<PortalCustomerNullableScalarRelationFilter, PortalCustomerWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    assignedUser?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    comments?: TicketCommentListRelationFilter
  }, "id" | "tenantId_externalId_externalSystem">

  export type TicketOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    portalCustomerId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    externalSystem?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    submittedByPortalCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrderInput | SortOrder
    _count?: TicketCountOrderByAggregateInput
    _max?: TicketMaxOrderByAggregateInput
    _min?: TicketMinOrderByAggregateInput
  }

  export type TicketScalarWhereWithAggregatesInput = {
    AND?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    OR?: TicketScalarWhereWithAggregatesInput[]
    NOT?: TicketScalarWhereWithAggregatesInput | TicketScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Ticket"> | string
    tenantId?: StringWithAggregatesFilter<"Ticket"> | string
    contactId?: StringWithAggregatesFilter<"Ticket"> | string
    portalCustomerId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    externalSystem?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    title?: StringWithAggregatesFilter<"Ticket"> | string
    description?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
    status?: EnumTicketStatusWithAggregatesFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityWithAggregatesFilter<"Ticket"> | $Enums.TicketPriority
    source?: EnumTicketSourceWithAggregatesFilter<"Ticket"> | $Enums.TicketSource
    submittedByPortalCustomer?: BoolWithAggregatesFilter<"Ticket"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Ticket"> | Date | string
    assignedUserId?: StringNullableWithAggregatesFilter<"Ticket"> | string | null
  }

  export type TicketCommentWhereInput = {
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    userId?: StringNullableFilter<"TicketComment"> | string | null
    portalCustomerId?: StringNullableFilter<"TicketComment"> | string | null
    content?: StringFilter<"TicketComment"> | string
    authorName?: StringNullableFilter<"TicketComment"> | string | null
    isInternal?: BoolFilter<"TicketComment"> | boolean
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    portalCustomer?: XOR<PortalCustomerNullableScalarRelationFilter, PortalCustomerWhereInput> | null
  }

  export type TicketCommentOrderByWithRelationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrderInput | SortOrder
    portalCustomerId?: SortOrderInput | SortOrder
    content?: SortOrder
    authorName?: SortOrderInput | SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    ticket?: TicketOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    portalCustomer?: PortalCustomerOrderByWithRelationInput
  }

  export type TicketCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TicketCommentWhereInput | TicketCommentWhereInput[]
    OR?: TicketCommentWhereInput[]
    NOT?: TicketCommentWhereInput | TicketCommentWhereInput[]
    ticketId?: StringFilter<"TicketComment"> | string
    userId?: StringNullableFilter<"TicketComment"> | string | null
    portalCustomerId?: StringNullableFilter<"TicketComment"> | string | null
    content?: StringFilter<"TicketComment"> | string
    authorName?: StringNullableFilter<"TicketComment"> | string | null
    isInternal?: BoolFilter<"TicketComment"> | boolean
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
    ticket?: XOR<TicketScalarRelationFilter, TicketWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    portalCustomer?: XOR<PortalCustomerNullableScalarRelationFilter, PortalCustomerWhereInput> | null
  }, "id">

  export type TicketCommentOrderByWithAggregationInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrderInput | SortOrder
    portalCustomerId?: SortOrderInput | SortOrder
    content?: SortOrder
    authorName?: SortOrderInput | SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TicketCommentCountOrderByAggregateInput
    _max?: TicketCommentMaxOrderByAggregateInput
    _min?: TicketCommentMinOrderByAggregateInput
  }

  export type TicketCommentScalarWhereWithAggregatesInput = {
    AND?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    OR?: TicketCommentScalarWhereWithAggregatesInput[]
    NOT?: TicketCommentScalarWhereWithAggregatesInput | TicketCommentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TicketComment"> | string
    ticketId?: StringWithAggregatesFilter<"TicketComment"> | string
    userId?: StringNullableWithAggregatesFilter<"TicketComment"> | string | null
    portalCustomerId?: StringNullableWithAggregatesFilter<"TicketComment"> | string | null
    content?: StringWithAggregatesFilter<"TicketComment"> | string
    authorName?: StringNullableWithAggregatesFilter<"TicketComment"> | string | null
    isInternal?: BoolWithAggregatesFilter<"TicketComment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TicketComment"> | Date | string
  }

  export type IntegrationWhereInput = {
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    id?: StringFilter<"Integration"> | string
    tenantId?: StringFilter<"Integration"> | string
    serviceName?: StringFilter<"Integration"> | string
    isActive?: BoolFilter<"Integration"> | boolean
    config?: JsonNullableFilter<"Integration">
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncStatus?: StringNullableFilter<"Integration"> | string | null
    errorMessage?: StringNullableFilter<"Integration"> | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type IntegrationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceName?: SortOrder
    isActive?: SortOrder
    config?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type IntegrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_serviceName?: IntegrationTenantIdServiceNameCompoundUniqueInput
    AND?: IntegrationWhereInput | IntegrationWhereInput[]
    OR?: IntegrationWhereInput[]
    NOT?: IntegrationWhereInput | IntegrationWhereInput[]
    tenantId?: StringFilter<"Integration"> | string
    serviceName?: StringFilter<"Integration"> | string
    isActive?: BoolFilter<"Integration"> | boolean
    config?: JsonNullableFilter<"Integration">
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncStatus?: StringNullableFilter<"Integration"> | string | null
    errorMessage?: StringNullableFilter<"Integration"> | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "tenantId_serviceName">

  export type IntegrationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceName?: SortOrder
    isActive?: SortOrder
    config?: SortOrderInput | SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    syncStatus?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: IntegrationCountOrderByAggregateInput
    _max?: IntegrationMaxOrderByAggregateInput
    _min?: IntegrationMinOrderByAggregateInput
  }

  export type IntegrationScalarWhereWithAggregatesInput = {
    AND?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    OR?: IntegrationScalarWhereWithAggregatesInput[]
    NOT?: IntegrationScalarWhereWithAggregatesInput | IntegrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Integration"> | string
    tenantId?: StringWithAggregatesFilter<"Integration"> | string
    serviceName?: StringWithAggregatesFilter<"Integration"> | string
    isActive?: BoolWithAggregatesFilter<"Integration"> | boolean
    config?: JsonNullableWithAggregatesFilter<"Integration">
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"Integration"> | Date | string | null
    syncStatus?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Integration"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Integration"> | Date | string
  }

  export type CallLogWhereInput = {
    AND?: CallLogWhereInput | CallLogWhereInput[]
    OR?: CallLogWhereInput[]
    NOT?: CallLogWhereInput | CallLogWhereInput[]
    id?: StringFilter<"CallLog"> | string
    tenantId?: StringFilter<"CallLog"> | string
    roomName?: StringFilter<"CallLog"> | string
    callerSupabaseId?: StringFilter<"CallLog"> | string
    calleeSupabaseId?: StringFilter<"CallLog"> | string
    direction?: EnumCallDirectionFilter<"CallLog"> | $Enums.CallDirection
    status?: StringFilter<"CallLog"> | string
    duration?: IntNullableFilter<"CallLog"> | number | null
    startTime?: DateTimeFilter<"CallLog"> | Date | string
    endTime?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeFilter<"CallLog"> | Date | string
    updatedAt?: DateTimeFilter<"CallLog"> | Date | string
    contactId?: StringNullableFilter<"CallLog"> | string | null
    dealId?: StringNullableFilter<"CallLog"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    recording?: XOR<CallRecordingNullableScalarRelationFilter, CallRecordingWhereInput> | null
    transcription?: XOR<CallTranscriptionNullableScalarRelationFilter, CallTranscriptionWhereInput> | null
  }

  export type CallLogOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomName?: SortOrder
    callerSupabaseId?: SortOrder
    calleeSupabaseId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    deal?: DealOrderByWithRelationInput
    recording?: CallRecordingOrderByWithRelationInput
    transcription?: CallTranscriptionOrderByWithRelationInput
  }

  export type CallLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallLogWhereInput | CallLogWhereInput[]
    OR?: CallLogWhereInput[]
    NOT?: CallLogWhereInput | CallLogWhereInput[]
    tenantId?: StringFilter<"CallLog"> | string
    roomName?: StringFilter<"CallLog"> | string
    callerSupabaseId?: StringFilter<"CallLog"> | string
    calleeSupabaseId?: StringFilter<"CallLog"> | string
    direction?: EnumCallDirectionFilter<"CallLog"> | $Enums.CallDirection
    status?: StringFilter<"CallLog"> | string
    duration?: IntNullableFilter<"CallLog"> | number | null
    startTime?: DateTimeFilter<"CallLog"> | Date | string
    endTime?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeFilter<"CallLog"> | Date | string
    updatedAt?: DateTimeFilter<"CallLog"> | Date | string
    contactId?: StringNullableFilter<"CallLog"> | string | null
    dealId?: StringNullableFilter<"CallLog"> | string | null
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    deal?: XOR<DealNullableScalarRelationFilter, DealWhereInput> | null
    recording?: XOR<CallRecordingNullableScalarRelationFilter, CallRecordingWhereInput> | null
    transcription?: XOR<CallTranscriptionNullableScalarRelationFilter, CallTranscriptionWhereInput> | null
  }, "id">

  export type CallLogOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomName?: SortOrder
    callerSupabaseId?: SortOrder
    calleeSupabaseId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrderInput | SortOrder
    dealId?: SortOrderInput | SortOrder
    _count?: CallLogCountOrderByAggregateInput
    _avg?: CallLogAvgOrderByAggregateInput
    _max?: CallLogMaxOrderByAggregateInput
    _min?: CallLogMinOrderByAggregateInput
    _sum?: CallLogSumOrderByAggregateInput
  }

  export type CallLogScalarWhereWithAggregatesInput = {
    AND?: CallLogScalarWhereWithAggregatesInput | CallLogScalarWhereWithAggregatesInput[]
    OR?: CallLogScalarWhereWithAggregatesInput[]
    NOT?: CallLogScalarWhereWithAggregatesInput | CallLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallLog"> | string
    tenantId?: StringWithAggregatesFilter<"CallLog"> | string
    roomName?: StringWithAggregatesFilter<"CallLog"> | string
    callerSupabaseId?: StringWithAggregatesFilter<"CallLog"> | string
    calleeSupabaseId?: StringWithAggregatesFilter<"CallLog"> | string
    direction?: EnumCallDirectionWithAggregatesFilter<"CallLog"> | $Enums.CallDirection
    status?: StringWithAggregatesFilter<"CallLog"> | string
    duration?: IntNullableWithAggregatesFilter<"CallLog"> | number | null
    startTime?: DateTimeWithAggregatesFilter<"CallLog"> | Date | string
    endTime?: DateTimeNullableWithAggregatesFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CallLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CallLog"> | Date | string
    contactId?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
    dealId?: StringNullableWithAggregatesFilter<"CallLog"> | string | null
  }

  export type PortalCustomerWhereInput = {
    AND?: PortalCustomerWhereInput | PortalCustomerWhereInput[]
    OR?: PortalCustomerWhereInput[]
    NOT?: PortalCustomerWhereInput | PortalCustomerWhereInput[]
    id?: StringFilter<"PortalCustomer"> | string
    tenantId?: StringFilter<"PortalCustomer"> | string
    contactId?: StringNullableFilter<"PortalCustomer"> | string | null
    supabaseUserId?: StringNullableFilter<"PortalCustomer"> | string | null
    email?: StringFilter<"PortalCustomer"> | string
    name?: StringNullableFilter<"PortalCustomer"> | string | null
    avatarUrl?: StringNullableFilter<"PortalCustomer"> | string | null
    accessToken?: StringNullableFilter<"PortalCustomer"> | string | null
    fcmToken?: StringNullableFilter<"PortalCustomer"> | string | null
    pushSubscription?: JsonNullableFilter<"PortalCustomer">
    isActive?: BoolFilter<"PortalCustomer"> | boolean
    createdAt?: DateTimeFilter<"PortalCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"PortalCustomer"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    tickets?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
  }

  export type PortalCustomerOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    supabaseUserId?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    pushSubscription?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    contact?: ContactOrderByWithRelationInput
    tickets?: TicketOrderByRelationAggregateInput
    ticketComments?: TicketCommentOrderByRelationAggregateInput
  }

  export type PortalCustomerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accessToken?: string
    tenantId_supabaseUserId?: PortalCustomerTenantIdSupabaseUserIdCompoundUniqueInput
    tenantId_email?: PortalCustomerTenantIdEmailCompoundUniqueInput
    AND?: PortalCustomerWhereInput | PortalCustomerWhereInput[]
    OR?: PortalCustomerWhereInput[]
    NOT?: PortalCustomerWhereInput | PortalCustomerWhereInput[]
    tenantId?: StringFilter<"PortalCustomer"> | string
    contactId?: StringNullableFilter<"PortalCustomer"> | string | null
    supabaseUserId?: StringNullableFilter<"PortalCustomer"> | string | null
    email?: StringFilter<"PortalCustomer"> | string
    name?: StringNullableFilter<"PortalCustomer"> | string | null
    avatarUrl?: StringNullableFilter<"PortalCustomer"> | string | null
    fcmToken?: StringNullableFilter<"PortalCustomer"> | string | null
    pushSubscription?: JsonNullableFilter<"PortalCustomer">
    isActive?: BoolFilter<"PortalCustomer"> | boolean
    createdAt?: DateTimeFilter<"PortalCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"PortalCustomer"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    contact?: XOR<ContactNullableScalarRelationFilter, ContactWhereInput> | null
    tickets?: TicketListRelationFilter
    ticketComments?: TicketCommentListRelationFilter
  }, "id" | "accessToken" | "tenantId_supabaseUserId" | "tenantId_email">

  export type PortalCustomerOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrderInput | SortOrder
    supabaseUserId?: SortOrderInput | SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    pushSubscription?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PortalCustomerCountOrderByAggregateInput
    _max?: PortalCustomerMaxOrderByAggregateInput
    _min?: PortalCustomerMinOrderByAggregateInput
  }

  export type PortalCustomerScalarWhereWithAggregatesInput = {
    AND?: PortalCustomerScalarWhereWithAggregatesInput | PortalCustomerScalarWhereWithAggregatesInput[]
    OR?: PortalCustomerScalarWhereWithAggregatesInput[]
    NOT?: PortalCustomerScalarWhereWithAggregatesInput | PortalCustomerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PortalCustomer"> | string
    tenantId?: StringWithAggregatesFilter<"PortalCustomer"> | string
    contactId?: StringNullableWithAggregatesFilter<"PortalCustomer"> | string | null
    supabaseUserId?: StringNullableWithAggregatesFilter<"PortalCustomer"> | string | null
    email?: StringWithAggregatesFilter<"PortalCustomer"> | string
    name?: StringNullableWithAggregatesFilter<"PortalCustomer"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"PortalCustomer"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"PortalCustomer"> | string | null
    fcmToken?: StringNullableWithAggregatesFilter<"PortalCustomer"> | string | null
    pushSubscription?: JsonNullableWithAggregatesFilter<"PortalCustomer">
    isActive?: BoolWithAggregatesFilter<"PortalCustomer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PortalCustomer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PortalCustomer"> | Date | string
  }

  export type UserInvitationWhereInput = {
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    id?: StringFilter<"UserInvitation"> | string
    tenantId?: StringFilter<"UserInvitation"> | string
    email?: StringFilter<"UserInvitation"> | string
    role?: EnumUserRoleFilter<"UserInvitation"> | $Enums.UserRole
    invitedBy?: StringFilter<"UserInvitation"> | string
    token?: StringFilter<"UserInvitation"> | string
    expiresAt?: DateTimeFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invitedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserInvitationOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    invitedByUser?: UserOrderByWithRelationInput
  }

  export type UserInvitationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    tenantId_email?: UserInvitationTenantIdEmailCompoundUniqueInput
    AND?: UserInvitationWhereInput | UserInvitationWhereInput[]
    OR?: UserInvitationWhereInput[]
    NOT?: UserInvitationWhereInput | UserInvitationWhereInput[]
    tenantId?: StringFilter<"UserInvitation"> | string
    email?: StringFilter<"UserInvitation"> | string
    role?: EnumUserRoleFilter<"UserInvitation"> | $Enums.UserRole
    invitedBy?: StringFilter<"UserInvitation"> | string
    expiresAt?: DateTimeFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
    invitedByUser?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token" | "tenantId_email">

  export type UserInvitationOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserInvitationCountOrderByAggregateInput
    _max?: UserInvitationMaxOrderByAggregateInput
    _min?: UserInvitationMinOrderByAggregateInput
  }

  export type UserInvitationScalarWhereWithAggregatesInput = {
    AND?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    OR?: UserInvitationScalarWhereWithAggregatesInput[]
    NOT?: UserInvitationScalarWhereWithAggregatesInput | UserInvitationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserInvitation"> | string
    tenantId?: StringWithAggregatesFilter<"UserInvitation"> | string
    email?: StringWithAggregatesFilter<"UserInvitation"> | string
    role?: EnumUserRoleWithAggregatesFilter<"UserInvitation"> | $Enums.UserRole
    invitedBy?: StringWithAggregatesFilter<"UserInvitation"> | string
    token?: StringWithAggregatesFilter<"UserInvitation"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserInvitation"> | Date | string
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    tenantId?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    messages?: MessageOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    userId?: StringFilter<"Conversation"> | string
    tenantId?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
    messages?: MessageListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    title?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    userId?: StringWithAggregatesFilter<"Conversation"> | string
    tenantId?: StringWithAggregatesFilter<"Conversation"> | string
    title?: StringNullableWithAggregatesFilter<"Conversation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Conversation"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversation?: ConversationOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    conversationId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    conversationId?: StringWithAggregatesFilter<"Message"> | string
    role?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type TelegramLinkRequestWhereInput = {
    AND?: TelegramLinkRequestWhereInput | TelegramLinkRequestWhereInput[]
    OR?: TelegramLinkRequestWhereInput[]
    NOT?: TelegramLinkRequestWhereInput | TelegramLinkRequestWhereInput[]
    id?: StringFilter<"TelegramLinkRequest"> | string
    code?: StringFilter<"TelegramLinkRequest"> | string
    userId?: StringFilter<"TelegramLinkRequest"> | string
    expiresAt?: DateTimeFilter<"TelegramLinkRequest"> | Date | string
    usedAt?: DateTimeNullableFilter<"TelegramLinkRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"TelegramLinkRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TelegramLinkRequestOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TelegramLinkRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: TelegramLinkRequestWhereInput | TelegramLinkRequestWhereInput[]
    OR?: TelegramLinkRequestWhereInput[]
    NOT?: TelegramLinkRequestWhereInput | TelegramLinkRequestWhereInput[]
    userId?: StringFilter<"TelegramLinkRequest"> | string
    expiresAt?: DateTimeFilter<"TelegramLinkRequest"> | Date | string
    usedAt?: DateTimeNullableFilter<"TelegramLinkRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"TelegramLinkRequest"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "code">

  export type TelegramLinkRequestOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: TelegramLinkRequestCountOrderByAggregateInput
    _max?: TelegramLinkRequestMaxOrderByAggregateInput
    _min?: TelegramLinkRequestMinOrderByAggregateInput
  }

  export type TelegramLinkRequestScalarWhereWithAggregatesInput = {
    AND?: TelegramLinkRequestScalarWhereWithAggregatesInput | TelegramLinkRequestScalarWhereWithAggregatesInput[]
    OR?: TelegramLinkRequestScalarWhereWithAggregatesInput[]
    NOT?: TelegramLinkRequestScalarWhereWithAggregatesInput | TelegramLinkRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelegramLinkRequest"> | string
    code?: StringWithAggregatesFilter<"TelegramLinkRequest"> | string
    userId?: StringWithAggregatesFilter<"TelegramLinkRequest"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"TelegramLinkRequest"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"TelegramLinkRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TelegramLinkRequest"> | Date | string
  }

  export type TelegramUserWhereInput = {
    AND?: TelegramUserWhereInput | TelegramUserWhereInput[]
    OR?: TelegramUserWhereInput[]
    NOT?: TelegramUserWhereInput | TelegramUserWhereInput[]
    id?: StringFilter<"TelegramUser"> | string
    telegramId?: StringFilter<"TelegramUser"> | string
    userId?: StringFilter<"TelegramUser"> | string
    username?: StringNullableFilter<"TelegramUser"> | string | null
    firstName?: StringNullableFilter<"TelegramUser"> | string | null
    lastName?: StringNullableFilter<"TelegramUser"> | string | null
    avatarUrl?: StringNullableFilter<"TelegramUser"> | string | null
    isActive?: BoolFilter<"TelegramUser"> | boolean
    createdAt?: DateTimeFilter<"TelegramUser"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TelegramUserOrderByWithRelationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    userId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TelegramUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    telegramId?: string
    AND?: TelegramUserWhereInput | TelegramUserWhereInput[]
    OR?: TelegramUserWhereInput[]
    NOT?: TelegramUserWhereInput | TelegramUserWhereInput[]
    userId?: StringFilter<"TelegramUser"> | string
    username?: StringNullableFilter<"TelegramUser"> | string | null
    firstName?: StringNullableFilter<"TelegramUser"> | string | null
    lastName?: StringNullableFilter<"TelegramUser"> | string | null
    avatarUrl?: StringNullableFilter<"TelegramUser"> | string | null
    isActive?: BoolFilter<"TelegramUser"> | boolean
    createdAt?: DateTimeFilter<"TelegramUser"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "telegramId">

  export type TelegramUserOrderByWithAggregationInput = {
    id?: SortOrder
    telegramId?: SortOrder
    userId?: SortOrder
    username?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TelegramUserCountOrderByAggregateInput
    _max?: TelegramUserMaxOrderByAggregateInput
    _min?: TelegramUserMinOrderByAggregateInput
  }

  export type TelegramUserScalarWhereWithAggregatesInput = {
    AND?: TelegramUserScalarWhereWithAggregatesInput | TelegramUserScalarWhereWithAggregatesInput[]
    OR?: TelegramUserScalarWhereWithAggregatesInput[]
    NOT?: TelegramUserScalarWhereWithAggregatesInput | TelegramUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TelegramUser"> | string
    telegramId?: StringWithAggregatesFilter<"TelegramUser"> | string
    userId?: StringWithAggregatesFilter<"TelegramUser"> | string
    username?: StringNullableWithAggregatesFilter<"TelegramUser"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"TelegramUser"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"TelegramUser"> | string | null
    avatarUrl?: StringNullableWithAggregatesFilter<"TelegramUser"> | string | null
    isActive?: BoolWithAggregatesFilter<"TelegramUser"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TelegramUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TelegramUser"> | Date | string
  }

  export type CallEventWhereInput = {
    AND?: CallEventWhereInput | CallEventWhereInput[]
    OR?: CallEventWhereInput[]
    NOT?: CallEventWhereInput | CallEventWhereInput[]
    id?: StringFilter<"CallEvent"> | string
    tenantId?: StringFilter<"CallEvent"> | string
    callerId?: StringNullableFilter<"CallEvent"> | string | null
    calleeId?: StringNullableFilter<"CallEvent"> | string | null
    roomName?: StringFilter<"CallEvent"> | string
    eventType?: EnumCallEventTypeFilter<"CallEvent"> | $Enums.CallEventType
    payload?: JsonFilter<"CallEvent">
    createdAt?: DateTimeFilter<"CallEvent"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CallEventOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    callerId?: SortOrderInput | SortOrder
    calleeId?: SortOrderInput | SortOrder
    roomName?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
  }

  export type CallEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CallEventWhereInput | CallEventWhereInput[]
    OR?: CallEventWhereInput[]
    NOT?: CallEventWhereInput | CallEventWhereInput[]
    tenantId?: StringFilter<"CallEvent"> | string
    callerId?: StringNullableFilter<"CallEvent"> | string | null
    calleeId?: StringNullableFilter<"CallEvent"> | string | null
    roomName?: StringFilter<"CallEvent"> | string
    eventType?: EnumCallEventTypeFilter<"CallEvent"> | $Enums.CallEventType
    payload?: JsonFilter<"CallEvent">
    createdAt?: DateTimeFilter<"CallEvent"> | Date | string
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id">

  export type CallEventOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    callerId?: SortOrderInput | SortOrder
    calleeId?: SortOrderInput | SortOrder
    roomName?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
    _count?: CallEventCountOrderByAggregateInput
    _max?: CallEventMaxOrderByAggregateInput
    _min?: CallEventMinOrderByAggregateInput
  }

  export type CallEventScalarWhereWithAggregatesInput = {
    AND?: CallEventScalarWhereWithAggregatesInput | CallEventScalarWhereWithAggregatesInput[]
    OR?: CallEventScalarWhereWithAggregatesInput[]
    NOT?: CallEventScalarWhereWithAggregatesInput | CallEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallEvent"> | string
    tenantId?: StringWithAggregatesFilter<"CallEvent"> | string
    callerId?: StringNullableWithAggregatesFilter<"CallEvent"> | string | null
    calleeId?: StringNullableWithAggregatesFilter<"CallEvent"> | string | null
    roomName?: StringWithAggregatesFilter<"CallEvent"> | string
    eventType?: EnumCallEventTypeWithAggregatesFilter<"CallEvent"> | $Enums.CallEventType
    payload?: JsonWithAggregatesFilter<"CallEvent">
    createdAt?: DateTimeWithAggregatesFilter<"CallEvent"> | Date | string
  }

  export type CallRecordingWhereInput = {
    AND?: CallRecordingWhereInput | CallRecordingWhereInput[]
    OR?: CallRecordingWhereInput[]
    NOT?: CallRecordingWhereInput | CallRecordingWhereInput[]
    id?: StringFilter<"CallRecording"> | string
    callLogId?: StringFilter<"CallRecording"> | string
    tenantId?: StringFilter<"CallRecording"> | string
    fileUrl?: StringFilter<"CallRecording"> | string
    fileName?: StringFilter<"CallRecording"> | string
    fileSize?: IntNullableFilter<"CallRecording"> | number | null
    format?: StringFilter<"CallRecording"> | string
    duration?: IntNullableFilter<"CallRecording"> | number | null
    provider?: EnumRecordingProviderFilter<"CallRecording"> | $Enums.RecordingProvider
    providerId?: StringNullableFilter<"CallRecording"> | string | null
    status?: EnumRecordingStatusFilter<"CallRecording"> | $Enums.RecordingStatus
    recordingStartTime?: DateTimeNullableFilter<"CallRecording"> | Date | string | null
    recordingEndTime?: DateTimeNullableFilter<"CallRecording"> | Date | string | null
    createdAt?: DateTimeFilter<"CallRecording"> | Date | string
    updatedAt?: DateTimeFilter<"CallRecording"> | Date | string
    callLog?: XOR<CallLogScalarRelationFilter, CallLogWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CallRecordingOrderByWithRelationInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    format?: SortOrder
    duration?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    status?: SortOrder
    recordingStartTime?: SortOrderInput | SortOrder
    recordingEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    callLog?: CallLogOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CallRecordingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    callLogId?: string
    AND?: CallRecordingWhereInput | CallRecordingWhereInput[]
    OR?: CallRecordingWhereInput[]
    NOT?: CallRecordingWhereInput | CallRecordingWhereInput[]
    tenantId?: StringFilter<"CallRecording"> | string
    fileUrl?: StringFilter<"CallRecording"> | string
    fileName?: StringFilter<"CallRecording"> | string
    fileSize?: IntNullableFilter<"CallRecording"> | number | null
    format?: StringFilter<"CallRecording"> | string
    duration?: IntNullableFilter<"CallRecording"> | number | null
    provider?: EnumRecordingProviderFilter<"CallRecording"> | $Enums.RecordingProvider
    providerId?: StringNullableFilter<"CallRecording"> | string | null
    status?: EnumRecordingStatusFilter<"CallRecording"> | $Enums.RecordingStatus
    recordingStartTime?: DateTimeNullableFilter<"CallRecording"> | Date | string | null
    recordingEndTime?: DateTimeNullableFilter<"CallRecording"> | Date | string | null
    createdAt?: DateTimeFilter<"CallRecording"> | Date | string
    updatedAt?: DateTimeFilter<"CallRecording"> | Date | string
    callLog?: XOR<CallLogScalarRelationFilter, CallLogWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "callLogId">

  export type CallRecordingOrderByWithAggregationInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrderInput | SortOrder
    format?: SortOrder
    duration?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    status?: SortOrder
    recordingStartTime?: SortOrderInput | SortOrder
    recordingEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CallRecordingCountOrderByAggregateInput
    _avg?: CallRecordingAvgOrderByAggregateInput
    _max?: CallRecordingMaxOrderByAggregateInput
    _min?: CallRecordingMinOrderByAggregateInput
    _sum?: CallRecordingSumOrderByAggregateInput
  }

  export type CallRecordingScalarWhereWithAggregatesInput = {
    AND?: CallRecordingScalarWhereWithAggregatesInput | CallRecordingScalarWhereWithAggregatesInput[]
    OR?: CallRecordingScalarWhereWithAggregatesInput[]
    NOT?: CallRecordingScalarWhereWithAggregatesInput | CallRecordingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallRecording"> | string
    callLogId?: StringWithAggregatesFilter<"CallRecording"> | string
    tenantId?: StringWithAggregatesFilter<"CallRecording"> | string
    fileUrl?: StringWithAggregatesFilter<"CallRecording"> | string
    fileName?: StringWithAggregatesFilter<"CallRecording"> | string
    fileSize?: IntNullableWithAggregatesFilter<"CallRecording"> | number | null
    format?: StringWithAggregatesFilter<"CallRecording"> | string
    duration?: IntNullableWithAggregatesFilter<"CallRecording"> | number | null
    provider?: EnumRecordingProviderWithAggregatesFilter<"CallRecording"> | $Enums.RecordingProvider
    providerId?: StringNullableWithAggregatesFilter<"CallRecording"> | string | null
    status?: EnumRecordingStatusWithAggregatesFilter<"CallRecording"> | $Enums.RecordingStatus
    recordingStartTime?: DateTimeNullableWithAggregatesFilter<"CallRecording"> | Date | string | null
    recordingEndTime?: DateTimeNullableWithAggregatesFilter<"CallRecording"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CallRecording"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CallRecording"> | Date | string
  }

  export type CallTranscriptionWhereInput = {
    AND?: CallTranscriptionWhereInput | CallTranscriptionWhereInput[]
    OR?: CallTranscriptionWhereInput[]
    NOT?: CallTranscriptionWhereInput | CallTranscriptionWhereInput[]
    id?: StringFilter<"CallTranscription"> | string
    callLogId?: StringFilter<"CallTranscription"> | string
    tenantId?: StringFilter<"CallTranscription"> | string
    fullText?: StringFilter<"CallTranscription"> | string
    segments?: JsonFilter<"CallTranscription">
    language?: StringFilter<"CallTranscription"> | string
    confidence?: FloatNullableFilter<"CallTranscription"> | number | null
    wordCount?: IntNullableFilter<"CallTranscription"> | number | null
    summary?: StringNullableFilter<"CallTranscription"> | string | null
    keywords?: StringNullableListFilter<"CallTranscription">
    sentiment?: StringNullableFilter<"CallTranscription"> | string | null
    provider?: EnumTranscriptionProviderFilter<"CallTranscription"> | $Enums.TranscriptionProvider
    providerId?: StringNullableFilter<"CallTranscription"> | string | null
    status?: EnumTranscriptionStatusFilter<"CallTranscription"> | $Enums.TranscriptionStatus
    createdAt?: DateTimeFilter<"CallTranscription"> | Date | string
    updatedAt?: DateTimeFilter<"CallTranscription"> | Date | string
    callLog?: XOR<CallLogScalarRelationFilter, CallLogWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }

  export type CallTranscriptionOrderByWithRelationInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fullText?: SortOrder
    segments?: SortOrder
    language?: SortOrder
    confidence?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    keywords?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    callLog?: CallLogOrderByWithRelationInput
    tenant?: TenantOrderByWithRelationInput
  }

  export type CallTranscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    callLogId?: string
    AND?: CallTranscriptionWhereInput | CallTranscriptionWhereInput[]
    OR?: CallTranscriptionWhereInput[]
    NOT?: CallTranscriptionWhereInput | CallTranscriptionWhereInput[]
    tenantId?: StringFilter<"CallTranscription"> | string
    fullText?: StringFilter<"CallTranscription"> | string
    segments?: JsonFilter<"CallTranscription">
    language?: StringFilter<"CallTranscription"> | string
    confidence?: FloatNullableFilter<"CallTranscription"> | number | null
    wordCount?: IntNullableFilter<"CallTranscription"> | number | null
    summary?: StringNullableFilter<"CallTranscription"> | string | null
    keywords?: StringNullableListFilter<"CallTranscription">
    sentiment?: StringNullableFilter<"CallTranscription"> | string | null
    provider?: EnumTranscriptionProviderFilter<"CallTranscription"> | $Enums.TranscriptionProvider
    providerId?: StringNullableFilter<"CallTranscription"> | string | null
    status?: EnumTranscriptionStatusFilter<"CallTranscription"> | $Enums.TranscriptionStatus
    createdAt?: DateTimeFilter<"CallTranscription"> | Date | string
    updatedAt?: DateTimeFilter<"CallTranscription"> | Date | string
    callLog?: XOR<CallLogScalarRelationFilter, CallLogWhereInput>
    tenant?: XOR<TenantScalarRelationFilter, TenantWhereInput>
  }, "id" | "callLogId">

  export type CallTranscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fullText?: SortOrder
    segments?: SortOrder
    language?: SortOrder
    confidence?: SortOrderInput | SortOrder
    wordCount?: SortOrderInput | SortOrder
    summary?: SortOrderInput | SortOrder
    keywords?: SortOrder
    sentiment?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CallTranscriptionCountOrderByAggregateInput
    _avg?: CallTranscriptionAvgOrderByAggregateInput
    _max?: CallTranscriptionMaxOrderByAggregateInput
    _min?: CallTranscriptionMinOrderByAggregateInput
    _sum?: CallTranscriptionSumOrderByAggregateInput
  }

  export type CallTranscriptionScalarWhereWithAggregatesInput = {
    AND?: CallTranscriptionScalarWhereWithAggregatesInput | CallTranscriptionScalarWhereWithAggregatesInput[]
    OR?: CallTranscriptionScalarWhereWithAggregatesInput[]
    NOT?: CallTranscriptionScalarWhereWithAggregatesInput | CallTranscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CallTranscription"> | string
    callLogId?: StringWithAggregatesFilter<"CallTranscription"> | string
    tenantId?: StringWithAggregatesFilter<"CallTranscription"> | string
    fullText?: StringWithAggregatesFilter<"CallTranscription"> | string
    segments?: JsonWithAggregatesFilter<"CallTranscription">
    language?: StringWithAggregatesFilter<"CallTranscription"> | string
    confidence?: FloatNullableWithAggregatesFilter<"CallTranscription"> | number | null
    wordCount?: IntNullableWithAggregatesFilter<"CallTranscription"> | number | null
    summary?: StringNullableWithAggregatesFilter<"CallTranscription"> | string | null
    keywords?: StringNullableListFilter<"CallTranscription">
    sentiment?: StringNullableWithAggregatesFilter<"CallTranscription"> | string | null
    provider?: EnumTranscriptionProviderWithAggregatesFilter<"CallTranscription"> | $Enums.TranscriptionProvider
    providerId?: StringNullableWithAggregatesFilter<"CallTranscription"> | string | null
    status?: EnumTranscriptionStatusWithAggregatesFilter<"CallTranscription"> | $Enums.TranscriptionStatus
    createdAt?: DateTimeWithAggregatesFilter<"CallTranscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CallTranscription"> | Date | string
  }

  export type UserPresenceWhereInput = {
    AND?: UserPresenceWhereInput | UserPresenceWhereInput[]
    OR?: UserPresenceWhereInput[]
    NOT?: UserPresenceWhereInput | UserPresenceWhereInput[]
    id?: StringFilter<"UserPresence"> | string
    userId?: StringFilter<"UserPresence"> | string
    status?: EnumPresenceStatusFilter<"UserPresence"> | $Enums.PresenceStatus
    lastSeen?: DateTimeFilter<"UserPresence"> | Date | string
    currentRoom?: StringNullableFilter<"UserPresence"> | string | null
    tenantId?: StringFilter<"UserPresence"> | string
    createdAt?: DateTimeFilter<"UserPresence"> | Date | string
    updatedAt?: DateTimeFilter<"UserPresence"> | Date | string
  }

  export type UserPresenceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    currentRoom?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPresenceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserPresenceWhereInput | UserPresenceWhereInput[]
    OR?: UserPresenceWhereInput[]
    NOT?: UserPresenceWhereInput | UserPresenceWhereInput[]
    status?: EnumPresenceStatusFilter<"UserPresence"> | $Enums.PresenceStatus
    lastSeen?: DateTimeFilter<"UserPresence"> | Date | string
    currentRoom?: StringNullableFilter<"UserPresence"> | string | null
    tenantId?: StringFilter<"UserPresence"> | string
    createdAt?: DateTimeFilter<"UserPresence"> | Date | string
    updatedAt?: DateTimeFilter<"UserPresence"> | Date | string
  }, "id" | "userId">

  export type UserPresenceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    currentRoom?: SortOrderInput | SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserPresenceCountOrderByAggregateInput
    _max?: UserPresenceMaxOrderByAggregateInput
    _min?: UserPresenceMinOrderByAggregateInput
  }

  export type UserPresenceScalarWhereWithAggregatesInput = {
    AND?: UserPresenceScalarWhereWithAggregatesInput | UserPresenceScalarWhereWithAggregatesInput[]
    OR?: UserPresenceScalarWhereWithAggregatesInput[]
    NOT?: UserPresenceScalarWhereWithAggregatesInput | UserPresenceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserPresence"> | string
    userId?: StringWithAggregatesFilter<"UserPresence"> | string
    status?: EnumPresenceStatusWithAggregatesFilter<"UserPresence"> | $Enums.PresenceStatus
    lastSeen?: DateTimeWithAggregatesFilter<"UserPresence"> | Date | string
    currentRoom?: StringNullableWithAggregatesFilter<"UserPresence"> | string | null
    tenantId?: StringWithAggregatesFilter<"UserPresence"> | string
    createdAt?: DateTimeWithAggregatesFilter<"UserPresence"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserPresence"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
    interactions?: InteractionCreateNestedManyWithoutContactInput
    deals?: DealCreateNestedManyWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    callLogs?: CallLogCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutContactInput
    deals?: DealUncheckedCreateNestedManyWithoutContactInput
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
    interactions?: InteractionUpdateManyWithoutContactNestedInput
    deals?: DealUpdateManyWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutContactNestedInput
    deals?: DealUncheckedUpdateManyWithoutContactNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactCreateManyInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateInput = {
    id?: string
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
    contact?: ContactCreateNestedOneWithoutLeadsInput
    deals?: DealCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateInput = {
    id?: string
    tenantId: string
    contactId?: string | null
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    contact?: ContactUpdateOneWithoutLeadsNestedInput
    deals?: DealUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadCreateManyInput = {
    id?: string
    tenantId: string
    contactId?: string | null
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineCreateInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPipelinesInput
    stages?: StageCreateNestedManyWithoutPipelineInput
    deals?: DealCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUncheckedCreateInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutPipelineInput
    deals?: DealUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPipelinesNestedInput
    stages?: StageUpdateManyWithoutPipelineNestedInput
    deals?: DealUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutPipelineNestedInput
    deals?: DealUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineCreateManyInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageCreateInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pipeline: PipelineCreateNestedOneWithoutStagesInput
    deals?: DealCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateInput = {
    id?: string
    pipelineId: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: PipelineUpdateOneRequiredWithoutStagesNestedInput
    deals?: DealUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageCreateManyInput = {
    id?: string
    pipelineId: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    contact: ContactCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    tickets?: TicketCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealCreateManyInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateInput = {
    id?: string
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInteractionsInput
    contact: ContactCreateNestedOneWithoutInteractionsInput
    deal?: DealCreateNestedOneWithoutInteractionsInput
    user?: UserCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateInput = {
    id?: string
    tenantId: string
    contactId: string
    dealId?: string | null
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInteractionsNestedInput
    contact?: ContactUpdateOneRequiredWithoutInteractionsNestedInput
    deal?: DealUpdateOneWithoutInteractionsNestedInput
    user?: UserUpdateOneWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateManyInput = {
    id?: string
    tenantId: string
    contactId: string
    dealId?: string | null
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateInput = {
    id?: string
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketsInput
    deal?: DealCreateNestedOneWithoutTicketsInput
    assignedUser?: UserCreateNestedOneWithoutTicketsAssignedInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateInput = {
    id?: string
    tenantId: string
    contactId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketsNestedInput
    deal?: DealUpdateOneWithoutTicketsNestedInput
    assignedUser?: UserUpdateOneWithoutTicketsAssignedNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketCreateManyInput = {
    id?: string
    tenantId: string
    contactId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type TicketUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCommentCreateInput = {
    id?: string
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutTicketCommentsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateInput = {
    id?: string
    ticketId: string
    userId?: string | null
    portalCustomerId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutTicketCommentsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentCreateManyInput = {
    id?: string
    ticketId: string
    userId?: string | null
    portalCustomerId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateInput = {
    id?: string
    serviceName: string
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    syncStatus?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutIntegrationsInput
  }

  export type IntegrationUncheckedCreateInput = {
    id?: string
    tenantId: string
    serviceName: string
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    syncStatus?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutIntegrationsNestedInput
  }

  export type IntegrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationCreateManyInput = {
    id?: string
    tenantId: string
    serviceName: string
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    syncStatus?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallLogCreateInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallLogsInput
    contact?: ContactCreateNestedOneWithoutCallLogsInput
    deal?: DealCreateNestedOneWithoutCallLogsInput
    recording?: CallRecordingCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionCreateNestedOneWithoutCallLogInput
  }

  export type CallLogUncheckedCreateInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    dealId?: string | null
    recording?: CallRecordingUncheckedCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionUncheckedCreateNestedOneWithoutCallLogInput
  }

  export type CallLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallLogsNestedInput
    contact?: ContactUpdateOneWithoutCallLogsNestedInput
    deal?: DealUpdateOneWithoutCallLogsNestedInput
    recording?: CallRecordingUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: CallRecordingUncheckedUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUncheckedUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogCreateManyInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    dealId?: string | null
  }

  export type CallLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortalCustomerCreateInput = {
    id?: string
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPortalCustomersInput
    contact?: ContactCreateNestedOneWithoutPortalCustomersInput
    tickets?: TicketCreateNestedManyWithoutPortalCustomerInput
    ticketComments?: TicketCommentCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerUncheckedCreateInput = {
    id?: string
    tenantId: string
    contactId?: string | null
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutPortalCustomerInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPortalCustomersNestedInput
    contact?: ContactUpdateOneWithoutPortalCustomersNestedInput
    tickets?: TicketUpdateManyWithoutPortalCustomerNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutPortalCustomerNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerCreateManyInput = {
    id?: string
    tenantId: string
    contactId?: string | null
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PortalCustomerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PortalCustomerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationCreateInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUserInvitationsInput
    invitedByUser: UserCreateNestedOneWithoutInvitationsInput
  }

  export type UserInvitationUncheckedCreateInput = {
    id?: string
    tenantId: string
    email: string
    role?: $Enums.UserRole
    invitedBy: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUserInvitationsNestedInput
    invitedByUser?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type UserInvitationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationCreateManyInput = {
    id?: string
    tenantId: string
    email: string
    role?: $Enums.UserRole
    invitedBy: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationCreateInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    user: UserCreateNestedOneWithoutConversationsInput
    tenant: TenantCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    userId: string
    tenantId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    userId: string
    tenantId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
    conversation: ConversationCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramLinkRequestCreateInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTelegramLinkRequestsInput
  }

  export type TelegramLinkRequestUncheckedCreateInput = {
    id?: string
    code: string
    userId: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TelegramLinkRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTelegramLinkRequestsNestedInput
  }

  export type TelegramLinkRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramLinkRequestCreateManyInput = {
    id?: string
    code: string
    userId: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TelegramLinkRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramLinkRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserCreateInput = {
    id?: string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTelegramUsersInput
  }

  export type TelegramUserUncheckedCreateInput = {
    id?: string
    telegramId: string
    userId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTelegramUsersNestedInput
  }

  export type TelegramUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserCreateManyInput = {
    id?: string
    telegramId: string
    userId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallEventCreateInput = {
    id?: string
    callerId?: string | null
    calleeId?: string | null
    roomName: string
    eventType: $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallEventsInput
  }

  export type CallEventUncheckedCreateInput = {
    id?: string
    tenantId: string
    callerId?: string | null
    calleeId?: string | null
    roomName: string
    eventType: $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CallEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: NullableStringFieldUpdateOperationsInput | string | null
    calleeId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCallEventTypeFieldUpdateOperationsInput | $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallEventsNestedInput
  }

  export type CallEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    callerId?: NullableStringFieldUpdateOperationsInput | string | null
    calleeId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCallEventTypeFieldUpdateOperationsInput | $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallEventCreateManyInput = {
    id?: string
    tenantId: string
    callerId?: string | null
    calleeId?: string | null
    roomName: string
    eventType: $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CallEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: NullableStringFieldUpdateOperationsInput | string | null
    calleeId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCallEventTypeFieldUpdateOperationsInput | $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    callerId?: NullableStringFieldUpdateOperationsInput | string | null
    calleeId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCallEventTypeFieldUpdateOperationsInput | $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRecordingCreateInput = {
    id?: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    callLog: CallLogCreateNestedOneWithoutRecordingInput
    tenant: TenantCreateNestedOneWithoutCallRecordingsInput
  }

  export type CallRecordingUncheckedCreateInput = {
    id?: string
    callLogId: string
    tenantId: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRecordingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callLog?: CallLogUpdateOneRequiredWithoutRecordingNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCallRecordingsNestedInput
  }

  export type CallRecordingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRecordingCreateManyInput = {
    id?: string
    callLogId: string
    tenantId: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRecordingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRecordingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallTranscriptionCreateInput = {
    id?: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    callLog: CallLogCreateNestedOneWithoutTranscriptionInput
    tenant: TenantCreateNestedOneWithoutCallTranscriptionsInput
  }

  export type CallTranscriptionUncheckedCreateInput = {
    id?: string
    callLogId: string
    tenantId: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallTranscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callLog?: CallLogUpdateOneRequiredWithoutTranscriptionNestedInput
    tenant?: TenantUpdateOneRequiredWithoutCallTranscriptionsNestedInput
  }

  export type CallTranscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallTranscriptionCreateManyInput = {
    id?: string
    callLogId: string
    tenantId: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallTranscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallTranscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceCreateInput = {
    id?: string
    userId: string
    status?: $Enums.PresenceStatus
    lastSeen?: Date | string
    currentRoom?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPresenceUncheckedCreateInput = {
    id?: string
    userId: string
    status?: $Enums.PresenceStatus
    lastSeen?: Date | string
    currentRoom?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPresenceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    currentRoom?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    currentRoom?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceCreateManyInput = {
    id?: string
    userId: string
    status?: $Enums.PresenceStatus
    lastSeen?: Date | string
    currentRoom?: string | null
    tenantId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserPresenceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    currentRoom?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserPresenceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: EnumPresenceStatusFieldUpdateOperationsInput | $Enums.PresenceStatus
    lastSeen?: DateTimeFieldUpdateOperationsInput | Date | string
    currentRoom?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type ContactListRelationFilter = {
    every?: ContactWhereInput
    some?: ContactWhereInput
    none?: ContactWhereInput
  }

  export type LeadListRelationFilter = {
    every?: LeadWhereInput
    some?: LeadWhereInput
    none?: LeadWhereInput
  }

  export type PipelineListRelationFilter = {
    every?: PipelineWhereInput
    some?: PipelineWhereInput
    none?: PipelineWhereInput
  }

  export type DealListRelationFilter = {
    every?: DealWhereInput
    some?: DealWhereInput
    none?: DealWhereInput
  }

  export type InteractionListRelationFilter = {
    every?: InteractionWhereInput
    some?: InteractionWhereInput
    none?: InteractionWhereInput
  }

  export type TicketListRelationFilter = {
    every?: TicketWhereInput
    some?: TicketWhereInput
    none?: TicketWhereInput
  }

  export type IntegrationListRelationFilter = {
    every?: IntegrationWhereInput
    some?: IntegrationWhereInput
    none?: IntegrationWhereInput
  }

  export type CallLogListRelationFilter = {
    every?: CallLogWhereInput
    some?: CallLogWhereInput
    none?: CallLogWhereInput
  }

  export type PortalCustomerListRelationFilter = {
    every?: PortalCustomerWhereInput
    some?: PortalCustomerWhereInput
    none?: PortalCustomerWhereInput
  }

  export type UserInvitationListRelationFilter = {
    every?: UserInvitationWhereInput
    some?: UserInvitationWhereInput
    none?: UserInvitationWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type CallEventListRelationFilter = {
    every?: CallEventWhereInput
    some?: CallEventWhereInput
    none?: CallEventWhereInput
  }

  export type CallRecordingListRelationFilter = {
    every?: CallRecordingWhereInput
    some?: CallRecordingWhereInput
    none?: CallRecordingWhereInput
  }

  export type CallTranscriptionListRelationFilter = {
    every?: CallTranscriptionWhereInput
    some?: CallTranscriptionWhereInput
    none?: CallTranscriptionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeadOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DealOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TicketOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IntegrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PortalCustomerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInvitationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallRecordingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CallTranscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrder
    type?: SortOrder
    settings?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    domain?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type TenantScalarRelationFilter = {
    is?: TenantWhereInput
    isNot?: TenantWhereInput
  }

  export type TicketCommentListRelationFilter = {
    every?: TicketCommentWhereInput
    some?: TicketCommentWhereInput
    none?: TicketCommentWhereInput
  }

  export type TelegramUserListRelationFilter = {
    every?: TelegramUserWhereInput
    some?: TelegramUserWhereInput
    none?: TelegramUserWhereInput
  }

  export type TelegramLinkRequestListRelationFilter = {
    every?: TelegramLinkRequestWhereInput
    some?: TelegramLinkRequestWhereInput
    none?: TelegramLinkRequestWhereInput
  }

  export type TicketCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelegramUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TelegramLinkRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTenantIdSupabaseUserIdCompoundUniqueInput = {
    tenantId: string
    supabaseUserId: string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrder
    pushSubscription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    fcmToken?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type ContactCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    customFields?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContactMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    company?: SortOrder
    jobTitle?: SortOrder
    source?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ContactNullableScalarRelationFilter = {
    is?: ContactWhereInput | null
    isNot?: ContactWhereInput | null
  }

  export type LeadCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    title?: SortOrder
    source?: SortOrder
    status?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadAvgOrderByAggregateInput = {
    value?: SortOrder
  }

  export type LeadMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    title?: SortOrder
    source?: SortOrder
    status?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    title?: SortOrder
    source?: SortOrder
    status?: SortOrder
    value?: SortOrder
    notes?: SortOrder
    convertedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeadSumOrderByAggregateInput = {
    value?: SortOrder
  }

  export type EnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type StageListRelationFilter = {
    every?: StageWhereInput
    some?: StageWhereInput
    none?: StageWhereInput
  }

  export type StageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PipelineCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PipelineMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PipelineScalarRelationFilter = {
    is?: PipelineWhereInput
    isNot?: PipelineWhereInput
  }

  export type StagePipelineIdOrderCompoundUniqueInput = {
    pipelineId: string
    order: number
  }

  export type StageCountOrderByAggregateInput = {
    id?: SortOrder
    pipelineId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type StageMaxOrderByAggregateInput = {
    id?: SortOrder
    pipelineId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageMinOrderByAggregateInput = {
    id?: SortOrder
    pipelineId?: SortOrder
    name?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StageSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ContactScalarRelationFilter = {
    is?: ContactWhereInput
    isNot?: ContactWhereInput
  }

  export type LeadNullableScalarRelationFilter = {
    is?: LeadWhereInput | null
    isNot?: LeadWhereInput | null
  }

  export type StageScalarRelationFilter = {
    is?: StageWhereInput
    isNot?: StageWhereInput
  }

  export type DealCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    pipelineId?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealAvgOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type DealMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    pipelineId?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    leadId?: SortOrder
    pipelineId?: SortOrder
    stageId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    value?: SortOrder
    probability?: SortOrder
    expectedCloseDate?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DealSumOrderByAggregateInput = {
    value?: SortOrder
    probability?: SortOrder
  }

  export type EnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type DealNullableScalarRelationFilter = {
    is?: DealWhereInput | null
    isNot?: DealWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InteractionCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InteractionMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    dateTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type EnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type EnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type EnumTicketSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSource | EnumTicketSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSourceFilter<$PrismaModel> | $Enums.TicketSource
  }

  export type PortalCustomerNullableScalarRelationFilter = {
    is?: PortalCustomerWhereInput | null
    isNot?: PortalCustomerWhereInput | null
  }

  export type TicketTenantIdExternalIdExternalSystemCompoundUniqueInput = {
    tenantId: string
    externalId: string
    externalSystem: string
  }

  export type TicketCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    portalCustomerId?: SortOrder
    dealId?: SortOrder
    externalId?: SortOrder
    externalSystem?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    submittedByPortalCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    portalCustomerId?: SortOrder
    dealId?: SortOrder
    externalId?: SortOrder
    externalSystem?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    submittedByPortalCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrder
  }

  export type TicketMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    portalCustomerId?: SortOrder
    dealId?: SortOrder
    externalId?: SortOrder
    externalSystem?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    source?: SortOrder
    submittedByPortalCustomer?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    assignedUserId?: SortOrder
  }

  export type EnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type EnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type EnumTicketSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSource | EnumTicketSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSourceWithAggregatesFilter<$PrismaModel> | $Enums.TicketSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketSourceFilter<$PrismaModel>
    _max?: NestedEnumTicketSourceFilter<$PrismaModel>
  }

  export type TicketScalarRelationFilter = {
    is?: TicketWhereInput
    isNot?: TicketWhereInput
  }

  export type TicketCommentCountOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    portalCustomerId?: SortOrder
    content?: SortOrder
    authorName?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    portalCustomerId?: SortOrder
    content?: SortOrder
    authorName?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TicketCommentMinOrderByAggregateInput = {
    id?: SortOrder
    ticketId?: SortOrder
    userId?: SortOrder
    portalCustomerId?: SortOrder
    content?: SortOrder
    authorName?: SortOrder
    isInternal?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationTenantIdServiceNameCompoundUniqueInput = {
    tenantId: string
    serviceName: string
  }

  export type IntegrationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceName?: SortOrder
    isActive?: SortOrder
    config?: SortOrder
    lastSyncAt?: SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceName?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntegrationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceName?: SortOrder
    isActive?: SortOrder
    lastSyncAt?: SortOrder
    syncStatus?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCallDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionFilter<$PrismaModel> | $Enums.CallDirection
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CallRecordingNullableScalarRelationFilter = {
    is?: CallRecordingWhereInput | null
    isNot?: CallRecordingWhereInput | null
  }

  export type CallTranscriptionNullableScalarRelationFilter = {
    is?: CallTranscriptionWhereInput | null
    isNot?: CallTranscriptionWhereInput | null
  }

  export type CallLogCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomName?: SortOrder
    callerSupabaseId?: SortOrder
    calleeSupabaseId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
  }

  export type CallLogAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type CallLogMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomName?: SortOrder
    callerSupabaseId?: SortOrder
    calleeSupabaseId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
  }

  export type CallLogMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    roomName?: SortOrder
    callerSupabaseId?: SortOrder
    calleeSupabaseId?: SortOrder
    direction?: SortOrder
    status?: SortOrder
    duration?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contactId?: SortOrder
    dealId?: SortOrder
  }

  export type CallLogSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type EnumCallDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CallDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallDirectionFilter<$PrismaModel>
    _max?: NestedEnumCallDirectionFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type PortalCustomerTenantIdSupabaseUserIdCompoundUniqueInput = {
    tenantId: string
    supabaseUserId: string
  }

  export type PortalCustomerTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type PortalCustomerCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    accessToken?: SortOrder
    fcmToken?: SortOrder
    pushSubscription?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortalCustomerMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    accessToken?: SortOrder
    fcmToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PortalCustomerMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    contactId?: SortOrder
    supabaseUserId?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatarUrl?: SortOrder
    accessToken?: SortOrder
    fcmToken?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserInvitationTenantIdEmailCompoundUniqueInput = {
    tenantId: string
    email: string
  }

  export type UserInvitationCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserInvitationMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    email?: SortOrder
    role?: SortOrder
    invitedBy?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    acceptedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    title?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type TelegramLinkRequestCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TelegramLinkRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TelegramLinkRequestMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    userId?: SortOrder
    expiresAt?: SortOrder
    usedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type TelegramUserCountOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramUserMaxOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TelegramUserMinOrderByAggregateInput = {
    id?: SortOrder
    telegramId?: SortOrder
    userId?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    avatarUrl?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCallEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CallEventType | EnumCallEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCallEventTypeFilter<$PrismaModel> | $Enums.CallEventType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CallEventCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    callerId?: SortOrder
    calleeId?: SortOrder
    roomName?: SortOrder
    eventType?: SortOrder
    payload?: SortOrder
    createdAt?: SortOrder
  }

  export type CallEventMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    callerId?: SortOrder
    calleeId?: SortOrder
    roomName?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type CallEventMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    callerId?: SortOrder
    calleeId?: SortOrder
    roomName?: SortOrder
    eventType?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumCallEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallEventType | EnumCallEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCallEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CallEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCallEventTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumRecordingProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingProvider | EnumRecordingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingProviderFilter<$PrismaModel> | $Enums.RecordingProvider
  }

  export type EnumRecordingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusFilter<$PrismaModel> | $Enums.RecordingStatus
  }

  export type CallLogScalarRelationFilter = {
    is?: CallLogWhereInput
    isNot?: CallLogWhereInput
  }

  export type CallRecordingCountOrderByAggregateInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    duration?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    recordingStartTime?: SortOrder
    recordingEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRecordingAvgOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type CallRecordingMaxOrderByAggregateInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    duration?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    recordingStartTime?: SortOrder
    recordingEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRecordingMinOrderByAggregateInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    format?: SortOrder
    duration?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    recordingStartTime?: SortOrder
    recordingEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallRecordingSumOrderByAggregateInput = {
    fileSize?: SortOrder
    duration?: SortOrder
  }

  export type EnumRecordingProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingProvider | EnumRecordingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingProviderWithAggregatesFilter<$PrismaModel> | $Enums.RecordingProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingProviderFilter<$PrismaModel>
    _max?: NestedEnumRecordingProviderFilter<$PrismaModel>
  }

  export type EnumRecordingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecordingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingStatusFilter<$PrismaModel>
    _max?: NestedEnumRecordingStatusFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumTranscriptionProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderFilter<$PrismaModel> | $Enums.TranscriptionProvider
  }

  export type EnumTranscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionStatus | EnumTranscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionStatusFilter<$PrismaModel> | $Enums.TranscriptionStatus
  }

  export type CallTranscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fullText?: SortOrder
    segments?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    summary?: SortOrder
    keywords?: SortOrder
    sentiment?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallTranscriptionAvgOrderByAggregateInput = {
    confidence?: SortOrder
    wordCount?: SortOrder
  }

  export type CallTranscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fullText?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallTranscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    callLogId?: SortOrder
    tenantId?: SortOrder
    fullText?: SortOrder
    language?: SortOrder
    confidence?: SortOrder
    wordCount?: SortOrder
    summary?: SortOrder
    sentiment?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CallTranscriptionSumOrderByAggregateInput = {
    confidence?: SortOrder
    wordCount?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTranscriptionProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptionProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
    _max?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
  }

  export type EnumTranscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionStatus | EnumTranscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumTranscriptionStatusFilter<$PrismaModel>
  }

  export type EnumPresenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusFilter<$PrismaModel> | $Enums.PresenceStatus
  }

  export type UserPresenceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    currentRoom?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPresenceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    currentRoom?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserPresenceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    status?: SortOrder
    lastSeen?: SortOrder
    currentRoom?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPresenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.PresenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPresenceStatusFilter<$PrismaModel>
    _max?: NestedEnumPresenceStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ContactCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type PipelineCreateNestedManyWithoutTenantInput = {
    create?: XOR<PipelineCreateWithoutTenantInput, PipelineUncheckedCreateWithoutTenantInput> | PipelineCreateWithoutTenantInput[] | PipelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutTenantInput | PipelineCreateOrConnectWithoutTenantInput[]
    createMany?: PipelineCreateManyTenantInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type InteractionCreateNestedManyWithoutTenantInput = {
    create?: XOR<InteractionCreateWithoutTenantInput, InteractionUncheckedCreateWithoutTenantInput> | InteractionCreateWithoutTenantInput[] | InteractionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTenantInput | InteractionCreateOrConnectWithoutTenantInput[]
    createMany?: InteractionCreateManyTenantInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutTenantInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type IntegrationCreateNestedManyWithoutTenantInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type CallLogCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallLogCreateWithoutTenantInput, CallLogUncheckedCreateWithoutTenantInput> | CallLogCreateWithoutTenantInput[] | CallLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutTenantInput | CallLogCreateOrConnectWithoutTenantInput[]
    createMany?: CallLogCreateManyTenantInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type PortalCustomerCreateNestedManyWithoutTenantInput = {
    create?: XOR<PortalCustomerCreateWithoutTenantInput, PortalCustomerUncheckedCreateWithoutTenantInput> | PortalCustomerCreateWithoutTenantInput[] | PortalCustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTenantInput | PortalCustomerCreateOrConnectWithoutTenantInput[]
    createMany?: PortalCustomerCreateManyTenantInputEnvelope
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
  }

  export type UserInvitationCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserInvitationCreateWithoutTenantInput, UserInvitationUncheckedCreateWithoutTenantInput> | UserInvitationCreateWithoutTenantInput[] | UserInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutTenantInput | UserInvitationCreateOrConnectWithoutTenantInput[]
    createMany?: UserInvitationCreateManyTenantInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutTenantInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type CallEventCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallEventCreateWithoutTenantInput, CallEventUncheckedCreateWithoutTenantInput> | CallEventCreateWithoutTenantInput[] | CallEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallEventCreateOrConnectWithoutTenantInput | CallEventCreateOrConnectWithoutTenantInput[]
    createMany?: CallEventCreateManyTenantInputEnvelope
    connect?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
  }

  export type CallRecordingCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallRecordingCreateWithoutTenantInput, CallRecordingUncheckedCreateWithoutTenantInput> | CallRecordingCreateWithoutTenantInput[] | CallRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallRecordingCreateOrConnectWithoutTenantInput | CallRecordingCreateOrConnectWithoutTenantInput[]
    createMany?: CallRecordingCreateManyTenantInputEnvelope
    connect?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
  }

  export type CallTranscriptionCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallTranscriptionCreateWithoutTenantInput, CallTranscriptionUncheckedCreateWithoutTenantInput> | CallTranscriptionCreateWithoutTenantInput[] | CallTranscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutTenantInput | CallTranscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: CallTranscriptionCreateManyTenantInputEnvelope
    connect?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type ContactUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type PipelineUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PipelineCreateWithoutTenantInput, PipelineUncheckedCreateWithoutTenantInput> | PipelineCreateWithoutTenantInput[] | PipelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutTenantInput | PipelineCreateOrConnectWithoutTenantInput[]
    createMany?: PipelineCreateManyTenantInputEnvelope
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<InteractionCreateWithoutTenantInput, InteractionUncheckedCreateWithoutTenantInput> | InteractionCreateWithoutTenantInput[] | InteractionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTenantInput | InteractionCreateOrConnectWithoutTenantInput[]
    createMany?: InteractionCreateManyTenantInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type IntegrationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
  }

  export type CallLogUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallLogCreateWithoutTenantInput, CallLogUncheckedCreateWithoutTenantInput> | CallLogCreateWithoutTenantInput[] | CallLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutTenantInput | CallLogCreateOrConnectWithoutTenantInput[]
    createMany?: CallLogCreateManyTenantInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type PortalCustomerUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<PortalCustomerCreateWithoutTenantInput, PortalCustomerUncheckedCreateWithoutTenantInput> | PortalCustomerCreateWithoutTenantInput[] | PortalCustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTenantInput | PortalCustomerCreateOrConnectWithoutTenantInput[]
    createMany?: PortalCustomerCreateManyTenantInputEnvelope
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
  }

  export type UserInvitationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<UserInvitationCreateWithoutTenantInput, UserInvitationUncheckedCreateWithoutTenantInput> | UserInvitationCreateWithoutTenantInput[] | UserInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutTenantInput | UserInvitationCreateOrConnectWithoutTenantInput[]
    createMany?: UserInvitationCreateManyTenantInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type CallEventUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallEventCreateWithoutTenantInput, CallEventUncheckedCreateWithoutTenantInput> | CallEventCreateWithoutTenantInput[] | CallEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallEventCreateOrConnectWithoutTenantInput | CallEventCreateOrConnectWithoutTenantInput[]
    createMany?: CallEventCreateManyTenantInputEnvelope
    connect?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
  }

  export type CallRecordingUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallRecordingCreateWithoutTenantInput, CallRecordingUncheckedCreateWithoutTenantInput> | CallRecordingCreateWithoutTenantInput[] | CallRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallRecordingCreateOrConnectWithoutTenantInput | CallRecordingCreateOrConnectWithoutTenantInput[]
    createMany?: CallRecordingCreateManyTenantInputEnvelope
    connect?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
  }

  export type CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<CallTranscriptionCreateWithoutTenantInput, CallTranscriptionUncheckedCreateWithoutTenantInput> | CallTranscriptionCreateWithoutTenantInput[] | CallTranscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutTenantInput | CallTranscriptionCreateOrConnectWithoutTenantInput[]
    createMany?: CallTranscriptionCreateManyTenantInputEnvelope
    connect?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumTenantTypeFieldUpdateOperationsInput = {
    set?: $Enums.TenantType
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ContactUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenantInput | ContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenantInput | ContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenantInput | ContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type PipelineUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PipelineCreateWithoutTenantInput, PipelineUncheckedCreateWithoutTenantInput> | PipelineCreateWithoutTenantInput[] | PipelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutTenantInput | PipelineCreateOrConnectWithoutTenantInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutTenantInput | PipelineUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PipelineCreateManyTenantInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutTenantInput | PipelineUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutTenantInput | PipelineUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type DealUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type InteractionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InteractionCreateWithoutTenantInput, InteractionUncheckedCreateWithoutTenantInput> | InteractionCreateWithoutTenantInput[] | InteractionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTenantInput | InteractionCreateOrConnectWithoutTenantInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutTenantInput | InteractionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InteractionCreateManyTenantInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutTenantInput | InteractionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutTenantInput | InteractionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTenantInput | TicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTenantInput | TicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTenantInput | TicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type IntegrationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutTenantInput | IntegrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutTenantInput | IntegrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutTenantInput | IntegrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type CallLogUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallLogCreateWithoutTenantInput, CallLogUncheckedCreateWithoutTenantInput> | CallLogCreateWithoutTenantInput[] | CallLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutTenantInput | CallLogCreateOrConnectWithoutTenantInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutTenantInput | CallLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallLogCreateManyTenantInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutTenantInput | CallLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutTenantInput | CallLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type PortalCustomerUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PortalCustomerCreateWithoutTenantInput, PortalCustomerUncheckedCreateWithoutTenantInput> | PortalCustomerCreateWithoutTenantInput[] | PortalCustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTenantInput | PortalCustomerCreateOrConnectWithoutTenantInput[]
    upsert?: PortalCustomerUpsertWithWhereUniqueWithoutTenantInput | PortalCustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PortalCustomerCreateManyTenantInputEnvelope
    set?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    disconnect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    delete?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    update?: PortalCustomerUpdateWithWhereUniqueWithoutTenantInput | PortalCustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PortalCustomerUpdateManyWithWhereWithoutTenantInput | PortalCustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PortalCustomerScalarWhereInput | PortalCustomerScalarWhereInput[]
  }

  export type UserInvitationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserInvitationCreateWithoutTenantInput, UserInvitationUncheckedCreateWithoutTenantInput> | UserInvitationCreateWithoutTenantInput[] | UserInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutTenantInput | UserInvitationCreateOrConnectWithoutTenantInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutTenantInput | UserInvitationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserInvitationCreateManyTenantInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutTenantInput | UserInvitationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutTenantInput | UserInvitationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutTenantInput | ConversationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutTenantInput | ConversationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutTenantInput | ConversationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type CallEventUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallEventCreateWithoutTenantInput, CallEventUncheckedCreateWithoutTenantInput> | CallEventCreateWithoutTenantInput[] | CallEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallEventCreateOrConnectWithoutTenantInput | CallEventCreateOrConnectWithoutTenantInput[]
    upsert?: CallEventUpsertWithWhereUniqueWithoutTenantInput | CallEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallEventCreateManyTenantInputEnvelope
    set?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    disconnect?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    delete?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    connect?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    update?: CallEventUpdateWithWhereUniqueWithoutTenantInput | CallEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallEventUpdateManyWithWhereWithoutTenantInput | CallEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallEventScalarWhereInput | CallEventScalarWhereInput[]
  }

  export type CallRecordingUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallRecordingCreateWithoutTenantInput, CallRecordingUncheckedCreateWithoutTenantInput> | CallRecordingCreateWithoutTenantInput[] | CallRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallRecordingCreateOrConnectWithoutTenantInput | CallRecordingCreateOrConnectWithoutTenantInput[]
    upsert?: CallRecordingUpsertWithWhereUniqueWithoutTenantInput | CallRecordingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallRecordingCreateManyTenantInputEnvelope
    set?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    disconnect?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    delete?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    connect?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    update?: CallRecordingUpdateWithWhereUniqueWithoutTenantInput | CallRecordingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallRecordingUpdateManyWithWhereWithoutTenantInput | CallRecordingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallRecordingScalarWhereInput | CallRecordingScalarWhereInput[]
  }

  export type CallTranscriptionUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallTranscriptionCreateWithoutTenantInput, CallTranscriptionUncheckedCreateWithoutTenantInput> | CallTranscriptionCreateWithoutTenantInput[] | CallTranscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutTenantInput | CallTranscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: CallTranscriptionUpsertWithWhereUniqueWithoutTenantInput | CallTranscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallTranscriptionCreateManyTenantInputEnvelope
    set?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    disconnect?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    delete?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    connect?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    update?: CallTranscriptionUpdateWithWhereUniqueWithoutTenantInput | CallTranscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallTranscriptionUpdateManyWithWhereWithoutTenantInput | CallTranscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallTranscriptionScalarWhereInput | CallTranscriptionScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput> | UserCreateWithoutTenantInput[] | UserUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserCreateOrConnectWithoutTenantInput | UserCreateOrConnectWithoutTenantInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutTenantInput | UserUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserCreateManyTenantInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutTenantInput | UserUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserUpdateManyWithWhereWithoutTenantInput | UserUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type ContactUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput> | ContactCreateWithoutTenantInput[] | ContactUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ContactCreateOrConnectWithoutTenantInput | ContactCreateOrConnectWithoutTenantInput[]
    upsert?: ContactUpsertWithWhereUniqueWithoutTenantInput | ContactUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ContactCreateManyTenantInputEnvelope
    set?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    disconnect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    delete?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    connect?: ContactWhereUniqueInput | ContactWhereUniqueInput[]
    update?: ContactUpdateWithWhereUniqueWithoutTenantInput | ContactUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ContactUpdateManyWithWhereWithoutTenantInput | ContactUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ContactScalarWhereInput | ContactScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput> | LeadCreateWithoutTenantInput[] | LeadUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutTenantInput | LeadCreateOrConnectWithoutTenantInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutTenantInput | LeadUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: LeadCreateManyTenantInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutTenantInput | LeadUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutTenantInput | LeadUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type PipelineUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PipelineCreateWithoutTenantInput, PipelineUncheckedCreateWithoutTenantInput> | PipelineCreateWithoutTenantInput[] | PipelineUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PipelineCreateOrConnectWithoutTenantInput | PipelineCreateOrConnectWithoutTenantInput[]
    upsert?: PipelineUpsertWithWhereUniqueWithoutTenantInput | PipelineUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PipelineCreateManyTenantInputEnvelope
    set?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    disconnect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    delete?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    connect?: PipelineWhereUniqueInput | PipelineWhereUniqueInput[]
    update?: PipelineUpdateWithWhereUniqueWithoutTenantInput | PipelineUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PipelineUpdateManyWithWhereWithoutTenantInput | PipelineUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput> | DealCreateWithoutTenantInput[] | DealUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: DealCreateOrConnectWithoutTenantInput | DealCreateOrConnectWithoutTenantInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutTenantInput | DealUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: DealCreateManyTenantInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutTenantInput | DealUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: DealUpdateManyWithWhereWithoutTenantInput | DealUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<InteractionCreateWithoutTenantInput, InteractionUncheckedCreateWithoutTenantInput> | InteractionCreateWithoutTenantInput[] | InteractionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutTenantInput | InteractionCreateOrConnectWithoutTenantInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutTenantInput | InteractionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: InteractionCreateManyTenantInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutTenantInput | InteractionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutTenantInput | InteractionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput> | TicketCreateWithoutTenantInput[] | TicketUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutTenantInput | TicketCreateOrConnectWithoutTenantInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutTenantInput | TicketUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: TicketCreateManyTenantInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutTenantInput | TicketUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutTenantInput | TicketUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type IntegrationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput> | IntegrationCreateWithoutTenantInput[] | IntegrationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: IntegrationCreateOrConnectWithoutTenantInput | IntegrationCreateOrConnectWithoutTenantInput[]
    upsert?: IntegrationUpsertWithWhereUniqueWithoutTenantInput | IntegrationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: IntegrationCreateManyTenantInputEnvelope
    set?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    disconnect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    delete?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    connect?: IntegrationWhereUniqueInput | IntegrationWhereUniqueInput[]
    update?: IntegrationUpdateWithWhereUniqueWithoutTenantInput | IntegrationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: IntegrationUpdateManyWithWhereWithoutTenantInput | IntegrationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
  }

  export type CallLogUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallLogCreateWithoutTenantInput, CallLogUncheckedCreateWithoutTenantInput> | CallLogCreateWithoutTenantInput[] | CallLogUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutTenantInput | CallLogCreateOrConnectWithoutTenantInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutTenantInput | CallLogUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallLogCreateManyTenantInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutTenantInput | CallLogUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutTenantInput | CallLogUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<PortalCustomerCreateWithoutTenantInput, PortalCustomerUncheckedCreateWithoutTenantInput> | PortalCustomerCreateWithoutTenantInput[] | PortalCustomerUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTenantInput | PortalCustomerCreateOrConnectWithoutTenantInput[]
    upsert?: PortalCustomerUpsertWithWhereUniqueWithoutTenantInput | PortalCustomerUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: PortalCustomerCreateManyTenantInputEnvelope
    set?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    disconnect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    delete?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    update?: PortalCustomerUpdateWithWhereUniqueWithoutTenantInput | PortalCustomerUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: PortalCustomerUpdateManyWithWhereWithoutTenantInput | PortalCustomerUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: PortalCustomerScalarWhereInput | PortalCustomerScalarWhereInput[]
  }

  export type UserInvitationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<UserInvitationCreateWithoutTenantInput, UserInvitationUncheckedCreateWithoutTenantInput> | UserInvitationCreateWithoutTenantInput[] | UserInvitationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutTenantInput | UserInvitationCreateOrConnectWithoutTenantInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutTenantInput | UserInvitationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: UserInvitationCreateManyTenantInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutTenantInput | UserInvitationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutTenantInput | UserInvitationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput> | ConversationCreateWithoutTenantInput[] | ConversationUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutTenantInput | ConversationCreateOrConnectWithoutTenantInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutTenantInput | ConversationUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ConversationCreateManyTenantInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutTenantInput | ConversationUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutTenantInput | ConversationUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type CallEventUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallEventCreateWithoutTenantInput, CallEventUncheckedCreateWithoutTenantInput> | CallEventCreateWithoutTenantInput[] | CallEventUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallEventCreateOrConnectWithoutTenantInput | CallEventCreateOrConnectWithoutTenantInput[]
    upsert?: CallEventUpsertWithWhereUniqueWithoutTenantInput | CallEventUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallEventCreateManyTenantInputEnvelope
    set?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    disconnect?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    delete?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    connect?: CallEventWhereUniqueInput | CallEventWhereUniqueInput[]
    update?: CallEventUpdateWithWhereUniqueWithoutTenantInput | CallEventUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallEventUpdateManyWithWhereWithoutTenantInput | CallEventUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallEventScalarWhereInput | CallEventScalarWhereInput[]
  }

  export type CallRecordingUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallRecordingCreateWithoutTenantInput, CallRecordingUncheckedCreateWithoutTenantInput> | CallRecordingCreateWithoutTenantInput[] | CallRecordingUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallRecordingCreateOrConnectWithoutTenantInput | CallRecordingCreateOrConnectWithoutTenantInput[]
    upsert?: CallRecordingUpsertWithWhereUniqueWithoutTenantInput | CallRecordingUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallRecordingCreateManyTenantInputEnvelope
    set?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    disconnect?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    delete?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    connect?: CallRecordingWhereUniqueInput | CallRecordingWhereUniqueInput[]
    update?: CallRecordingUpdateWithWhereUniqueWithoutTenantInput | CallRecordingUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallRecordingUpdateManyWithWhereWithoutTenantInput | CallRecordingUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallRecordingScalarWhereInput | CallRecordingScalarWhereInput[]
  }

  export type CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<CallTranscriptionCreateWithoutTenantInput, CallTranscriptionUncheckedCreateWithoutTenantInput> | CallTranscriptionCreateWithoutTenantInput[] | CallTranscriptionUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutTenantInput | CallTranscriptionCreateOrConnectWithoutTenantInput[]
    upsert?: CallTranscriptionUpsertWithWhereUniqueWithoutTenantInput | CallTranscriptionUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: CallTranscriptionCreateManyTenantInputEnvelope
    set?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    disconnect?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    delete?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    connect?: CallTranscriptionWhereUniqueInput | CallTranscriptionWhereUniqueInput[]
    update?: CallTranscriptionUpdateWithWhereUniqueWithoutTenantInput | CallTranscriptionUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: CallTranscriptionUpdateManyWithWhereWithoutTenantInput | CallTranscriptionUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: CallTranscriptionScalarWhereInput | CallTranscriptionScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUsersInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    connect?: TenantWhereUniqueInput
  }

  export type InteractionCreateNestedManyWithoutUserInput = {
    create?: XOR<InteractionCreateWithoutUserInput, InteractionUncheckedCreateWithoutUserInput> | InteractionCreateWithoutUserInput[] | InteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutUserInput | InteractionCreateOrConnectWithoutUserInput[]
    createMany?: InteractionCreateManyUserInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<TicketCreateWithoutAssignedUserInput, TicketUncheckedCreateWithoutAssignedUserInput> | TicketCreateWithoutAssignedUserInput[] | TicketUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedUserInput | TicketCreateOrConnectWithoutAssignedUserInput[]
    createMany?: TicketCreateManyAssignedUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserInvitationCreateNestedManyWithoutInvitedByUserInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedByUserInput, UserInvitationUncheckedCreateWithoutInvitedByUserInput> | UserInvitationCreateWithoutInvitedByUserInput[] | UserInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedByUserInput | UserInvitationCreateOrConnectWithoutInvitedByUserInput[]
    createMany?: UserInvitationCreateManyInvitedByUserInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type TelegramUserCreateNestedManyWithoutUserInput = {
    create?: XOR<TelegramUserCreateWithoutUserInput, TelegramUserUncheckedCreateWithoutUserInput> | TelegramUserCreateWithoutUserInput[] | TelegramUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramUserCreateOrConnectWithoutUserInput | TelegramUserCreateOrConnectWithoutUserInput[]
    createMany?: TelegramUserCreateManyUserInputEnvelope
    connect?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
  }

  export type TelegramLinkRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<TelegramLinkRequestCreateWithoutUserInput, TelegramLinkRequestUncheckedCreateWithoutUserInput> | TelegramLinkRequestCreateWithoutUserInput[] | TelegramLinkRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramLinkRequestCreateOrConnectWithoutUserInput | TelegramLinkRequestCreateOrConnectWithoutUserInput[]
    createMany?: TelegramLinkRequestCreateManyUserInputEnvelope
    connect?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InteractionCreateWithoutUserInput, InteractionUncheckedCreateWithoutUserInput> | InteractionCreateWithoutUserInput[] | InteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutUserInput | InteractionCreateOrConnectWithoutUserInput[]
    createMany?: InteractionCreateManyUserInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutAssignedUserInput = {
    create?: XOR<TicketCreateWithoutAssignedUserInput, TicketUncheckedCreateWithoutAssignedUserInput> | TicketCreateWithoutAssignedUserInput[] | TicketUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedUserInput | TicketCreateOrConnectWithoutAssignedUserInput[]
    createMany?: TicketCreateManyAssignedUserInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedByUserInput, UserInvitationUncheckedCreateWithoutInvitedByUserInput> | UserInvitationCreateWithoutInvitedByUserInput[] | UserInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedByUserInput | UserInvitationCreateOrConnectWithoutInvitedByUserInput[]
    createMany?: UserInvitationCreateManyInvitedByUserInputEnvelope
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type TelegramUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TelegramUserCreateWithoutUserInput, TelegramUserUncheckedCreateWithoutUserInput> | TelegramUserCreateWithoutUserInput[] | TelegramUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramUserCreateOrConnectWithoutUserInput | TelegramUserCreateOrConnectWithoutUserInput[]
    createMany?: TelegramUserCreateManyUserInputEnvelope
    connect?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
  }

  export type TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TelegramLinkRequestCreateWithoutUserInput, TelegramLinkRequestUncheckedCreateWithoutUserInput> | TelegramLinkRequestCreateWithoutUserInput[] | TelegramLinkRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramLinkRequestCreateOrConnectWithoutUserInput | TelegramLinkRequestCreateOrConnectWithoutUserInput[]
    createMany?: TelegramLinkRequestCreateManyUserInputEnvelope
    connect?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type TenantUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUsersInput
    upsert?: TenantUpsertWithoutUsersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUsersInput, TenantUpdateWithoutUsersInput>, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type InteractionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InteractionCreateWithoutUserInput, InteractionUncheckedCreateWithoutUserInput> | InteractionCreateWithoutUserInput[] | InteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutUserInput | InteractionCreateOrConnectWithoutUserInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutUserInput | InteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InteractionCreateManyUserInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutUserInput | InteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutUserInput | InteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedUserInput, TicketUncheckedCreateWithoutAssignedUserInput> | TicketCreateWithoutAssignedUserInput[] | TicketUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedUserInput | TicketCreateOrConnectWithoutAssignedUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedUserInput | TicketUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: TicketCreateManyAssignedUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedUserInput | TicketUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedUserInput | TicketUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type UserInvitationUpdateManyWithoutInvitedByUserNestedInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedByUserInput, UserInvitationUncheckedCreateWithoutInvitedByUserInput> | UserInvitationCreateWithoutInvitedByUserInput[] | UserInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedByUserInput | UserInvitationCreateOrConnectWithoutInvitedByUserInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput | UserInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput[]
    createMany?: UserInvitationCreateManyInvitedByUserInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput | UserInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutInvitedByUserInput | UserInvitationUpdateManyWithWhereWithoutInvitedByUserInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type TelegramUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelegramUserCreateWithoutUserInput, TelegramUserUncheckedCreateWithoutUserInput> | TelegramUserCreateWithoutUserInput[] | TelegramUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramUserCreateOrConnectWithoutUserInput | TelegramUserCreateOrConnectWithoutUserInput[]
    upsert?: TelegramUserUpsertWithWhereUniqueWithoutUserInput | TelegramUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelegramUserCreateManyUserInputEnvelope
    set?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    disconnect?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    delete?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    connect?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    update?: TelegramUserUpdateWithWhereUniqueWithoutUserInput | TelegramUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelegramUserUpdateManyWithWhereWithoutUserInput | TelegramUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelegramUserScalarWhereInput | TelegramUserScalarWhereInput[]
  }

  export type TelegramLinkRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelegramLinkRequestCreateWithoutUserInput, TelegramLinkRequestUncheckedCreateWithoutUserInput> | TelegramLinkRequestCreateWithoutUserInput[] | TelegramLinkRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramLinkRequestCreateOrConnectWithoutUserInput | TelegramLinkRequestCreateOrConnectWithoutUserInput[]
    upsert?: TelegramLinkRequestUpsertWithWhereUniqueWithoutUserInput | TelegramLinkRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelegramLinkRequestCreateManyUserInputEnvelope
    set?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    disconnect?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    delete?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    connect?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    update?: TelegramLinkRequestUpdateWithWhereUniqueWithoutUserInput | TelegramLinkRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelegramLinkRequestUpdateManyWithWhereWithoutUserInput | TelegramLinkRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelegramLinkRequestScalarWhereInput | TelegramLinkRequestScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InteractionCreateWithoutUserInput, InteractionUncheckedCreateWithoutUserInput> | InteractionCreateWithoutUserInput[] | InteractionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutUserInput | InteractionCreateOrConnectWithoutUserInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutUserInput | InteractionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InteractionCreateManyUserInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutUserInput | InteractionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutUserInput | InteractionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutAssignedUserNestedInput = {
    create?: XOR<TicketCreateWithoutAssignedUserInput, TicketUncheckedCreateWithoutAssignedUserInput> | TicketCreateWithoutAssignedUserInput[] | TicketUncheckedCreateWithoutAssignedUserInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutAssignedUserInput | TicketCreateOrConnectWithoutAssignedUserInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutAssignedUserInput | TicketUpsertWithWhereUniqueWithoutAssignedUserInput[]
    createMany?: TicketCreateManyAssignedUserInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutAssignedUserInput | TicketUpdateWithWhereUniqueWithoutAssignedUserInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutAssignedUserInput | TicketUpdateManyWithWhereWithoutAssignedUserInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput> | TicketCommentCreateWithoutUserInput[] | TicketCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutUserInput | TicketCommentCreateOrConnectWithoutUserInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutUserInput | TicketCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TicketCommentCreateManyUserInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutUserInput | TicketCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutUserInput | TicketCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput = {
    create?: XOR<UserInvitationCreateWithoutInvitedByUserInput, UserInvitationUncheckedCreateWithoutInvitedByUserInput> | UserInvitationCreateWithoutInvitedByUserInput[] | UserInvitationUncheckedCreateWithoutInvitedByUserInput[]
    connectOrCreate?: UserInvitationCreateOrConnectWithoutInvitedByUserInput | UserInvitationCreateOrConnectWithoutInvitedByUserInput[]
    upsert?: UserInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput | UserInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput[]
    createMany?: UserInvitationCreateManyInvitedByUserInputEnvelope
    set?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    disconnect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    delete?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    connect?: UserInvitationWhereUniqueInput | UserInvitationWhereUniqueInput[]
    update?: UserInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput | UserInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput[]
    updateMany?: UserInvitationUpdateManyWithWhereWithoutInvitedByUserInput | UserInvitationUpdateManyWithWhereWithoutInvitedByUserInput[]
    deleteMany?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput> | ConversationCreateWithoutUserInput[] | ConversationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutUserInput | ConversationCreateOrConnectWithoutUserInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutUserInput | ConversationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ConversationCreateManyUserInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutUserInput | ConversationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutUserInput | ConversationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type TelegramUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelegramUserCreateWithoutUserInput, TelegramUserUncheckedCreateWithoutUserInput> | TelegramUserCreateWithoutUserInput[] | TelegramUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramUserCreateOrConnectWithoutUserInput | TelegramUserCreateOrConnectWithoutUserInput[]
    upsert?: TelegramUserUpsertWithWhereUniqueWithoutUserInput | TelegramUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelegramUserCreateManyUserInputEnvelope
    set?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    disconnect?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    delete?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    connect?: TelegramUserWhereUniqueInput | TelegramUserWhereUniqueInput[]
    update?: TelegramUserUpdateWithWhereUniqueWithoutUserInput | TelegramUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelegramUserUpdateManyWithWhereWithoutUserInput | TelegramUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelegramUserScalarWhereInput | TelegramUserScalarWhereInput[]
  }

  export type TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TelegramLinkRequestCreateWithoutUserInput, TelegramLinkRequestUncheckedCreateWithoutUserInput> | TelegramLinkRequestCreateWithoutUserInput[] | TelegramLinkRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TelegramLinkRequestCreateOrConnectWithoutUserInput | TelegramLinkRequestCreateOrConnectWithoutUserInput[]
    upsert?: TelegramLinkRequestUpsertWithWhereUniqueWithoutUserInput | TelegramLinkRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TelegramLinkRequestCreateManyUserInputEnvelope
    set?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    disconnect?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    delete?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    connect?: TelegramLinkRequestWhereUniqueInput | TelegramLinkRequestWhereUniqueInput[]
    update?: TelegramLinkRequestUpdateWithWhereUniqueWithoutUserInput | TelegramLinkRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TelegramLinkRequestUpdateManyWithWhereWithoutUserInput | TelegramLinkRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TelegramLinkRequestScalarWhereInput | TelegramLinkRequestScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutContactsInput = {
    create?: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContactsInput
    connect?: TenantWhereUniqueInput
  }

  export type LeadCreateNestedManyWithoutContactInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type InteractionCreateNestedManyWithoutContactInput = {
    create?: XOR<InteractionCreateWithoutContactInput, InteractionUncheckedCreateWithoutContactInput> | InteractionCreateWithoutContactInput[] | InteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutContactInput | InteractionCreateOrConnectWithoutContactInput[]
    createMany?: InteractionCreateManyContactInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutContactInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutContactInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CallLogCreateNestedManyWithoutContactInput = {
    create?: XOR<CallLogCreateWithoutContactInput, CallLogUncheckedCreateWithoutContactInput> | CallLogCreateWithoutContactInput[] | CallLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutContactInput | CallLogCreateOrConnectWithoutContactInput[]
    createMany?: CallLogCreateManyContactInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type PortalCustomerCreateNestedManyWithoutContactInput = {
    create?: XOR<PortalCustomerCreateWithoutContactInput, PortalCustomerUncheckedCreateWithoutContactInput> | PortalCustomerCreateWithoutContactInput[] | PortalCustomerUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutContactInput | PortalCustomerCreateOrConnectWithoutContactInput[]
    createMany?: PortalCustomerCreateManyContactInputEnvelope
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
  }

  export type LeadUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<InteractionCreateWithoutContactInput, InteractionUncheckedCreateWithoutContactInput> | InteractionCreateWithoutContactInput[] | InteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutContactInput | InteractionCreateOrConnectWithoutContactInput[]
    createMany?: InteractionCreateManyContactInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CallLogUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<CallLogCreateWithoutContactInput, CallLogUncheckedCreateWithoutContactInput> | CallLogCreateWithoutContactInput[] | CallLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutContactInput | CallLogCreateOrConnectWithoutContactInput[]
    createMany?: CallLogCreateManyContactInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type PortalCustomerUncheckedCreateNestedManyWithoutContactInput = {
    create?: XOR<PortalCustomerCreateWithoutContactInput, PortalCustomerUncheckedCreateWithoutContactInput> | PortalCustomerCreateWithoutContactInput[] | PortalCustomerUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutContactInput | PortalCustomerCreateOrConnectWithoutContactInput[]
    createMany?: PortalCustomerCreateManyContactInputEnvelope
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutContactsNestedInput = {
    create?: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutContactsInput
    upsert?: TenantUpsertWithoutContactsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutContactsInput, TenantUpdateWithoutContactsInput>, TenantUncheckedUpdateWithoutContactsInput>
  }

  export type LeadUpdateManyWithoutContactNestedInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutContactInput | LeadUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutContactInput | LeadUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutContactInput | LeadUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type InteractionUpdateManyWithoutContactNestedInput = {
    create?: XOR<InteractionCreateWithoutContactInput, InteractionUncheckedCreateWithoutContactInput> | InteractionCreateWithoutContactInput[] | InteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutContactInput | InteractionCreateOrConnectWithoutContactInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutContactInput | InteractionUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: InteractionCreateManyContactInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutContactInput | InteractionUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutContactInput | InteractionUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type DealUpdateManyWithoutContactNestedInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutContactInput | DealUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutContactInput | DealUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DealUpdateManyWithWhereWithoutContactInput | DealUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutContactNestedInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutContactInput | TicketUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutContactInput | TicketUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutContactInput | TicketUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CallLogUpdateManyWithoutContactNestedInput = {
    create?: XOR<CallLogCreateWithoutContactInput, CallLogUncheckedCreateWithoutContactInput> | CallLogCreateWithoutContactInput[] | CallLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutContactInput | CallLogCreateOrConnectWithoutContactInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutContactInput | CallLogUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CallLogCreateManyContactInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutContactInput | CallLogUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutContactInput | CallLogUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type PortalCustomerUpdateManyWithoutContactNestedInput = {
    create?: XOR<PortalCustomerCreateWithoutContactInput, PortalCustomerUncheckedCreateWithoutContactInput> | PortalCustomerCreateWithoutContactInput[] | PortalCustomerUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutContactInput | PortalCustomerCreateOrConnectWithoutContactInput[]
    upsert?: PortalCustomerUpsertWithWhereUniqueWithoutContactInput | PortalCustomerUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PortalCustomerCreateManyContactInputEnvelope
    set?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    disconnect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    delete?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    update?: PortalCustomerUpdateWithWhereUniqueWithoutContactInput | PortalCustomerUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PortalCustomerUpdateManyWithWhereWithoutContactInput | PortalCustomerUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PortalCustomerScalarWhereInput | PortalCustomerScalarWhereInput[]
  }

  export type LeadUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput> | LeadCreateWithoutContactInput[] | LeadUncheckedCreateWithoutContactInput[]
    connectOrCreate?: LeadCreateOrConnectWithoutContactInput | LeadCreateOrConnectWithoutContactInput[]
    upsert?: LeadUpsertWithWhereUniqueWithoutContactInput | LeadUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: LeadCreateManyContactInputEnvelope
    set?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    disconnect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    delete?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    connect?: LeadWhereUniqueInput | LeadWhereUniqueInput[]
    update?: LeadUpdateWithWhereUniqueWithoutContactInput | LeadUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: LeadUpdateManyWithWhereWithoutContactInput | LeadUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: LeadScalarWhereInput | LeadScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<InteractionCreateWithoutContactInput, InteractionUncheckedCreateWithoutContactInput> | InteractionCreateWithoutContactInput[] | InteractionUncheckedCreateWithoutContactInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutContactInput | InteractionCreateOrConnectWithoutContactInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutContactInput | InteractionUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: InteractionCreateManyContactInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutContactInput | InteractionUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutContactInput | InteractionUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput> | DealCreateWithoutContactInput[] | DealUncheckedCreateWithoutContactInput[]
    connectOrCreate?: DealCreateOrConnectWithoutContactInput | DealCreateOrConnectWithoutContactInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutContactInput | DealUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: DealCreateManyContactInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutContactInput | DealUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: DealUpdateManyWithWhereWithoutContactInput | DealUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput> | TicketCreateWithoutContactInput[] | TicketUncheckedCreateWithoutContactInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutContactInput | TicketCreateOrConnectWithoutContactInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutContactInput | TicketUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: TicketCreateManyContactInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutContactInput | TicketUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutContactInput | TicketUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CallLogUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<CallLogCreateWithoutContactInput, CallLogUncheckedCreateWithoutContactInput> | CallLogCreateWithoutContactInput[] | CallLogUncheckedCreateWithoutContactInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutContactInput | CallLogCreateOrConnectWithoutContactInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutContactInput | CallLogUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: CallLogCreateManyContactInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutContactInput | CallLogUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutContactInput | CallLogUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type PortalCustomerUncheckedUpdateManyWithoutContactNestedInput = {
    create?: XOR<PortalCustomerCreateWithoutContactInput, PortalCustomerUncheckedCreateWithoutContactInput> | PortalCustomerCreateWithoutContactInput[] | PortalCustomerUncheckedCreateWithoutContactInput[]
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutContactInput | PortalCustomerCreateOrConnectWithoutContactInput[]
    upsert?: PortalCustomerUpsertWithWhereUniqueWithoutContactInput | PortalCustomerUpsertWithWhereUniqueWithoutContactInput[]
    createMany?: PortalCustomerCreateManyContactInputEnvelope
    set?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    disconnect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    delete?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    connect?: PortalCustomerWhereUniqueInput | PortalCustomerWhereUniqueInput[]
    update?: PortalCustomerUpdateWithWhereUniqueWithoutContactInput | PortalCustomerUpdateWithWhereUniqueWithoutContactInput[]
    updateMany?: PortalCustomerUpdateManyWithWhereWithoutContactInput | PortalCustomerUpdateManyWithWhereWithoutContactInput[]
    deleteMany?: PortalCustomerScalarWhereInput | PortalCustomerScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutLeadsInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutLeadsInput = {
    create?: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutLeadsInput
    connect?: ContactWhereUniqueInput
  }

  export type DealCreateNestedManyWithoutLeadInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutLeadInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type EnumLeadStatusFieldUpdateOperationsInput = {
    set?: $Enums.LeadStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TenantUpdateOneRequiredWithoutLeadsNestedInput = {
    create?: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutLeadsInput
    upsert?: TenantUpsertWithoutLeadsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutLeadsInput, TenantUpdateWithoutLeadsInput>, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type ContactUpdateOneWithoutLeadsNestedInput = {
    create?: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutLeadsInput
    upsert?: ContactUpsertWithoutLeadsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutLeadsInput, ContactUpdateWithoutLeadsInput>, ContactUncheckedUpdateWithoutLeadsInput>
  }

  export type DealUpdateManyWithoutLeadNestedInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutLeadInput | DealUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutLeadInput | DealUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: DealUpdateManyWithWhereWithoutLeadInput | DealUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutLeadNestedInput = {
    create?: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput> | DealCreateWithoutLeadInput[] | DealUncheckedCreateWithoutLeadInput[]
    connectOrCreate?: DealCreateOrConnectWithoutLeadInput | DealCreateOrConnectWithoutLeadInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutLeadInput | DealUpsertWithWhereUniqueWithoutLeadInput[]
    createMany?: DealCreateManyLeadInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutLeadInput | DealUpdateWithWhereUniqueWithoutLeadInput[]
    updateMany?: DealUpdateManyWithWhereWithoutLeadInput | DealUpdateManyWithWhereWithoutLeadInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutPipelinesInput = {
    create?: XOR<TenantCreateWithoutPipelinesInput, TenantUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPipelinesInput
    connect?: TenantWhereUniqueInput
  }

  export type StageCreateNestedManyWithoutPipelineInput = {
    create?: XOR<StageCreateWithoutPipelineInput, StageUncheckedCreateWithoutPipelineInput> | StageCreateWithoutPipelineInput[] | StageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: StageCreateOrConnectWithoutPipelineInput | StageCreateOrConnectWithoutPipelineInput[]
    createMany?: StageCreateManyPipelineInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type DealCreateNestedManyWithoutPipelineInput = {
    create?: XOR<DealCreateWithoutPipelineInput, DealUncheckedCreateWithoutPipelineInput> | DealCreateWithoutPipelineInput[] | DealUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPipelineInput | DealCreateOrConnectWithoutPipelineInput[]
    createMany?: DealCreateManyPipelineInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type StageUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<StageCreateWithoutPipelineInput, StageUncheckedCreateWithoutPipelineInput> | StageCreateWithoutPipelineInput[] | StageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: StageCreateOrConnectWithoutPipelineInput | StageCreateOrConnectWithoutPipelineInput[]
    createMany?: StageCreateManyPipelineInputEnvelope
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutPipelineInput = {
    create?: XOR<DealCreateWithoutPipelineInput, DealUncheckedCreateWithoutPipelineInput> | DealCreateWithoutPipelineInput[] | DealUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPipelineInput | DealCreateOrConnectWithoutPipelineInput[]
    createMany?: DealCreateManyPipelineInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutPipelinesNestedInput = {
    create?: XOR<TenantCreateWithoutPipelinesInput, TenantUncheckedCreateWithoutPipelinesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPipelinesInput
    upsert?: TenantUpsertWithoutPipelinesInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPipelinesInput, TenantUpdateWithoutPipelinesInput>, TenantUncheckedUpdateWithoutPipelinesInput>
  }

  export type StageUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<StageCreateWithoutPipelineInput, StageUncheckedCreateWithoutPipelineInput> | StageCreateWithoutPipelineInput[] | StageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: StageCreateOrConnectWithoutPipelineInput | StageCreateOrConnectWithoutPipelineInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutPipelineInput | StageUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: StageCreateManyPipelineInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutPipelineInput | StageUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: StageUpdateManyWithWhereWithoutPipelineInput | StageUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type DealUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<DealCreateWithoutPipelineInput, DealUncheckedCreateWithoutPipelineInput> | DealCreateWithoutPipelineInput[] | DealUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPipelineInput | DealCreateOrConnectWithoutPipelineInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutPipelineInput | DealUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: DealCreateManyPipelineInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutPipelineInput | DealUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: DealUpdateManyWithWhereWithoutPipelineInput | DealUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type StageUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<StageCreateWithoutPipelineInput, StageUncheckedCreateWithoutPipelineInput> | StageCreateWithoutPipelineInput[] | StageUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: StageCreateOrConnectWithoutPipelineInput | StageCreateOrConnectWithoutPipelineInput[]
    upsert?: StageUpsertWithWhereUniqueWithoutPipelineInput | StageUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: StageCreateManyPipelineInputEnvelope
    set?: StageWhereUniqueInput | StageWhereUniqueInput[]
    disconnect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    delete?: StageWhereUniqueInput | StageWhereUniqueInput[]
    connect?: StageWhereUniqueInput | StageWhereUniqueInput[]
    update?: StageUpdateWithWhereUniqueWithoutPipelineInput | StageUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: StageUpdateManyWithWhereWithoutPipelineInput | StageUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: StageScalarWhereInput | StageScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutPipelineNestedInput = {
    create?: XOR<DealCreateWithoutPipelineInput, DealUncheckedCreateWithoutPipelineInput> | DealCreateWithoutPipelineInput[] | DealUncheckedCreateWithoutPipelineInput[]
    connectOrCreate?: DealCreateOrConnectWithoutPipelineInput | DealCreateOrConnectWithoutPipelineInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutPipelineInput | DealUpsertWithWhereUniqueWithoutPipelineInput[]
    createMany?: DealCreateManyPipelineInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutPipelineInput | DealUpdateWithWhereUniqueWithoutPipelineInput[]
    updateMany?: DealUpdateManyWithWhereWithoutPipelineInput | DealUpdateManyWithWhereWithoutPipelineInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type PipelineCreateNestedOneWithoutStagesInput = {
    create?: XOR<PipelineCreateWithoutStagesInput, PipelineUncheckedCreateWithoutStagesInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutStagesInput
    connect?: PipelineWhereUniqueInput
  }

  export type DealCreateNestedManyWithoutStageInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type DealUncheckedCreateNestedManyWithoutStageInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PipelineUpdateOneRequiredWithoutStagesNestedInput = {
    create?: XOR<PipelineCreateWithoutStagesInput, PipelineUncheckedCreateWithoutStagesInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutStagesInput
    upsert?: PipelineUpsertWithoutStagesInput
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutStagesInput, PipelineUpdateWithoutStagesInput>, PipelineUncheckedUpdateWithoutStagesInput>
  }

  export type DealUpdateManyWithoutStageNestedInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutStageInput | DealUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutStageInput | DealUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: DealUpdateManyWithWhereWithoutStageInput | DealUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type DealUncheckedUpdateManyWithoutStageNestedInput = {
    create?: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput> | DealCreateWithoutStageInput[] | DealUncheckedCreateWithoutStageInput[]
    connectOrCreate?: DealCreateOrConnectWithoutStageInput | DealCreateOrConnectWithoutStageInput[]
    upsert?: DealUpsertWithWhereUniqueWithoutStageInput | DealUpsertWithWhereUniqueWithoutStageInput[]
    createMany?: DealCreateManyStageInputEnvelope
    set?: DealWhereUniqueInput | DealWhereUniqueInput[]
    disconnect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    delete?: DealWhereUniqueInput | DealWhereUniqueInput[]
    connect?: DealWhereUniqueInput | DealWhereUniqueInput[]
    update?: DealUpdateWithWhereUniqueWithoutStageInput | DealUpdateWithWhereUniqueWithoutStageInput[]
    updateMany?: DealUpdateManyWithWhereWithoutStageInput | DealUpdateManyWithWhereWithoutStageInput[]
    deleteMany?: DealScalarWhereInput | DealScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutDealsInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutDealsInput = {
    create?: XOR<ContactCreateWithoutDealsInput, ContactUncheckedCreateWithoutDealsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDealsInput
    connect?: ContactWhereUniqueInput
  }

  export type LeadCreateNestedOneWithoutDealsInput = {
    create?: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealsInput
    connect?: LeadWhereUniqueInput
  }

  export type PipelineCreateNestedOneWithoutDealsInput = {
    create?: XOR<PipelineCreateWithoutDealsInput, PipelineUncheckedCreateWithoutDealsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutDealsInput
    connect?: PipelineWhereUniqueInput
  }

  export type StageCreateNestedOneWithoutDealsInput = {
    create?: XOR<StageCreateWithoutDealsInput, StageUncheckedCreateWithoutDealsInput>
    connectOrCreate?: StageCreateOrConnectWithoutDealsInput
    connect?: StageWhereUniqueInput
  }

  export type InteractionCreateNestedManyWithoutDealInput = {
    create?: XOR<InteractionCreateWithoutDealInput, InteractionUncheckedCreateWithoutDealInput> | InteractionCreateWithoutDealInput[] | InteractionUncheckedCreateWithoutDealInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutDealInput | InteractionCreateOrConnectWithoutDealInput[]
    createMany?: InteractionCreateManyDealInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TicketCreateNestedManyWithoutDealInput = {
    create?: XOR<TicketCreateWithoutDealInput, TicketUncheckedCreateWithoutDealInput> | TicketCreateWithoutDealInput[] | TicketUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutDealInput | TicketCreateOrConnectWithoutDealInput[]
    createMany?: TicketCreateManyDealInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CallLogCreateNestedManyWithoutDealInput = {
    create?: XOR<CallLogCreateWithoutDealInput, CallLogUncheckedCreateWithoutDealInput> | CallLogCreateWithoutDealInput[] | CallLogUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutDealInput | CallLogCreateOrConnectWithoutDealInput[]
    createMany?: CallLogCreateManyDealInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type InteractionUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<InteractionCreateWithoutDealInput, InteractionUncheckedCreateWithoutDealInput> | InteractionCreateWithoutDealInput[] | InteractionUncheckedCreateWithoutDealInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutDealInput | InteractionCreateOrConnectWithoutDealInput[]
    createMany?: InteractionCreateManyDealInputEnvelope
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<TicketCreateWithoutDealInput, TicketUncheckedCreateWithoutDealInput> | TicketCreateWithoutDealInput[] | TicketUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutDealInput | TicketCreateOrConnectWithoutDealInput[]
    createMany?: TicketCreateManyDealInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type CallLogUncheckedCreateNestedManyWithoutDealInput = {
    create?: XOR<CallLogCreateWithoutDealInput, CallLogUncheckedCreateWithoutDealInput> | CallLogCreateWithoutDealInput[] | CallLogUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutDealInput | CallLogCreateOrConnectWithoutDealInput[]
    createMany?: CallLogCreateManyDealInputEnvelope
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutDealsInput
    upsert?: TenantUpsertWithoutDealsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutDealsInput, TenantUpdateWithoutDealsInput>, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type ContactUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<ContactCreateWithoutDealsInput, ContactUncheckedCreateWithoutDealsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutDealsInput
    upsert?: ContactUpsertWithoutDealsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutDealsInput, ContactUpdateWithoutDealsInput>, ContactUncheckedUpdateWithoutDealsInput>
  }

  export type LeadUpdateOneWithoutDealsNestedInput = {
    create?: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
    connectOrCreate?: LeadCreateOrConnectWithoutDealsInput
    upsert?: LeadUpsertWithoutDealsInput
    disconnect?: LeadWhereInput | boolean
    delete?: LeadWhereInput | boolean
    connect?: LeadWhereUniqueInput
    update?: XOR<XOR<LeadUpdateToOneWithWhereWithoutDealsInput, LeadUpdateWithoutDealsInput>, LeadUncheckedUpdateWithoutDealsInput>
  }

  export type PipelineUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<PipelineCreateWithoutDealsInput, PipelineUncheckedCreateWithoutDealsInput>
    connectOrCreate?: PipelineCreateOrConnectWithoutDealsInput
    upsert?: PipelineUpsertWithoutDealsInput
    connect?: PipelineWhereUniqueInput
    update?: XOR<XOR<PipelineUpdateToOneWithWhereWithoutDealsInput, PipelineUpdateWithoutDealsInput>, PipelineUncheckedUpdateWithoutDealsInput>
  }

  export type StageUpdateOneRequiredWithoutDealsNestedInput = {
    create?: XOR<StageCreateWithoutDealsInput, StageUncheckedCreateWithoutDealsInput>
    connectOrCreate?: StageCreateOrConnectWithoutDealsInput
    upsert?: StageUpsertWithoutDealsInput
    connect?: StageWhereUniqueInput
    update?: XOR<XOR<StageUpdateToOneWithWhereWithoutDealsInput, StageUpdateWithoutDealsInput>, StageUncheckedUpdateWithoutDealsInput>
  }

  export type InteractionUpdateManyWithoutDealNestedInput = {
    create?: XOR<InteractionCreateWithoutDealInput, InteractionUncheckedCreateWithoutDealInput> | InteractionCreateWithoutDealInput[] | InteractionUncheckedCreateWithoutDealInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutDealInput | InteractionCreateOrConnectWithoutDealInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutDealInput | InteractionUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: InteractionCreateManyDealInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutDealInput | InteractionUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutDealInput | InteractionUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TicketUpdateManyWithoutDealNestedInput = {
    create?: XOR<TicketCreateWithoutDealInput, TicketUncheckedCreateWithoutDealInput> | TicketCreateWithoutDealInput[] | TicketUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutDealInput | TicketCreateOrConnectWithoutDealInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutDealInput | TicketUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TicketCreateManyDealInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutDealInput | TicketUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutDealInput | TicketUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CallLogUpdateManyWithoutDealNestedInput = {
    create?: XOR<CallLogCreateWithoutDealInput, CallLogUncheckedCreateWithoutDealInput> | CallLogCreateWithoutDealInput[] | CallLogUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutDealInput | CallLogCreateOrConnectWithoutDealInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutDealInput | CallLogUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CallLogCreateManyDealInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutDealInput | CallLogUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutDealInput | CallLogUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type InteractionUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<InteractionCreateWithoutDealInput, InteractionUncheckedCreateWithoutDealInput> | InteractionCreateWithoutDealInput[] | InteractionUncheckedCreateWithoutDealInput[]
    connectOrCreate?: InteractionCreateOrConnectWithoutDealInput | InteractionCreateOrConnectWithoutDealInput[]
    upsert?: InteractionUpsertWithWhereUniqueWithoutDealInput | InteractionUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: InteractionCreateManyDealInputEnvelope
    set?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    disconnect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    delete?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    connect?: InteractionWhereUniqueInput | InteractionWhereUniqueInput[]
    update?: InteractionUpdateWithWhereUniqueWithoutDealInput | InteractionUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: InteractionUpdateManyWithWhereWithoutDealInput | InteractionUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<TicketCreateWithoutDealInput, TicketUncheckedCreateWithoutDealInput> | TicketCreateWithoutDealInput[] | TicketUncheckedCreateWithoutDealInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutDealInput | TicketCreateOrConnectWithoutDealInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutDealInput | TicketUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: TicketCreateManyDealInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutDealInput | TicketUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutDealInput | TicketUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type CallLogUncheckedUpdateManyWithoutDealNestedInput = {
    create?: XOR<CallLogCreateWithoutDealInput, CallLogUncheckedCreateWithoutDealInput> | CallLogCreateWithoutDealInput[] | CallLogUncheckedCreateWithoutDealInput[]
    connectOrCreate?: CallLogCreateOrConnectWithoutDealInput | CallLogCreateOrConnectWithoutDealInput[]
    upsert?: CallLogUpsertWithWhereUniqueWithoutDealInput | CallLogUpsertWithWhereUniqueWithoutDealInput[]
    createMany?: CallLogCreateManyDealInputEnvelope
    set?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    disconnect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    delete?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    connect?: CallLogWhereUniqueInput | CallLogWhereUniqueInput[]
    update?: CallLogUpdateWithWhereUniqueWithoutDealInput | CallLogUpdateWithWhereUniqueWithoutDealInput[]
    updateMany?: CallLogUpdateManyWithWhereWithoutDealInput | CallLogUpdateManyWithWhereWithoutDealInput[]
    deleteMany?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<TenantCreateWithoutInteractionsInput, TenantUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInteractionsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<ContactCreateWithoutInteractionsInput, ContactUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutInteractionsInput
    connect?: ContactWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<DealCreateWithoutInteractionsInput, DealUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInteractionsInput
    connect?: DealWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInteractionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInteractionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InteractionType
  }

  export type TenantUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<TenantCreateWithoutInteractionsInput, TenantUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutInteractionsInput
    upsert?: TenantUpsertWithoutInteractionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutInteractionsInput, TenantUpdateWithoutInteractionsInput>, TenantUncheckedUpdateWithoutInteractionsInput>
  }

  export type ContactUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<ContactCreateWithoutInteractionsInput, ContactUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutInteractionsInput
    upsert?: ContactUpsertWithoutInteractionsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutInteractionsInput, ContactUpdateWithoutInteractionsInput>, ContactUncheckedUpdateWithoutInteractionsInput>
  }

  export type DealUpdateOneWithoutInteractionsNestedInput = {
    create?: XOR<DealCreateWithoutInteractionsInput, DealUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: DealCreateOrConnectWithoutInteractionsInput
    upsert?: DealUpsertWithoutInteractionsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutInteractionsInput, DealUpdateWithoutInteractionsInput>, DealUncheckedUpdateWithoutInteractionsInput>
  }

  export type UserUpdateOneWithoutInteractionsNestedInput = {
    create?: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInteractionsInput
    upsert?: UserUpsertWithoutInteractionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInteractionsInput, UserUpdateWithoutInteractionsInput>, UserUncheckedUpdateWithoutInteractionsInput>
  }

  export type TenantCreateNestedOneWithoutTicketsInput = {
    create?: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTicketsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutTicketsInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    connect?: ContactWhereUniqueInput
  }

  export type PortalCustomerCreateNestedOneWithoutTicketsInput = {
    create?: XOR<PortalCustomerCreateWithoutTicketsInput, PortalCustomerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTicketsInput
    connect?: PortalCustomerWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutTicketsInput = {
    create?: XOR<DealCreateWithoutTicketsInput, DealUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: DealCreateOrConnectWithoutTicketsInput
    connect?: DealWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketsAssignedInput = {
    create?: XOR<UserCreateWithoutTicketsAssignedInput, UserUncheckedCreateWithoutTicketsAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsAssignedInput
    connect?: UserWhereUniqueInput
  }

  export type TicketCommentCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutTicketInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type EnumTicketStatusFieldUpdateOperationsInput = {
    set?: $Enums.TicketStatus
  }

  export type EnumTicketPriorityFieldUpdateOperationsInput = {
    set?: $Enums.TicketPriority
  }

  export type EnumTicketSourceFieldUpdateOperationsInput = {
    set?: $Enums.TicketSource
  }

  export type TenantUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutTicketsInput
    upsert?: TenantUpsertWithoutTicketsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutTicketsInput, TenantUpdateWithoutTicketsInput>, TenantUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactUpdateOneRequiredWithoutTicketsNestedInput = {
    create?: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutTicketsInput
    upsert?: ContactUpsertWithoutTicketsInput
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutTicketsInput, ContactUpdateWithoutTicketsInput>, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type PortalCustomerUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<PortalCustomerCreateWithoutTicketsInput, PortalCustomerUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTicketsInput
    upsert?: PortalCustomerUpsertWithoutTicketsInput
    disconnect?: PortalCustomerWhereInput | boolean
    delete?: PortalCustomerWhereInput | boolean
    connect?: PortalCustomerWhereUniqueInput
    update?: XOR<XOR<PortalCustomerUpdateToOneWithWhereWithoutTicketsInput, PortalCustomerUpdateWithoutTicketsInput>, PortalCustomerUncheckedUpdateWithoutTicketsInput>
  }

  export type DealUpdateOneWithoutTicketsNestedInput = {
    create?: XOR<DealCreateWithoutTicketsInput, DealUncheckedCreateWithoutTicketsInput>
    connectOrCreate?: DealCreateOrConnectWithoutTicketsInput
    upsert?: DealUpsertWithoutTicketsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutTicketsInput, DealUpdateWithoutTicketsInput>, DealUncheckedUpdateWithoutTicketsInput>
  }

  export type UserUpdateOneWithoutTicketsAssignedNestedInput = {
    create?: XOR<UserCreateWithoutTicketsAssignedInput, UserUncheckedCreateWithoutTicketsAssignedInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketsAssignedInput
    upsert?: UserUpsertWithoutTicketsAssignedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketsAssignedInput, UserUpdateWithoutTicketsAssignedInput>, UserUncheckedUpdateWithoutTicketsAssignedInput>
  }

  export type TicketCommentUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketNestedInput = {
    create?: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput> | TicketCommentCreateWithoutTicketInput[] | TicketCommentUncheckedCreateWithoutTicketInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutTicketInput | TicketCommentCreateOrConnectWithoutTicketInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutTicketInput | TicketCommentUpsertWithWhereUniqueWithoutTicketInput[]
    createMany?: TicketCommentCreateManyTicketInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutTicketInput | TicketCommentUpdateWithWhereUniqueWithoutTicketInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutTicketInput | TicketCommentUpdateManyWithWhereWithoutTicketInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketCreateNestedOneWithoutCommentsInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    connect?: TicketWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTicketCommentsInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type PortalCustomerCreateNestedOneWithoutTicketCommentsInput = {
    create?: XOR<PortalCustomerCreateWithoutTicketCommentsInput, PortalCustomerUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTicketCommentsInput
    connect?: PortalCustomerWhereUniqueInput
  }

  export type TicketUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: TicketCreateOrConnectWithoutCommentsInput
    upsert?: TicketUpsertWithoutCommentsInput
    connect?: TicketWhereUniqueInput
    update?: XOR<XOR<TicketUpdateToOneWithWhereWithoutCommentsInput, TicketUpdateWithoutCommentsInput>, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneWithoutTicketCommentsNestedInput = {
    create?: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTicketCommentsInput
    upsert?: UserUpsertWithoutTicketCommentsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTicketCommentsInput, UserUpdateWithoutTicketCommentsInput>, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type PortalCustomerUpdateOneWithoutTicketCommentsNestedInput = {
    create?: XOR<PortalCustomerCreateWithoutTicketCommentsInput, PortalCustomerUncheckedCreateWithoutTicketCommentsInput>
    connectOrCreate?: PortalCustomerCreateOrConnectWithoutTicketCommentsInput
    upsert?: PortalCustomerUpsertWithoutTicketCommentsInput
    disconnect?: PortalCustomerWhereInput | boolean
    delete?: PortalCustomerWhereInput | boolean
    connect?: PortalCustomerWhereUniqueInput
    update?: XOR<XOR<PortalCustomerUpdateToOneWithWhereWithoutTicketCommentsInput, PortalCustomerUpdateWithoutTicketCommentsInput>, PortalCustomerUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type TenantCreateNestedOneWithoutIntegrationsInput = {
    create?: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIntegrationsInput
    connect?: TenantWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutIntegrationsNestedInput = {
    create?: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutIntegrationsInput
    upsert?: TenantUpsertWithoutIntegrationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutIntegrationsInput, TenantUpdateWithoutIntegrationsInput>, TenantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type TenantCreateNestedOneWithoutCallLogsInput = {
    create?: XOR<TenantCreateWithoutCallLogsInput, TenantUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallLogsInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutCallLogsInput = {
    create?: XOR<ContactCreateWithoutCallLogsInput, ContactUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCallLogsInput
    connect?: ContactWhereUniqueInput
  }

  export type DealCreateNestedOneWithoutCallLogsInput = {
    create?: XOR<DealCreateWithoutCallLogsInput, DealUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: DealCreateOrConnectWithoutCallLogsInput
    connect?: DealWhereUniqueInput
  }

  export type CallRecordingCreateNestedOneWithoutCallLogInput = {
    create?: XOR<CallRecordingCreateWithoutCallLogInput, CallRecordingUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallRecordingCreateOrConnectWithoutCallLogInput
    connect?: CallRecordingWhereUniqueInput
  }

  export type CallTranscriptionCreateNestedOneWithoutCallLogInput = {
    create?: XOR<CallTranscriptionCreateWithoutCallLogInput, CallTranscriptionUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutCallLogInput
    connect?: CallTranscriptionWhereUniqueInput
  }

  export type CallRecordingUncheckedCreateNestedOneWithoutCallLogInput = {
    create?: XOR<CallRecordingCreateWithoutCallLogInput, CallRecordingUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallRecordingCreateOrConnectWithoutCallLogInput
    connect?: CallRecordingWhereUniqueInput
  }

  export type CallTranscriptionUncheckedCreateNestedOneWithoutCallLogInput = {
    create?: XOR<CallTranscriptionCreateWithoutCallLogInput, CallTranscriptionUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutCallLogInput
    connect?: CallTranscriptionWhereUniqueInput
  }

  export type EnumCallDirectionFieldUpdateOperationsInput = {
    set?: $Enums.CallDirection
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type TenantUpdateOneRequiredWithoutCallLogsNestedInput = {
    create?: XOR<TenantCreateWithoutCallLogsInput, TenantUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallLogsInput
    upsert?: TenantUpsertWithoutCallLogsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCallLogsInput, TenantUpdateWithoutCallLogsInput>, TenantUncheckedUpdateWithoutCallLogsInput>
  }

  export type ContactUpdateOneWithoutCallLogsNestedInput = {
    create?: XOR<ContactCreateWithoutCallLogsInput, ContactUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: ContactCreateOrConnectWithoutCallLogsInput
    upsert?: ContactUpsertWithoutCallLogsInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutCallLogsInput, ContactUpdateWithoutCallLogsInput>, ContactUncheckedUpdateWithoutCallLogsInput>
  }

  export type DealUpdateOneWithoutCallLogsNestedInput = {
    create?: XOR<DealCreateWithoutCallLogsInput, DealUncheckedCreateWithoutCallLogsInput>
    connectOrCreate?: DealCreateOrConnectWithoutCallLogsInput
    upsert?: DealUpsertWithoutCallLogsInput
    disconnect?: DealWhereInput | boolean
    delete?: DealWhereInput | boolean
    connect?: DealWhereUniqueInput
    update?: XOR<XOR<DealUpdateToOneWithWhereWithoutCallLogsInput, DealUpdateWithoutCallLogsInput>, DealUncheckedUpdateWithoutCallLogsInput>
  }

  export type CallRecordingUpdateOneWithoutCallLogNestedInput = {
    create?: XOR<CallRecordingCreateWithoutCallLogInput, CallRecordingUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallRecordingCreateOrConnectWithoutCallLogInput
    upsert?: CallRecordingUpsertWithoutCallLogInput
    disconnect?: CallRecordingWhereInput | boolean
    delete?: CallRecordingWhereInput | boolean
    connect?: CallRecordingWhereUniqueInput
    update?: XOR<XOR<CallRecordingUpdateToOneWithWhereWithoutCallLogInput, CallRecordingUpdateWithoutCallLogInput>, CallRecordingUncheckedUpdateWithoutCallLogInput>
  }

  export type CallTranscriptionUpdateOneWithoutCallLogNestedInput = {
    create?: XOR<CallTranscriptionCreateWithoutCallLogInput, CallTranscriptionUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutCallLogInput
    upsert?: CallTranscriptionUpsertWithoutCallLogInput
    disconnect?: CallTranscriptionWhereInput | boolean
    delete?: CallTranscriptionWhereInput | boolean
    connect?: CallTranscriptionWhereUniqueInput
    update?: XOR<XOR<CallTranscriptionUpdateToOneWithWhereWithoutCallLogInput, CallTranscriptionUpdateWithoutCallLogInput>, CallTranscriptionUncheckedUpdateWithoutCallLogInput>
  }

  export type CallRecordingUncheckedUpdateOneWithoutCallLogNestedInput = {
    create?: XOR<CallRecordingCreateWithoutCallLogInput, CallRecordingUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallRecordingCreateOrConnectWithoutCallLogInput
    upsert?: CallRecordingUpsertWithoutCallLogInput
    disconnect?: CallRecordingWhereInput | boolean
    delete?: CallRecordingWhereInput | boolean
    connect?: CallRecordingWhereUniqueInput
    update?: XOR<XOR<CallRecordingUpdateToOneWithWhereWithoutCallLogInput, CallRecordingUpdateWithoutCallLogInput>, CallRecordingUncheckedUpdateWithoutCallLogInput>
  }

  export type CallTranscriptionUncheckedUpdateOneWithoutCallLogNestedInput = {
    create?: XOR<CallTranscriptionCreateWithoutCallLogInput, CallTranscriptionUncheckedCreateWithoutCallLogInput>
    connectOrCreate?: CallTranscriptionCreateOrConnectWithoutCallLogInput
    upsert?: CallTranscriptionUpsertWithoutCallLogInput
    disconnect?: CallTranscriptionWhereInput | boolean
    delete?: CallTranscriptionWhereInput | boolean
    connect?: CallTranscriptionWhereUniqueInput
    update?: XOR<XOR<CallTranscriptionUpdateToOneWithWhereWithoutCallLogInput, CallTranscriptionUpdateWithoutCallLogInput>, CallTranscriptionUncheckedUpdateWithoutCallLogInput>
  }

  export type TenantCreateNestedOneWithoutPortalCustomersInput = {
    create?: XOR<TenantCreateWithoutPortalCustomersInput, TenantUncheckedCreateWithoutPortalCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPortalCustomersInput
    connect?: TenantWhereUniqueInput
  }

  export type ContactCreateNestedOneWithoutPortalCustomersInput = {
    create?: XOR<ContactCreateWithoutPortalCustomersInput, ContactUncheckedCreateWithoutPortalCustomersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPortalCustomersInput
    connect?: ContactWhereUniqueInput
  }

  export type TicketCreateNestedManyWithoutPortalCustomerInput = {
    create?: XOR<TicketCreateWithoutPortalCustomerInput, TicketUncheckedCreateWithoutPortalCustomerInput> | TicketCreateWithoutPortalCustomerInput[] | TicketUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPortalCustomerInput | TicketCreateOrConnectWithoutPortalCustomerInput[]
    createMany?: TicketCreateManyPortalCustomerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentCreateNestedManyWithoutPortalCustomerInput = {
    create?: XOR<TicketCommentCreateWithoutPortalCustomerInput, TicketCommentUncheckedCreateWithoutPortalCustomerInput> | TicketCommentCreateWithoutPortalCustomerInput[] | TicketCommentUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutPortalCustomerInput | TicketCommentCreateOrConnectWithoutPortalCustomerInput[]
    createMany?: TicketCommentCreateManyPortalCustomerInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TicketUncheckedCreateNestedManyWithoutPortalCustomerInput = {
    create?: XOR<TicketCreateWithoutPortalCustomerInput, TicketUncheckedCreateWithoutPortalCustomerInput> | TicketCreateWithoutPortalCustomerInput[] | TicketUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPortalCustomerInput | TicketCreateOrConnectWithoutPortalCustomerInput[]
    createMany?: TicketCreateManyPortalCustomerInputEnvelope
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
  }

  export type TicketCommentUncheckedCreateNestedManyWithoutPortalCustomerInput = {
    create?: XOR<TicketCommentCreateWithoutPortalCustomerInput, TicketCommentUncheckedCreateWithoutPortalCustomerInput> | TicketCommentCreateWithoutPortalCustomerInput[] | TicketCommentUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutPortalCustomerInput | TicketCommentCreateOrConnectWithoutPortalCustomerInput[]
    createMany?: TicketCommentCreateManyPortalCustomerInputEnvelope
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
  }

  export type TenantUpdateOneRequiredWithoutPortalCustomersNestedInput = {
    create?: XOR<TenantCreateWithoutPortalCustomersInput, TenantUncheckedCreateWithoutPortalCustomersInput>
    connectOrCreate?: TenantCreateOrConnectWithoutPortalCustomersInput
    upsert?: TenantUpsertWithoutPortalCustomersInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutPortalCustomersInput, TenantUpdateWithoutPortalCustomersInput>, TenantUncheckedUpdateWithoutPortalCustomersInput>
  }

  export type ContactUpdateOneWithoutPortalCustomersNestedInput = {
    create?: XOR<ContactCreateWithoutPortalCustomersInput, ContactUncheckedCreateWithoutPortalCustomersInput>
    connectOrCreate?: ContactCreateOrConnectWithoutPortalCustomersInput
    upsert?: ContactUpsertWithoutPortalCustomersInput
    disconnect?: ContactWhereInput | boolean
    delete?: ContactWhereInput | boolean
    connect?: ContactWhereUniqueInput
    update?: XOR<XOR<ContactUpdateToOneWithWhereWithoutPortalCustomersInput, ContactUpdateWithoutPortalCustomersInput>, ContactUncheckedUpdateWithoutPortalCustomersInput>
  }

  export type TicketUpdateManyWithoutPortalCustomerNestedInput = {
    create?: XOR<TicketCreateWithoutPortalCustomerInput, TicketUncheckedCreateWithoutPortalCustomerInput> | TicketCreateWithoutPortalCustomerInput[] | TicketUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPortalCustomerInput | TicketCreateOrConnectWithoutPortalCustomerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPortalCustomerInput | TicketUpsertWithWhereUniqueWithoutPortalCustomerInput[]
    createMany?: TicketCreateManyPortalCustomerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPortalCustomerInput | TicketUpdateWithWhereUniqueWithoutPortalCustomerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPortalCustomerInput | TicketUpdateManyWithWhereWithoutPortalCustomerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUpdateManyWithoutPortalCustomerNestedInput = {
    create?: XOR<TicketCommentCreateWithoutPortalCustomerInput, TicketCommentUncheckedCreateWithoutPortalCustomerInput> | TicketCommentCreateWithoutPortalCustomerInput[] | TicketCommentUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutPortalCustomerInput | TicketCommentCreateOrConnectWithoutPortalCustomerInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutPortalCustomerInput | TicketCommentUpsertWithWhereUniqueWithoutPortalCustomerInput[]
    createMany?: TicketCommentCreateManyPortalCustomerInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutPortalCustomerInput | TicketCommentUpdateWithWhereUniqueWithoutPortalCustomerInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutPortalCustomerInput | TicketCommentUpdateManyWithWhereWithoutPortalCustomerInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TicketUncheckedUpdateManyWithoutPortalCustomerNestedInput = {
    create?: XOR<TicketCreateWithoutPortalCustomerInput, TicketUncheckedCreateWithoutPortalCustomerInput> | TicketCreateWithoutPortalCustomerInput[] | TicketUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCreateOrConnectWithoutPortalCustomerInput | TicketCreateOrConnectWithoutPortalCustomerInput[]
    upsert?: TicketUpsertWithWhereUniqueWithoutPortalCustomerInput | TicketUpsertWithWhereUniqueWithoutPortalCustomerInput[]
    createMany?: TicketCreateManyPortalCustomerInputEnvelope
    set?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    disconnect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    delete?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    connect?: TicketWhereUniqueInput | TicketWhereUniqueInput[]
    update?: TicketUpdateWithWhereUniqueWithoutPortalCustomerInput | TicketUpdateWithWhereUniqueWithoutPortalCustomerInput[]
    updateMany?: TicketUpdateManyWithWhereWithoutPortalCustomerInput | TicketUpdateManyWithWhereWithoutPortalCustomerInput[]
    deleteMany?: TicketScalarWhereInput | TicketScalarWhereInput[]
  }

  export type TicketCommentUncheckedUpdateManyWithoutPortalCustomerNestedInput = {
    create?: XOR<TicketCommentCreateWithoutPortalCustomerInput, TicketCommentUncheckedCreateWithoutPortalCustomerInput> | TicketCommentCreateWithoutPortalCustomerInput[] | TicketCommentUncheckedCreateWithoutPortalCustomerInput[]
    connectOrCreate?: TicketCommentCreateOrConnectWithoutPortalCustomerInput | TicketCommentCreateOrConnectWithoutPortalCustomerInput[]
    upsert?: TicketCommentUpsertWithWhereUniqueWithoutPortalCustomerInput | TicketCommentUpsertWithWhereUniqueWithoutPortalCustomerInput[]
    createMany?: TicketCommentCreateManyPortalCustomerInputEnvelope
    set?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    disconnect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    delete?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    connect?: TicketCommentWhereUniqueInput | TicketCommentWhereUniqueInput[]
    update?: TicketCommentUpdateWithWhereUniqueWithoutPortalCustomerInput | TicketCommentUpdateWithWhereUniqueWithoutPortalCustomerInput[]
    updateMany?: TicketCommentUpdateManyWithWhereWithoutPortalCustomerInput | TicketCommentUpdateManyWithWhereWithoutPortalCustomerInput[]
    deleteMany?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
  }

  export type TenantCreateNestedOneWithoutUserInvitationsInput = {
    create?: XOR<TenantCreateWithoutUserInvitationsInput, TenantUncheckedCreateWithoutUserInvitationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserInvitationsInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvitationsInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantUpdateOneRequiredWithoutUserInvitationsNestedInput = {
    create?: XOR<TenantCreateWithoutUserInvitationsInput, TenantUncheckedCreateWithoutUserInvitationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutUserInvitationsInput
    upsert?: TenantUpsertWithoutUserInvitationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutUserInvitationsInput, TenantUpdateWithoutUserInvitationsInput>, TenantUncheckedUpdateWithoutUserInvitationsInput>
  }

  export type UserUpdateOneRequiredWithoutInvitationsNestedInput = {
    create?: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvitationsInput
    upsert?: UserUpsertWithoutInvitationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvitationsInput, UserUpdateWithoutInvitationsInput>, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type MessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutConversationsInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    connect?: UserWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutConversationsInput = {
    create?: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutConversationsInput
    connect?: TenantWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutConversationsInput
    upsert?: UserUpsertWithoutConversationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutConversationsInput, UserUpdateWithoutConversationsInput>, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type TenantUpdateOneRequiredWithoutConversationsNestedInput = {
    create?: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutConversationsInput
    upsert?: TenantUpsertWithoutConversationsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutConversationsInput, TenantUpdateWithoutConversationsInput>, TenantUncheckedUpdateWithoutConversationsInput>
  }

  export type MessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput> | MessageCreateWithoutConversationInput[] | MessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutConversationInput | MessageCreateOrConnectWithoutConversationInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutConversationInput | MessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: MessageCreateManyConversationInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutConversationInput | MessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutConversationInput | MessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type ConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutMessagesInput
    upsert?: ConversationUpsertWithoutMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutMessagesInput, ConversationUpdateWithoutMessagesInput>, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutTelegramLinkRequestsInput = {
    create?: XOR<UserCreateWithoutTelegramLinkRequestsInput, UserUncheckedCreateWithoutTelegramLinkRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramLinkRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTelegramLinkRequestsNestedInput = {
    create?: XOR<UserCreateWithoutTelegramLinkRequestsInput, UserUncheckedCreateWithoutTelegramLinkRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramLinkRequestsInput
    upsert?: UserUpsertWithoutTelegramLinkRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTelegramLinkRequestsInput, UserUpdateWithoutTelegramLinkRequestsInput>, UserUncheckedUpdateWithoutTelegramLinkRequestsInput>
  }

  export type UserCreateNestedOneWithoutTelegramUsersInput = {
    create?: XOR<UserCreateWithoutTelegramUsersInput, UserUncheckedCreateWithoutTelegramUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramUsersInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTelegramUsersNestedInput = {
    create?: XOR<UserCreateWithoutTelegramUsersInput, UserUncheckedCreateWithoutTelegramUsersInput>
    connectOrCreate?: UserCreateOrConnectWithoutTelegramUsersInput
    upsert?: UserUpsertWithoutTelegramUsersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTelegramUsersInput, UserUpdateWithoutTelegramUsersInput>, UserUncheckedUpdateWithoutTelegramUsersInput>
  }

  export type TenantCreateNestedOneWithoutCallEventsInput = {
    create?: XOR<TenantCreateWithoutCallEventsInput, TenantUncheckedCreateWithoutCallEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallEventsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumCallEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.CallEventType
  }

  export type TenantUpdateOneRequiredWithoutCallEventsNestedInput = {
    create?: XOR<TenantCreateWithoutCallEventsInput, TenantUncheckedCreateWithoutCallEventsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallEventsInput
    upsert?: TenantUpsertWithoutCallEventsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCallEventsInput, TenantUpdateWithoutCallEventsInput>, TenantUncheckedUpdateWithoutCallEventsInput>
  }

  export type CallLogCreateNestedOneWithoutRecordingInput = {
    create?: XOR<CallLogCreateWithoutRecordingInput, CallLogUncheckedCreateWithoutRecordingInput>
    connectOrCreate?: CallLogCreateOrConnectWithoutRecordingInput
    connect?: CallLogWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCallRecordingsInput = {
    create?: XOR<TenantCreateWithoutCallRecordingsInput, TenantUncheckedCreateWithoutCallRecordingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallRecordingsInput
    connect?: TenantWhereUniqueInput
  }

  export type EnumRecordingProviderFieldUpdateOperationsInput = {
    set?: $Enums.RecordingProvider
  }

  export type EnumRecordingStatusFieldUpdateOperationsInput = {
    set?: $Enums.RecordingStatus
  }

  export type CallLogUpdateOneRequiredWithoutRecordingNestedInput = {
    create?: XOR<CallLogCreateWithoutRecordingInput, CallLogUncheckedCreateWithoutRecordingInput>
    connectOrCreate?: CallLogCreateOrConnectWithoutRecordingInput
    upsert?: CallLogUpsertWithoutRecordingInput
    connect?: CallLogWhereUniqueInput
    update?: XOR<XOR<CallLogUpdateToOneWithWhereWithoutRecordingInput, CallLogUpdateWithoutRecordingInput>, CallLogUncheckedUpdateWithoutRecordingInput>
  }

  export type TenantUpdateOneRequiredWithoutCallRecordingsNestedInput = {
    create?: XOR<TenantCreateWithoutCallRecordingsInput, TenantUncheckedCreateWithoutCallRecordingsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallRecordingsInput
    upsert?: TenantUpsertWithoutCallRecordingsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCallRecordingsInput, TenantUpdateWithoutCallRecordingsInput>, TenantUncheckedUpdateWithoutCallRecordingsInput>
  }

  export type CallTranscriptionCreatekeywordsInput = {
    set: string[]
  }

  export type CallLogCreateNestedOneWithoutTranscriptionInput = {
    create?: XOR<CallLogCreateWithoutTranscriptionInput, CallLogUncheckedCreateWithoutTranscriptionInput>
    connectOrCreate?: CallLogCreateOrConnectWithoutTranscriptionInput
    connect?: CallLogWhereUniqueInput
  }

  export type TenantCreateNestedOneWithoutCallTranscriptionsInput = {
    create?: XOR<TenantCreateWithoutCallTranscriptionsInput, TenantUncheckedCreateWithoutCallTranscriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallTranscriptionsInput
    connect?: TenantWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CallTranscriptionUpdatekeywordsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumTranscriptionProviderFieldUpdateOperationsInput = {
    set?: $Enums.TranscriptionProvider
  }

  export type EnumTranscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TranscriptionStatus
  }

  export type CallLogUpdateOneRequiredWithoutTranscriptionNestedInput = {
    create?: XOR<CallLogCreateWithoutTranscriptionInput, CallLogUncheckedCreateWithoutTranscriptionInput>
    connectOrCreate?: CallLogCreateOrConnectWithoutTranscriptionInput
    upsert?: CallLogUpsertWithoutTranscriptionInput
    connect?: CallLogWhereUniqueInput
    update?: XOR<XOR<CallLogUpdateToOneWithWhereWithoutTranscriptionInput, CallLogUpdateWithoutTranscriptionInput>, CallLogUncheckedUpdateWithoutTranscriptionInput>
  }

  export type TenantUpdateOneRequiredWithoutCallTranscriptionsNestedInput = {
    create?: XOR<TenantCreateWithoutCallTranscriptionsInput, TenantUncheckedCreateWithoutCallTranscriptionsInput>
    connectOrCreate?: TenantCreateOrConnectWithoutCallTranscriptionsInput
    upsert?: TenantUpsertWithoutCallTranscriptionsInput
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutCallTranscriptionsInput, TenantUpdateWithoutCallTranscriptionsInput>, TenantUncheckedUpdateWithoutCallTranscriptionsInput>
  }

  export type EnumPresenceStatusFieldUpdateOperationsInput = {
    set?: $Enums.PresenceStatus
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumTenantTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeFilter<$PrismaModel> | $Enums.TenantType
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TenantType | EnumTenantTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TenantType[] | ListEnumTenantTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTenantTypeWithAggregatesFilter<$PrismaModel> | $Enums.TenantType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTenantTypeFilter<$PrismaModel>
    _max?: NestedEnumTenantTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumLeadStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusFilter<$PrismaModel> | $Enums.LeadStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LeadStatus | EnumLeadStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LeadStatus[] | ListEnumLeadStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLeadStatusWithAggregatesFilter<$PrismaModel> | $Enums.LeadStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLeadStatusFilter<$PrismaModel>
    _max?: NestedEnumLeadStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumInteractionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeFilter<$PrismaModel> | $Enums.InteractionType
  }

  export type NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionType | EnumInteractionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionType[] | ListEnumInteractionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InteractionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionTypeFilter<$PrismaModel>
    _max?: NestedEnumInteractionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTicketStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusFilter<$PrismaModel> | $Enums.TicketStatus
  }

  export type NestedEnumTicketPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityFilter<$PrismaModel> | $Enums.TicketPriority
  }

  export type NestedEnumTicketSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSource | EnumTicketSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSourceFilter<$PrismaModel> | $Enums.TicketSource
  }

  export type NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketStatus | EnumTicketStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketStatus[] | ListEnumTicketStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketStatusWithAggregatesFilter<$PrismaModel> | $Enums.TicketStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketStatusFilter<$PrismaModel>
    _max?: NestedEnumTicketStatusFilter<$PrismaModel>
  }

  export type NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketPriority | EnumTicketPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketPriority[] | ListEnumTicketPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketPriorityWithAggregatesFilter<$PrismaModel> | $Enums.TicketPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketPriorityFilter<$PrismaModel>
    _max?: NestedEnumTicketPriorityFilter<$PrismaModel>
  }

  export type NestedEnumTicketSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TicketSource | EnumTicketSourceFieldRefInput<$PrismaModel>
    in?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    notIn?: $Enums.TicketSource[] | ListEnumTicketSourceFieldRefInput<$PrismaModel>
    not?: NestedEnumTicketSourceWithAggregatesFilter<$PrismaModel> | $Enums.TicketSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTicketSourceFilter<$PrismaModel>
    _max?: NestedEnumTicketSourceFilter<$PrismaModel>
  }

  export type NestedEnumCallDirectionFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionFilter<$PrismaModel> | $Enums.CallDirection
  }

  export type NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallDirection | EnumCallDirectionFieldRefInput<$PrismaModel>
    in?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallDirection[] | ListEnumCallDirectionFieldRefInput<$PrismaModel>
    not?: NestedEnumCallDirectionWithAggregatesFilter<$PrismaModel> | $Enums.CallDirection
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallDirectionFilter<$PrismaModel>
    _max?: NestedEnumCallDirectionFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumCallEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.CallEventType | EnumCallEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCallEventTypeFilter<$PrismaModel> | $Enums.CallEventType
  }

  export type NestedEnumCallEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CallEventType | EnumCallEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.CallEventType[] | ListEnumCallEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumCallEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.CallEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCallEventTypeFilter<$PrismaModel>
    _max?: NestedEnumCallEventTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumRecordingProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingProvider | EnumRecordingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingProviderFilter<$PrismaModel> | $Enums.RecordingProvider
  }

  export type NestedEnumRecordingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusFilter<$PrismaModel> | $Enums.RecordingStatus
  }

  export type NestedEnumRecordingProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingProvider | EnumRecordingProviderFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingProvider[] | ListEnumRecordingProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingProviderWithAggregatesFilter<$PrismaModel> | $Enums.RecordingProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingProviderFilter<$PrismaModel>
    _max?: NestedEnumRecordingProviderFilter<$PrismaModel>
  }

  export type NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RecordingStatus | EnumRecordingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RecordingStatus[] | ListEnumRecordingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRecordingStatusWithAggregatesFilter<$PrismaModel> | $Enums.RecordingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRecordingStatusFilter<$PrismaModel>
    _max?: NestedEnumRecordingStatusFilter<$PrismaModel>
  }

  export type NestedEnumTranscriptionProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderFilter<$PrismaModel> | $Enums.TranscriptionProvider
  }

  export type NestedEnumTranscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionStatus | EnumTranscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionStatusFilter<$PrismaModel> | $Enums.TranscriptionStatus
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTranscriptionProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionProvider | EnumTranscriptionProviderFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionProvider[] | ListEnumTranscriptionProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionProviderWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptionProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
    _max?: NestedEnumTranscriptionProviderFilter<$PrismaModel>
  }

  export type NestedEnumTranscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TranscriptionStatus | EnumTranscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TranscriptionStatus[] | ListEnumTranscriptionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTranscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TranscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTranscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumTranscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPresenceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusFilter<$PrismaModel> | $Enums.PresenceStatus
  }

  export type NestedEnumPresenceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PresenceStatus | EnumPresenceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PresenceStatus[] | ListEnumPresenceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPresenceStatusWithAggregatesFilter<$PrismaModel> | $Enums.PresenceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPresenceStatusFilter<$PrismaModel>
    _max?: NestedEnumPresenceStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutTenantInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTenantInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTenantInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserCreateManyTenantInputEnvelope = {
    data: UserCreateManyTenantInput | UserCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ContactCreateWithoutTenantInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadCreateNestedManyWithoutContactInput
    interactions?: InteractionCreateNestedManyWithoutContactInput
    deals?: DealCreateNestedManyWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    callLogs?: CallLogCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTenantInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutContactInput
    deals?: DealUncheckedCreateNestedManyWithoutContactInput
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTenantInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput>
  }

  export type ContactCreateManyTenantInputEnvelope = {
    data: ContactCreateManyTenantInput | ContactCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type LeadCreateWithoutTenantInput = {
    id?: string
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: ContactCreateNestedOneWithoutLeadsInput
    deals?: DealCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutTenantInput = {
    id?: string
    contactId?: string | null
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutTenantInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadCreateManyTenantInputEnvelope = {
    data: LeadCreateManyTenantInput | LeadCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PipelineCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageCreateNestedManyWithoutPipelineInput
    deals?: DealCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUncheckedCreateWithoutTenantInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutPipelineInput
    deals?: DealUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineCreateOrConnectWithoutTenantInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutTenantInput, PipelineUncheckedCreateWithoutTenantInput>
  }

  export type PipelineCreateManyTenantInputEnvelope = {
    data: PipelineCreateManyTenantInput | PipelineCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutTenantInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    tickets?: TicketCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutTenantInput = {
    id?: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutTenantInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealCreateManyTenantInputEnvelope = {
    data: DealCreateManyTenantInput | DealCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type InteractionCreateWithoutTenantInput = {
    id?: string
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutInteractionsInput
    deal?: DealCreateNestedOneWithoutInteractionsInput
    user?: UserCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateWithoutTenantInput = {
    id?: string
    contactId: string
    dealId?: string | null
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateOrConnectWithoutTenantInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutTenantInput, InteractionUncheckedCreateWithoutTenantInput>
  }

  export type InteractionCreateManyTenantInputEnvelope = {
    data: InteractionCreateManyTenantInput | InteractionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutTenantInput = {
    id?: string
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact: ContactCreateNestedOneWithoutTicketsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketsInput
    deal?: DealCreateNestedOneWithoutTicketsInput
    assignedUser?: UserCreateNestedOneWithoutTicketsAssignedInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutTenantInput = {
    id?: string
    contactId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutTenantInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput>
  }

  export type TicketCreateManyTenantInputEnvelope = {
    data: TicketCreateManyTenantInput | TicketCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type IntegrationCreateWithoutTenantInput = {
    id?: string
    serviceName: string
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    syncStatus?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationUncheckedCreateWithoutTenantInput = {
    id?: string
    serviceName: string
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    syncStatus?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type IntegrationCreateOrConnectWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    create: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput>
  }

  export type IntegrationCreateManyTenantInputEnvelope = {
    data: IntegrationCreateManyTenantInput | IntegrationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CallLogCreateWithoutTenantInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: ContactCreateNestedOneWithoutCallLogsInput
    deal?: DealCreateNestedOneWithoutCallLogsInput
    recording?: CallRecordingCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionCreateNestedOneWithoutCallLogInput
  }

  export type CallLogUncheckedCreateWithoutTenantInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    dealId?: string | null
    recording?: CallRecordingUncheckedCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionUncheckedCreateNestedOneWithoutCallLogInput
  }

  export type CallLogCreateOrConnectWithoutTenantInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutTenantInput, CallLogUncheckedCreateWithoutTenantInput>
  }

  export type CallLogCreateManyTenantInputEnvelope = {
    data: CallLogCreateManyTenantInput | CallLogCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type PortalCustomerCreateWithoutTenantInput = {
    id?: string
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contact?: ContactCreateNestedOneWithoutPortalCustomersInput
    tickets?: TicketCreateNestedManyWithoutPortalCustomerInput
    ticketComments?: TicketCommentCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerUncheckedCreateWithoutTenantInput = {
    id?: string
    contactId?: string | null
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutPortalCustomerInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerCreateOrConnectWithoutTenantInput = {
    where: PortalCustomerWhereUniqueInput
    create: XOR<PortalCustomerCreateWithoutTenantInput, PortalCustomerUncheckedCreateWithoutTenantInput>
  }

  export type PortalCustomerCreateManyTenantInputEnvelope = {
    data: PortalCustomerCreateManyTenantInput | PortalCustomerCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserInvitationCreateWithoutTenantInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    invitedByUser: UserCreateNestedOneWithoutInvitationsInput
  }

  export type UserInvitationUncheckedCreateWithoutTenantInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    invitedBy: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationCreateOrConnectWithoutTenantInput = {
    where: UserInvitationWhereUniqueInput
    create: XOR<UserInvitationCreateWithoutTenantInput, UserInvitationUncheckedCreateWithoutTenantInput>
  }

  export type UserInvitationCreateManyTenantInputEnvelope = {
    data: UserInvitationCreateManyTenantInput | UserInvitationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutTenantInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    user: UserCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutTenantInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutTenantInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput>
  }

  export type ConversationCreateManyTenantInputEnvelope = {
    data: ConversationCreateManyTenantInput | ConversationCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CallEventCreateWithoutTenantInput = {
    id?: string
    callerId?: string | null
    calleeId?: string | null
    roomName: string
    eventType: $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CallEventUncheckedCreateWithoutTenantInput = {
    id?: string
    callerId?: string | null
    calleeId?: string | null
    roomName: string
    eventType: $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CallEventCreateOrConnectWithoutTenantInput = {
    where: CallEventWhereUniqueInput
    create: XOR<CallEventCreateWithoutTenantInput, CallEventUncheckedCreateWithoutTenantInput>
  }

  export type CallEventCreateManyTenantInputEnvelope = {
    data: CallEventCreateManyTenantInput | CallEventCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CallRecordingCreateWithoutTenantInput = {
    id?: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    callLog: CallLogCreateNestedOneWithoutRecordingInput
  }

  export type CallRecordingUncheckedCreateWithoutTenantInput = {
    id?: string
    callLogId: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRecordingCreateOrConnectWithoutTenantInput = {
    where: CallRecordingWhereUniqueInput
    create: XOR<CallRecordingCreateWithoutTenantInput, CallRecordingUncheckedCreateWithoutTenantInput>
  }

  export type CallRecordingCreateManyTenantInputEnvelope = {
    data: CallRecordingCreateManyTenantInput | CallRecordingCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type CallTranscriptionCreateWithoutTenantInput = {
    id?: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    callLog: CallLogCreateNestedOneWithoutTranscriptionInput
  }

  export type CallTranscriptionUncheckedCreateWithoutTenantInput = {
    id?: string
    callLogId: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallTranscriptionCreateOrConnectWithoutTenantInput = {
    where: CallTranscriptionWhereUniqueInput
    create: XOR<CallTranscriptionCreateWithoutTenantInput, CallTranscriptionUncheckedCreateWithoutTenantInput>
  }

  export type CallTranscriptionCreateManyTenantInputEnvelope = {
    data: CallTranscriptionCreateManyTenantInput | CallTranscriptionCreateManyTenantInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
    create: XOR<UserCreateWithoutTenantInput, UserUncheckedCreateWithoutTenantInput>
  }

  export type UserUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutTenantInput, UserUncheckedUpdateWithoutTenantInput>
  }

  export type UserUpdateManyWithWhereWithoutTenantInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    tenantId?: StringFilter<"User"> | string
    supabaseUserId?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    name?: StringNullableFilter<"User"> | string | null
    avatarUrl?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isActive?: BoolFilter<"User"> | boolean
    fcmToken?: StringNullableFilter<"User"> | string | null
    pushSubscription?: JsonNullableFilter<"User">
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type ContactUpsertWithWhereUniqueWithoutTenantInput = {
    where: ContactWhereUniqueInput
    update: XOR<ContactUpdateWithoutTenantInput, ContactUncheckedUpdateWithoutTenantInput>
    create: XOR<ContactCreateWithoutTenantInput, ContactUncheckedCreateWithoutTenantInput>
  }

  export type ContactUpdateWithWhereUniqueWithoutTenantInput = {
    where: ContactWhereUniqueInput
    data: XOR<ContactUpdateWithoutTenantInput, ContactUncheckedUpdateWithoutTenantInput>
  }

  export type ContactUpdateManyWithWhereWithoutTenantInput = {
    where: ContactScalarWhereInput
    data: XOR<ContactUpdateManyMutationInput, ContactUncheckedUpdateManyWithoutTenantInput>
  }

  export type ContactScalarWhereInput = {
    AND?: ContactScalarWhereInput | ContactScalarWhereInput[]
    OR?: ContactScalarWhereInput[]
    NOT?: ContactScalarWhereInput | ContactScalarWhereInput[]
    id?: StringFilter<"Contact"> | string
    tenantId?: StringFilter<"Contact"> | string
    firstName?: StringFilter<"Contact"> | string
    lastName?: StringFilter<"Contact"> | string
    email?: StringNullableFilter<"Contact"> | string | null
    phone?: StringNullableFilter<"Contact"> | string | null
    company?: StringNullableFilter<"Contact"> | string | null
    jobTitle?: StringNullableFilter<"Contact"> | string | null
    source?: StringNullableFilter<"Contact"> | string | null
    notes?: StringNullableFilter<"Contact"> | string | null
    customFields?: JsonNullableFilter<"Contact">
    createdAt?: DateTimeFilter<"Contact"> | Date | string
    updatedAt?: DateTimeFilter<"Contact"> | Date | string
  }

  export type LeadUpsertWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
    create: XOR<LeadCreateWithoutTenantInput, LeadUncheckedCreateWithoutTenantInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutTenantInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutTenantInput, LeadUncheckedUpdateWithoutTenantInput>
  }

  export type LeadUpdateManyWithWhereWithoutTenantInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutTenantInput>
  }

  export type LeadScalarWhereInput = {
    AND?: LeadScalarWhereInput | LeadScalarWhereInput[]
    OR?: LeadScalarWhereInput[]
    NOT?: LeadScalarWhereInput | LeadScalarWhereInput[]
    id?: StringFilter<"Lead"> | string
    tenantId?: StringFilter<"Lead"> | string
    contactId?: StringNullableFilter<"Lead"> | string | null
    title?: StringFilter<"Lead"> | string
    source?: StringFilter<"Lead"> | string
    status?: EnumLeadStatusFilter<"Lead"> | $Enums.LeadStatus
    value?: DecimalNullableFilter<"Lead"> | Decimal | DecimalJsLike | number | string | null
    notes?: StringNullableFilter<"Lead"> | string | null
    convertedAt?: DateTimeNullableFilter<"Lead"> | Date | string | null
    createdAt?: DateTimeFilter<"Lead"> | Date | string
    updatedAt?: DateTimeFilter<"Lead"> | Date | string
  }

  export type PipelineUpsertWithWhereUniqueWithoutTenantInput = {
    where: PipelineWhereUniqueInput
    update: XOR<PipelineUpdateWithoutTenantInput, PipelineUncheckedUpdateWithoutTenantInput>
    create: XOR<PipelineCreateWithoutTenantInput, PipelineUncheckedCreateWithoutTenantInput>
  }

  export type PipelineUpdateWithWhereUniqueWithoutTenantInput = {
    where: PipelineWhereUniqueInput
    data: XOR<PipelineUpdateWithoutTenantInput, PipelineUncheckedUpdateWithoutTenantInput>
  }

  export type PipelineUpdateManyWithWhereWithoutTenantInput = {
    where: PipelineScalarWhereInput
    data: XOR<PipelineUpdateManyMutationInput, PipelineUncheckedUpdateManyWithoutTenantInput>
  }

  export type PipelineScalarWhereInput = {
    AND?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    OR?: PipelineScalarWhereInput[]
    NOT?: PipelineScalarWhereInput | PipelineScalarWhereInput[]
    id?: StringFilter<"Pipeline"> | string
    tenantId?: StringFilter<"Pipeline"> | string
    name?: StringFilter<"Pipeline"> | string
    description?: StringNullableFilter<"Pipeline"> | string | null
    isActive?: BoolFilter<"Pipeline"> | boolean
    createdAt?: DateTimeFilter<"Pipeline"> | Date | string
    updatedAt?: DateTimeFilter<"Pipeline"> | Date | string
  }

  export type DealUpsertWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
    create: XOR<DealCreateWithoutTenantInput, DealUncheckedCreateWithoutTenantInput>
  }

  export type DealUpdateWithWhereUniqueWithoutTenantInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutTenantInput, DealUncheckedUpdateWithoutTenantInput>
  }

  export type DealUpdateManyWithWhereWithoutTenantInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutTenantInput>
  }

  export type DealScalarWhereInput = {
    AND?: DealScalarWhereInput | DealScalarWhereInput[]
    OR?: DealScalarWhereInput[]
    NOT?: DealScalarWhereInput | DealScalarWhereInput[]
    id?: StringFilter<"Deal"> | string
    tenantId?: StringFilter<"Deal"> | string
    contactId?: StringFilter<"Deal"> | string
    leadId?: StringNullableFilter<"Deal"> | string | null
    pipelineId?: StringFilter<"Deal"> | string
    stageId?: StringFilter<"Deal"> | string
    title?: StringFilter<"Deal"> | string
    description?: StringNullableFilter<"Deal"> | string | null
    value?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    probability?: DecimalNullableFilter<"Deal"> | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: DateTimeNullableFilter<"Deal"> | Date | string | null
    notes?: StringNullableFilter<"Deal"> | string | null
    createdAt?: DateTimeFilter<"Deal"> | Date | string
    updatedAt?: DateTimeFilter<"Deal"> | Date | string
  }

  export type InteractionUpsertWithWhereUniqueWithoutTenantInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutTenantInput, InteractionUncheckedUpdateWithoutTenantInput>
    create: XOR<InteractionCreateWithoutTenantInput, InteractionUncheckedCreateWithoutTenantInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutTenantInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutTenantInput, InteractionUncheckedUpdateWithoutTenantInput>
  }

  export type InteractionUpdateManyWithWhereWithoutTenantInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutTenantInput>
  }

  export type InteractionScalarWhereInput = {
    AND?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    OR?: InteractionScalarWhereInput[]
    NOT?: InteractionScalarWhereInput | InteractionScalarWhereInput[]
    id?: StringFilter<"Interaction"> | string
    tenantId?: StringFilter<"Interaction"> | string
    contactId?: StringFilter<"Interaction"> | string
    dealId?: StringNullableFilter<"Interaction"> | string | null
    userId?: StringNullableFilter<"Interaction"> | string | null
    type?: EnumInteractionTypeFilter<"Interaction"> | $Enums.InteractionType
    subject?: StringNullableFilter<"Interaction"> | string | null
    content?: StringFilter<"Interaction"> | string
    dateTime?: DateTimeFilter<"Interaction"> | Date | string
    createdAt?: DateTimeFilter<"Interaction"> | Date | string
    updatedAt?: DateTimeFilter<"Interaction"> | Date | string
  }

  export type TicketUpsertWithWhereUniqueWithoutTenantInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutTenantInput, TicketUncheckedUpdateWithoutTenantInput>
    create: XOR<TicketCreateWithoutTenantInput, TicketUncheckedCreateWithoutTenantInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutTenantInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutTenantInput, TicketUncheckedUpdateWithoutTenantInput>
  }

  export type TicketUpdateManyWithWhereWithoutTenantInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutTenantInput>
  }

  export type TicketScalarWhereInput = {
    AND?: TicketScalarWhereInput | TicketScalarWhereInput[]
    OR?: TicketScalarWhereInput[]
    NOT?: TicketScalarWhereInput | TicketScalarWhereInput[]
    id?: StringFilter<"Ticket"> | string
    tenantId?: StringFilter<"Ticket"> | string
    contactId?: StringFilter<"Ticket"> | string
    portalCustomerId?: StringNullableFilter<"Ticket"> | string | null
    dealId?: StringNullableFilter<"Ticket"> | string | null
    externalId?: StringNullableFilter<"Ticket"> | string | null
    externalSystem?: StringNullableFilter<"Ticket"> | string | null
    title?: StringFilter<"Ticket"> | string
    description?: StringNullableFilter<"Ticket"> | string | null
    status?: EnumTicketStatusFilter<"Ticket"> | $Enums.TicketStatus
    priority?: EnumTicketPriorityFilter<"Ticket"> | $Enums.TicketPriority
    source?: EnumTicketSourceFilter<"Ticket"> | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFilter<"Ticket"> | boolean
    createdAt?: DateTimeFilter<"Ticket"> | Date | string
    updatedAt?: DateTimeFilter<"Ticket"> | Date | string
    assignedUserId?: StringNullableFilter<"Ticket"> | string | null
  }

  export type IntegrationUpsertWithWhereUniqueWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    update: XOR<IntegrationUpdateWithoutTenantInput, IntegrationUncheckedUpdateWithoutTenantInput>
    create: XOR<IntegrationCreateWithoutTenantInput, IntegrationUncheckedCreateWithoutTenantInput>
  }

  export type IntegrationUpdateWithWhereUniqueWithoutTenantInput = {
    where: IntegrationWhereUniqueInput
    data: XOR<IntegrationUpdateWithoutTenantInput, IntegrationUncheckedUpdateWithoutTenantInput>
  }

  export type IntegrationUpdateManyWithWhereWithoutTenantInput = {
    where: IntegrationScalarWhereInput
    data: XOR<IntegrationUpdateManyMutationInput, IntegrationUncheckedUpdateManyWithoutTenantInput>
  }

  export type IntegrationScalarWhereInput = {
    AND?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    OR?: IntegrationScalarWhereInput[]
    NOT?: IntegrationScalarWhereInput | IntegrationScalarWhereInput[]
    id?: StringFilter<"Integration"> | string
    tenantId?: StringFilter<"Integration"> | string
    serviceName?: StringFilter<"Integration"> | string
    isActive?: BoolFilter<"Integration"> | boolean
    config?: JsonNullableFilter<"Integration">
    lastSyncAt?: DateTimeNullableFilter<"Integration"> | Date | string | null
    syncStatus?: StringNullableFilter<"Integration"> | string | null
    errorMessage?: StringNullableFilter<"Integration"> | string | null
    createdAt?: DateTimeFilter<"Integration"> | Date | string
    updatedAt?: DateTimeFilter<"Integration"> | Date | string
  }

  export type CallLogUpsertWithWhereUniqueWithoutTenantInput = {
    where: CallLogWhereUniqueInput
    update: XOR<CallLogUpdateWithoutTenantInput, CallLogUncheckedUpdateWithoutTenantInput>
    create: XOR<CallLogCreateWithoutTenantInput, CallLogUncheckedCreateWithoutTenantInput>
  }

  export type CallLogUpdateWithWhereUniqueWithoutTenantInput = {
    where: CallLogWhereUniqueInput
    data: XOR<CallLogUpdateWithoutTenantInput, CallLogUncheckedUpdateWithoutTenantInput>
  }

  export type CallLogUpdateManyWithWhereWithoutTenantInput = {
    where: CallLogScalarWhereInput
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyWithoutTenantInput>
  }

  export type CallLogScalarWhereInput = {
    AND?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
    OR?: CallLogScalarWhereInput[]
    NOT?: CallLogScalarWhereInput | CallLogScalarWhereInput[]
    id?: StringFilter<"CallLog"> | string
    tenantId?: StringFilter<"CallLog"> | string
    roomName?: StringFilter<"CallLog"> | string
    callerSupabaseId?: StringFilter<"CallLog"> | string
    calleeSupabaseId?: StringFilter<"CallLog"> | string
    direction?: EnumCallDirectionFilter<"CallLog"> | $Enums.CallDirection
    status?: StringFilter<"CallLog"> | string
    duration?: IntNullableFilter<"CallLog"> | number | null
    startTime?: DateTimeFilter<"CallLog"> | Date | string
    endTime?: DateTimeNullableFilter<"CallLog"> | Date | string | null
    createdAt?: DateTimeFilter<"CallLog"> | Date | string
    updatedAt?: DateTimeFilter<"CallLog"> | Date | string
    contactId?: StringNullableFilter<"CallLog"> | string | null
    dealId?: StringNullableFilter<"CallLog"> | string | null
  }

  export type PortalCustomerUpsertWithWhereUniqueWithoutTenantInput = {
    where: PortalCustomerWhereUniqueInput
    update: XOR<PortalCustomerUpdateWithoutTenantInput, PortalCustomerUncheckedUpdateWithoutTenantInput>
    create: XOR<PortalCustomerCreateWithoutTenantInput, PortalCustomerUncheckedCreateWithoutTenantInput>
  }

  export type PortalCustomerUpdateWithWhereUniqueWithoutTenantInput = {
    where: PortalCustomerWhereUniqueInput
    data: XOR<PortalCustomerUpdateWithoutTenantInput, PortalCustomerUncheckedUpdateWithoutTenantInput>
  }

  export type PortalCustomerUpdateManyWithWhereWithoutTenantInput = {
    where: PortalCustomerScalarWhereInput
    data: XOR<PortalCustomerUpdateManyMutationInput, PortalCustomerUncheckedUpdateManyWithoutTenantInput>
  }

  export type PortalCustomerScalarWhereInput = {
    AND?: PortalCustomerScalarWhereInput | PortalCustomerScalarWhereInput[]
    OR?: PortalCustomerScalarWhereInput[]
    NOT?: PortalCustomerScalarWhereInput | PortalCustomerScalarWhereInput[]
    id?: StringFilter<"PortalCustomer"> | string
    tenantId?: StringFilter<"PortalCustomer"> | string
    contactId?: StringNullableFilter<"PortalCustomer"> | string | null
    supabaseUserId?: StringNullableFilter<"PortalCustomer"> | string | null
    email?: StringFilter<"PortalCustomer"> | string
    name?: StringNullableFilter<"PortalCustomer"> | string | null
    avatarUrl?: StringNullableFilter<"PortalCustomer"> | string | null
    accessToken?: StringNullableFilter<"PortalCustomer"> | string | null
    fcmToken?: StringNullableFilter<"PortalCustomer"> | string | null
    pushSubscription?: JsonNullableFilter<"PortalCustomer">
    isActive?: BoolFilter<"PortalCustomer"> | boolean
    createdAt?: DateTimeFilter<"PortalCustomer"> | Date | string
    updatedAt?: DateTimeFilter<"PortalCustomer"> | Date | string
  }

  export type UserInvitationUpsertWithWhereUniqueWithoutTenantInput = {
    where: UserInvitationWhereUniqueInput
    update: XOR<UserInvitationUpdateWithoutTenantInput, UserInvitationUncheckedUpdateWithoutTenantInput>
    create: XOR<UserInvitationCreateWithoutTenantInput, UserInvitationUncheckedCreateWithoutTenantInput>
  }

  export type UserInvitationUpdateWithWhereUniqueWithoutTenantInput = {
    where: UserInvitationWhereUniqueInput
    data: XOR<UserInvitationUpdateWithoutTenantInput, UserInvitationUncheckedUpdateWithoutTenantInput>
  }

  export type UserInvitationUpdateManyWithWhereWithoutTenantInput = {
    where: UserInvitationScalarWhereInput
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyWithoutTenantInput>
  }

  export type UserInvitationScalarWhereInput = {
    AND?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    OR?: UserInvitationScalarWhereInput[]
    NOT?: UserInvitationScalarWhereInput | UserInvitationScalarWhereInput[]
    id?: StringFilter<"UserInvitation"> | string
    tenantId?: StringFilter<"UserInvitation"> | string
    email?: StringFilter<"UserInvitation"> | string
    role?: EnumUserRoleFilter<"UserInvitation"> | $Enums.UserRole
    invitedBy?: StringFilter<"UserInvitation"> | string
    token?: StringFilter<"UserInvitation"> | string
    expiresAt?: DateTimeFilter<"UserInvitation"> | Date | string
    acceptedAt?: DateTimeNullableFilter<"UserInvitation"> | Date | string | null
    createdAt?: DateTimeFilter<"UserInvitation"> | Date | string
    updatedAt?: DateTimeFilter<"UserInvitation"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutTenantInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutTenantInput, ConversationUncheckedUpdateWithoutTenantInput>
    create: XOR<ConversationCreateWithoutTenantInput, ConversationUncheckedCreateWithoutTenantInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutTenantInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutTenantInput, ConversationUncheckedUpdateWithoutTenantInput>
  }

  export type ConversationUpdateManyWithWhereWithoutTenantInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutTenantInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    userId?: StringFilter<"Conversation"> | string
    tenantId?: StringFilter<"Conversation"> | string
    title?: StringNullableFilter<"Conversation"> | string | null
    createdAt?: DateTimeFilter<"Conversation"> | Date | string
    updatedAt?: DateTimeFilter<"Conversation"> | Date | string
  }

  export type CallEventUpsertWithWhereUniqueWithoutTenantInput = {
    where: CallEventWhereUniqueInput
    update: XOR<CallEventUpdateWithoutTenantInput, CallEventUncheckedUpdateWithoutTenantInput>
    create: XOR<CallEventCreateWithoutTenantInput, CallEventUncheckedCreateWithoutTenantInput>
  }

  export type CallEventUpdateWithWhereUniqueWithoutTenantInput = {
    where: CallEventWhereUniqueInput
    data: XOR<CallEventUpdateWithoutTenantInput, CallEventUncheckedUpdateWithoutTenantInput>
  }

  export type CallEventUpdateManyWithWhereWithoutTenantInput = {
    where: CallEventScalarWhereInput
    data: XOR<CallEventUpdateManyMutationInput, CallEventUncheckedUpdateManyWithoutTenantInput>
  }

  export type CallEventScalarWhereInput = {
    AND?: CallEventScalarWhereInput | CallEventScalarWhereInput[]
    OR?: CallEventScalarWhereInput[]
    NOT?: CallEventScalarWhereInput | CallEventScalarWhereInput[]
    id?: StringFilter<"CallEvent"> | string
    tenantId?: StringFilter<"CallEvent"> | string
    callerId?: StringNullableFilter<"CallEvent"> | string | null
    calleeId?: StringNullableFilter<"CallEvent"> | string | null
    roomName?: StringFilter<"CallEvent"> | string
    eventType?: EnumCallEventTypeFilter<"CallEvent"> | $Enums.CallEventType
    payload?: JsonFilter<"CallEvent">
    createdAt?: DateTimeFilter<"CallEvent"> | Date | string
  }

  export type CallRecordingUpsertWithWhereUniqueWithoutTenantInput = {
    where: CallRecordingWhereUniqueInput
    update: XOR<CallRecordingUpdateWithoutTenantInput, CallRecordingUncheckedUpdateWithoutTenantInput>
    create: XOR<CallRecordingCreateWithoutTenantInput, CallRecordingUncheckedCreateWithoutTenantInput>
  }

  export type CallRecordingUpdateWithWhereUniqueWithoutTenantInput = {
    where: CallRecordingWhereUniqueInput
    data: XOR<CallRecordingUpdateWithoutTenantInput, CallRecordingUncheckedUpdateWithoutTenantInput>
  }

  export type CallRecordingUpdateManyWithWhereWithoutTenantInput = {
    where: CallRecordingScalarWhereInput
    data: XOR<CallRecordingUpdateManyMutationInput, CallRecordingUncheckedUpdateManyWithoutTenantInput>
  }

  export type CallRecordingScalarWhereInput = {
    AND?: CallRecordingScalarWhereInput | CallRecordingScalarWhereInput[]
    OR?: CallRecordingScalarWhereInput[]
    NOT?: CallRecordingScalarWhereInput | CallRecordingScalarWhereInput[]
    id?: StringFilter<"CallRecording"> | string
    callLogId?: StringFilter<"CallRecording"> | string
    tenantId?: StringFilter<"CallRecording"> | string
    fileUrl?: StringFilter<"CallRecording"> | string
    fileName?: StringFilter<"CallRecording"> | string
    fileSize?: IntNullableFilter<"CallRecording"> | number | null
    format?: StringFilter<"CallRecording"> | string
    duration?: IntNullableFilter<"CallRecording"> | number | null
    provider?: EnumRecordingProviderFilter<"CallRecording"> | $Enums.RecordingProvider
    providerId?: StringNullableFilter<"CallRecording"> | string | null
    status?: EnumRecordingStatusFilter<"CallRecording"> | $Enums.RecordingStatus
    recordingStartTime?: DateTimeNullableFilter<"CallRecording"> | Date | string | null
    recordingEndTime?: DateTimeNullableFilter<"CallRecording"> | Date | string | null
    createdAt?: DateTimeFilter<"CallRecording"> | Date | string
    updatedAt?: DateTimeFilter<"CallRecording"> | Date | string
  }

  export type CallTranscriptionUpsertWithWhereUniqueWithoutTenantInput = {
    where: CallTranscriptionWhereUniqueInput
    update: XOR<CallTranscriptionUpdateWithoutTenantInput, CallTranscriptionUncheckedUpdateWithoutTenantInput>
    create: XOR<CallTranscriptionCreateWithoutTenantInput, CallTranscriptionUncheckedCreateWithoutTenantInput>
  }

  export type CallTranscriptionUpdateWithWhereUniqueWithoutTenantInput = {
    where: CallTranscriptionWhereUniqueInput
    data: XOR<CallTranscriptionUpdateWithoutTenantInput, CallTranscriptionUncheckedUpdateWithoutTenantInput>
  }

  export type CallTranscriptionUpdateManyWithWhereWithoutTenantInput = {
    where: CallTranscriptionScalarWhereInput
    data: XOR<CallTranscriptionUpdateManyMutationInput, CallTranscriptionUncheckedUpdateManyWithoutTenantInput>
  }

  export type CallTranscriptionScalarWhereInput = {
    AND?: CallTranscriptionScalarWhereInput | CallTranscriptionScalarWhereInput[]
    OR?: CallTranscriptionScalarWhereInput[]
    NOT?: CallTranscriptionScalarWhereInput | CallTranscriptionScalarWhereInput[]
    id?: StringFilter<"CallTranscription"> | string
    callLogId?: StringFilter<"CallTranscription"> | string
    tenantId?: StringFilter<"CallTranscription"> | string
    fullText?: StringFilter<"CallTranscription"> | string
    segments?: JsonFilter<"CallTranscription">
    language?: StringFilter<"CallTranscription"> | string
    confidence?: FloatNullableFilter<"CallTranscription"> | number | null
    wordCount?: IntNullableFilter<"CallTranscription"> | number | null
    summary?: StringNullableFilter<"CallTranscription"> | string | null
    keywords?: StringNullableListFilter<"CallTranscription">
    sentiment?: StringNullableFilter<"CallTranscription"> | string | null
    provider?: EnumTranscriptionProviderFilter<"CallTranscription"> | $Enums.TranscriptionProvider
    providerId?: StringNullableFilter<"CallTranscription"> | string | null
    status?: EnumTranscriptionStatusFilter<"CallTranscription"> | $Enums.TranscriptionStatus
    createdAt?: DateTimeFilter<"CallTranscription"> | Date | string
    updatedAt?: DateTimeFilter<"CallTranscription"> | Date | string
  }

  export type TenantCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUsersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
  }

  export type InteractionCreateWithoutUserInput = {
    id?: string
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInteractionsInput
    contact: ContactCreateNestedOneWithoutInteractionsInput
    deal?: DealCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    contactId: string
    dealId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateOrConnectWithoutUserInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutUserInput, InteractionUncheckedCreateWithoutUserInput>
  }

  export type InteractionCreateManyUserInputEnvelope = {
    data: InteractionCreateManyUserInput | InteractionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutAssignedUserInput = {
    id?: string
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketsInput
    deal?: DealCreateNestedOneWithoutTicketsInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutAssignedUserInput = {
    id?: string
    tenantId: string
    contactId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutAssignedUserInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutAssignedUserInput, TicketUncheckedCreateWithoutAssignedUserInput>
  }

  export type TicketCreateManyAssignedUserInputEnvelope = {
    data: TicketCreateManyAssignedUserInput | TicketCreateManyAssignedUserInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutUserInput = {
    id?: string
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutUserInput = {
    id?: string
    ticketId: string
    portalCustomerId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentCreateManyUserInputEnvelope = {
    data: TicketCommentCreateManyUserInput | TicketCommentCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserInvitationCreateWithoutInvitedByUserInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUserInvitationsInput
  }

  export type UserInvitationUncheckedCreateWithoutInvitedByUserInput = {
    id?: string
    tenantId: string
    email: string
    role?: $Enums.UserRole
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationCreateOrConnectWithoutInvitedByUserInput = {
    where: UserInvitationWhereUniqueInput
    create: XOR<UserInvitationCreateWithoutInvitedByUserInput, UserInvitationUncheckedCreateWithoutInvitedByUserInput>
  }

  export type UserInvitationCreateManyInvitedByUserInputEnvelope = {
    data: UserInvitationCreateManyInvitedByUserInput | UserInvitationCreateManyInvitedByUserInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutUserInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageCreateNestedManyWithoutConversationInput
    tenant: TenantCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutUserInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationCreateManyUserInputEnvelope = {
    data: ConversationCreateManyUserInput | ConversationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TelegramUserCreateWithoutUserInput = {
    id?: string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserUncheckedCreateWithoutUserInput = {
    id?: string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserCreateOrConnectWithoutUserInput = {
    where: TelegramUserWhereUniqueInput
    create: XOR<TelegramUserCreateWithoutUserInput, TelegramUserUncheckedCreateWithoutUserInput>
  }

  export type TelegramUserCreateManyUserInputEnvelope = {
    data: TelegramUserCreateManyUserInput | TelegramUserCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TelegramLinkRequestCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TelegramLinkRequestUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type TelegramLinkRequestCreateOrConnectWithoutUserInput = {
    where: TelegramLinkRequestWhereUniqueInput
    create: XOR<TelegramLinkRequestCreateWithoutUserInput, TelegramLinkRequestUncheckedCreateWithoutUserInput>
  }

  export type TelegramLinkRequestCreateManyUserInputEnvelope = {
    data: TelegramLinkRequestCreateManyUserInput | TelegramLinkRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutUsersInput = {
    update: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
    create: XOR<TenantCreateWithoutUsersInput, TenantUncheckedCreateWithoutUsersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUsersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUsersInput, TenantUncheckedUpdateWithoutUsersInput>
  }

  export type TenantUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type InteractionUpsertWithWhereUniqueWithoutUserInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutUserInput, InteractionUncheckedUpdateWithoutUserInput>
    create: XOR<InteractionCreateWithoutUserInput, InteractionUncheckedCreateWithoutUserInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutUserInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutUserInput, InteractionUncheckedUpdateWithoutUserInput>
  }

  export type InteractionUpdateManyWithWhereWithoutUserInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutAssignedUserInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutAssignedUserInput, TicketUncheckedUpdateWithoutAssignedUserInput>
    create: XOR<TicketCreateWithoutAssignedUserInput, TicketUncheckedCreateWithoutAssignedUserInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutAssignedUserInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutAssignedUserInput, TicketUncheckedUpdateWithoutAssignedUserInput>
  }

  export type TicketUpdateManyWithWhereWithoutAssignedUserInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutAssignedUserInput>
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
    create: XOR<TicketCommentCreateWithoutUserInput, TicketCommentUncheckedCreateWithoutUserInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutUserInput, TicketCommentUncheckedUpdateWithoutUserInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutUserInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type TicketCommentScalarWhereInput = {
    AND?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    OR?: TicketCommentScalarWhereInput[]
    NOT?: TicketCommentScalarWhereInput | TicketCommentScalarWhereInput[]
    id?: StringFilter<"TicketComment"> | string
    ticketId?: StringFilter<"TicketComment"> | string
    userId?: StringNullableFilter<"TicketComment"> | string | null
    portalCustomerId?: StringNullableFilter<"TicketComment"> | string | null
    content?: StringFilter<"TicketComment"> | string
    authorName?: StringNullableFilter<"TicketComment"> | string | null
    isInternal?: BoolFilter<"TicketComment"> | boolean
    createdAt?: DateTimeFilter<"TicketComment"> | Date | string
    updatedAt?: DateTimeFilter<"TicketComment"> | Date | string
  }

  export type UserInvitationUpsertWithWhereUniqueWithoutInvitedByUserInput = {
    where: UserInvitationWhereUniqueInput
    update: XOR<UserInvitationUpdateWithoutInvitedByUserInput, UserInvitationUncheckedUpdateWithoutInvitedByUserInput>
    create: XOR<UserInvitationCreateWithoutInvitedByUserInput, UserInvitationUncheckedCreateWithoutInvitedByUserInput>
  }

  export type UserInvitationUpdateWithWhereUniqueWithoutInvitedByUserInput = {
    where: UserInvitationWhereUniqueInput
    data: XOR<UserInvitationUpdateWithoutInvitedByUserInput, UserInvitationUncheckedUpdateWithoutInvitedByUserInput>
  }

  export type UserInvitationUpdateManyWithWhereWithoutInvitedByUserInput = {
    where: UserInvitationScalarWhereInput
    data: XOR<UserInvitationUpdateManyMutationInput, UserInvitationUncheckedUpdateManyWithoutInvitedByUserInput>
  }

  export type ConversationUpsertWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
    create: XOR<ConversationCreateWithoutUserInput, ConversationUncheckedCreateWithoutUserInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutUserInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutUserInput, ConversationUncheckedUpdateWithoutUserInput>
  }

  export type ConversationUpdateManyWithWhereWithoutUserInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutUserInput>
  }

  export type TelegramUserUpsertWithWhereUniqueWithoutUserInput = {
    where: TelegramUserWhereUniqueInput
    update: XOR<TelegramUserUpdateWithoutUserInput, TelegramUserUncheckedUpdateWithoutUserInput>
    create: XOR<TelegramUserCreateWithoutUserInput, TelegramUserUncheckedCreateWithoutUserInput>
  }

  export type TelegramUserUpdateWithWhereUniqueWithoutUserInput = {
    where: TelegramUserWhereUniqueInput
    data: XOR<TelegramUserUpdateWithoutUserInput, TelegramUserUncheckedUpdateWithoutUserInput>
  }

  export type TelegramUserUpdateManyWithWhereWithoutUserInput = {
    where: TelegramUserScalarWhereInput
    data: XOR<TelegramUserUpdateManyMutationInput, TelegramUserUncheckedUpdateManyWithoutUserInput>
  }

  export type TelegramUserScalarWhereInput = {
    AND?: TelegramUserScalarWhereInput | TelegramUserScalarWhereInput[]
    OR?: TelegramUserScalarWhereInput[]
    NOT?: TelegramUserScalarWhereInput | TelegramUserScalarWhereInput[]
    id?: StringFilter<"TelegramUser"> | string
    telegramId?: StringFilter<"TelegramUser"> | string
    userId?: StringFilter<"TelegramUser"> | string
    username?: StringNullableFilter<"TelegramUser"> | string | null
    firstName?: StringNullableFilter<"TelegramUser"> | string | null
    lastName?: StringNullableFilter<"TelegramUser"> | string | null
    avatarUrl?: StringNullableFilter<"TelegramUser"> | string | null
    isActive?: BoolFilter<"TelegramUser"> | boolean
    createdAt?: DateTimeFilter<"TelegramUser"> | Date | string
    updatedAt?: DateTimeFilter<"TelegramUser"> | Date | string
  }

  export type TelegramLinkRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: TelegramLinkRequestWhereUniqueInput
    update: XOR<TelegramLinkRequestUpdateWithoutUserInput, TelegramLinkRequestUncheckedUpdateWithoutUserInput>
    create: XOR<TelegramLinkRequestCreateWithoutUserInput, TelegramLinkRequestUncheckedCreateWithoutUserInput>
  }

  export type TelegramLinkRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: TelegramLinkRequestWhereUniqueInput
    data: XOR<TelegramLinkRequestUpdateWithoutUserInput, TelegramLinkRequestUncheckedUpdateWithoutUserInput>
  }

  export type TelegramLinkRequestUpdateManyWithWhereWithoutUserInput = {
    where: TelegramLinkRequestScalarWhereInput
    data: XOR<TelegramLinkRequestUpdateManyMutationInput, TelegramLinkRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type TelegramLinkRequestScalarWhereInput = {
    AND?: TelegramLinkRequestScalarWhereInput | TelegramLinkRequestScalarWhereInput[]
    OR?: TelegramLinkRequestScalarWhereInput[]
    NOT?: TelegramLinkRequestScalarWhereInput | TelegramLinkRequestScalarWhereInput[]
    id?: StringFilter<"TelegramLinkRequest"> | string
    code?: StringFilter<"TelegramLinkRequest"> | string
    userId?: StringFilter<"TelegramLinkRequest"> | string
    expiresAt?: DateTimeFilter<"TelegramLinkRequest"> | Date | string
    usedAt?: DateTimeNullableFilter<"TelegramLinkRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"TelegramLinkRequest"> | Date | string
  }

  export type TenantCreateWithoutContactsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutContactsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutContactsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
  }

  export type LeadCreateWithoutContactInput = {
    id?: string
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
    deals?: DealCreateNestedManyWithoutLeadInput
  }

  export type LeadUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutLeadInput
  }

  export type LeadCreateOrConnectWithoutContactInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput>
  }

  export type LeadCreateManyContactInputEnvelope = {
    data: LeadCreateManyContactInput | LeadCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type InteractionCreateWithoutContactInput = {
    id?: string
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInteractionsInput
    deal?: DealCreateNestedOneWithoutInteractionsInput
    user?: UserCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    dealId?: string | null
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateOrConnectWithoutContactInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutContactInput, InteractionUncheckedCreateWithoutContactInput>
  }

  export type InteractionCreateManyContactInputEnvelope = {
    data: InteractionCreateManyContactInput | InteractionCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutContactInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    tickets?: TicketCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutContactInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput>
  }

  export type DealCreateManyContactInputEnvelope = {
    data: DealCreateManyContactInput | DealCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutContactInput = {
    id?: string
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTicketsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketsInput
    deal?: DealCreateNestedOneWithoutTicketsInput
    assignedUser?: UserCreateNestedOneWithoutTicketsAssignedInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutContactInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput>
  }

  export type TicketCreateManyContactInputEnvelope = {
    data: TicketCreateManyContactInput | TicketCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type CallLogCreateWithoutContactInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallLogsInput
    deal?: DealCreateNestedOneWithoutCallLogsInput
    recording?: CallRecordingCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionCreateNestedOneWithoutCallLogInput
  }

  export type CallLogUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealId?: string | null
    recording?: CallRecordingUncheckedCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionUncheckedCreateNestedOneWithoutCallLogInput
  }

  export type CallLogCreateOrConnectWithoutContactInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutContactInput, CallLogUncheckedCreateWithoutContactInput>
  }

  export type CallLogCreateManyContactInputEnvelope = {
    data: CallLogCreateManyContactInput | CallLogCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type PortalCustomerCreateWithoutContactInput = {
    id?: string
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPortalCustomersInput
    tickets?: TicketCreateNestedManyWithoutPortalCustomerInput
    ticketComments?: TicketCommentCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerUncheckedCreateWithoutContactInput = {
    id?: string
    tenantId: string
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutPortalCustomerInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerCreateOrConnectWithoutContactInput = {
    where: PortalCustomerWhereUniqueInput
    create: XOR<PortalCustomerCreateWithoutContactInput, PortalCustomerUncheckedCreateWithoutContactInput>
  }

  export type PortalCustomerCreateManyContactInputEnvelope = {
    data: PortalCustomerCreateManyContactInput | PortalCustomerCreateManyContactInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutContactsInput = {
    update: XOR<TenantUpdateWithoutContactsInput, TenantUncheckedUpdateWithoutContactsInput>
    create: XOR<TenantCreateWithoutContactsInput, TenantUncheckedCreateWithoutContactsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutContactsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutContactsInput, TenantUncheckedUpdateWithoutContactsInput>
  }

  export type TenantUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutContactsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type LeadUpsertWithWhereUniqueWithoutContactInput = {
    where: LeadWhereUniqueInput
    update: XOR<LeadUpdateWithoutContactInput, LeadUncheckedUpdateWithoutContactInput>
    create: XOR<LeadCreateWithoutContactInput, LeadUncheckedCreateWithoutContactInput>
  }

  export type LeadUpdateWithWhereUniqueWithoutContactInput = {
    where: LeadWhereUniqueInput
    data: XOR<LeadUpdateWithoutContactInput, LeadUncheckedUpdateWithoutContactInput>
  }

  export type LeadUpdateManyWithWhereWithoutContactInput = {
    where: LeadScalarWhereInput
    data: XOR<LeadUpdateManyMutationInput, LeadUncheckedUpdateManyWithoutContactInput>
  }

  export type InteractionUpsertWithWhereUniqueWithoutContactInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutContactInput, InteractionUncheckedUpdateWithoutContactInput>
    create: XOR<InteractionCreateWithoutContactInput, InteractionUncheckedCreateWithoutContactInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutContactInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutContactInput, InteractionUncheckedUpdateWithoutContactInput>
  }

  export type InteractionUpdateManyWithWhereWithoutContactInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutContactInput>
  }

  export type DealUpsertWithWhereUniqueWithoutContactInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutContactInput, DealUncheckedUpdateWithoutContactInput>
    create: XOR<DealCreateWithoutContactInput, DealUncheckedCreateWithoutContactInput>
  }

  export type DealUpdateWithWhereUniqueWithoutContactInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutContactInput, DealUncheckedUpdateWithoutContactInput>
  }

  export type DealUpdateManyWithWhereWithoutContactInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutContactInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutContactInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutContactInput, TicketUncheckedUpdateWithoutContactInput>
    create: XOR<TicketCreateWithoutContactInput, TicketUncheckedCreateWithoutContactInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutContactInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutContactInput, TicketUncheckedUpdateWithoutContactInput>
  }

  export type TicketUpdateManyWithWhereWithoutContactInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutContactInput>
  }

  export type CallLogUpsertWithWhereUniqueWithoutContactInput = {
    where: CallLogWhereUniqueInput
    update: XOR<CallLogUpdateWithoutContactInput, CallLogUncheckedUpdateWithoutContactInput>
    create: XOR<CallLogCreateWithoutContactInput, CallLogUncheckedCreateWithoutContactInput>
  }

  export type CallLogUpdateWithWhereUniqueWithoutContactInput = {
    where: CallLogWhereUniqueInput
    data: XOR<CallLogUpdateWithoutContactInput, CallLogUncheckedUpdateWithoutContactInput>
  }

  export type CallLogUpdateManyWithWhereWithoutContactInput = {
    where: CallLogScalarWhereInput
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyWithoutContactInput>
  }

  export type PortalCustomerUpsertWithWhereUniqueWithoutContactInput = {
    where: PortalCustomerWhereUniqueInput
    update: XOR<PortalCustomerUpdateWithoutContactInput, PortalCustomerUncheckedUpdateWithoutContactInput>
    create: XOR<PortalCustomerCreateWithoutContactInput, PortalCustomerUncheckedCreateWithoutContactInput>
  }

  export type PortalCustomerUpdateWithWhereUniqueWithoutContactInput = {
    where: PortalCustomerWhereUniqueInput
    data: XOR<PortalCustomerUpdateWithoutContactInput, PortalCustomerUncheckedUpdateWithoutContactInput>
  }

  export type PortalCustomerUpdateManyWithWhereWithoutContactInput = {
    where: PortalCustomerScalarWhereInput
    data: XOR<PortalCustomerUpdateManyMutationInput, PortalCustomerUncheckedUpdateManyWithoutContactInput>
  }

  export type TenantCreateWithoutLeadsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutLeadsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutLeadsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
  }

  export type ContactCreateWithoutLeadsInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    interactions?: InteractionCreateNestedManyWithoutContactInput
    deals?: DealCreateNestedManyWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    callLogs?: CallLogCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutLeadsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutContactInput
    deals?: DealUncheckedCreateNestedManyWithoutContactInput
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutLeadsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
  }

  export type DealCreateWithoutLeadInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    contact: ContactCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    tickets?: TicketCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutLeadInput = {
    id?: string
    tenantId: string
    contactId: string
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutLeadInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
  }

  export type DealCreateManyLeadInputEnvelope = {
    data: DealCreateManyLeadInput | DealCreateManyLeadInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutLeadsInput = {
    update: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
    create: XOR<TenantCreateWithoutLeadsInput, TenantUncheckedCreateWithoutLeadsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutLeadsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutLeadsInput, TenantUncheckedUpdateWithoutLeadsInput>
  }

  export type TenantUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutLeadsInput = {
    update: XOR<ContactUpdateWithoutLeadsInput, ContactUncheckedUpdateWithoutLeadsInput>
    create: XOR<ContactCreateWithoutLeadsInput, ContactUncheckedCreateWithoutLeadsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutLeadsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutLeadsInput, ContactUncheckedUpdateWithoutLeadsInput>
  }

  export type ContactUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    interactions?: InteractionUpdateManyWithoutContactNestedInput
    deals?: DealUpdateManyWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutLeadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutContactNestedInput
    deals?: DealUncheckedUpdateManyWithoutContactNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutContactNestedInput
  }

  export type DealUpsertWithWhereUniqueWithoutLeadInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutLeadInput, DealUncheckedUpdateWithoutLeadInput>
    create: XOR<DealCreateWithoutLeadInput, DealUncheckedCreateWithoutLeadInput>
  }

  export type DealUpdateWithWhereUniqueWithoutLeadInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutLeadInput, DealUncheckedUpdateWithoutLeadInput>
  }

  export type DealUpdateManyWithWhereWithoutLeadInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutLeadInput>
  }

  export type TenantCreateWithoutPipelinesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPipelinesInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPipelinesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPipelinesInput, TenantUncheckedCreateWithoutPipelinesInput>
  }

  export type StageCreateWithoutPipelineInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealCreateNestedManyWithoutStageInput
  }

  export type StageUncheckedCreateWithoutPipelineInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutStageInput
  }

  export type StageCreateOrConnectWithoutPipelineInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutPipelineInput, StageUncheckedCreateWithoutPipelineInput>
  }

  export type StageCreateManyPipelineInputEnvelope = {
    data: StageCreateManyPipelineInput | StageCreateManyPipelineInput[]
    skipDuplicates?: boolean
  }

  export type DealCreateWithoutPipelineInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    contact: ContactCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    tickets?: TicketCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutPipelineInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutPipelineInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutPipelineInput, DealUncheckedCreateWithoutPipelineInput>
  }

  export type DealCreateManyPipelineInputEnvelope = {
    data: DealCreateManyPipelineInput | DealCreateManyPipelineInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutPipelinesInput = {
    update: XOR<TenantUpdateWithoutPipelinesInput, TenantUncheckedUpdateWithoutPipelinesInput>
    create: XOR<TenantCreateWithoutPipelinesInput, TenantUncheckedCreateWithoutPipelinesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPipelinesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPipelinesInput, TenantUncheckedUpdateWithoutPipelinesInput>
  }

  export type TenantUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPipelinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type StageUpsertWithWhereUniqueWithoutPipelineInput = {
    where: StageWhereUniqueInput
    update: XOR<StageUpdateWithoutPipelineInput, StageUncheckedUpdateWithoutPipelineInput>
    create: XOR<StageCreateWithoutPipelineInput, StageUncheckedCreateWithoutPipelineInput>
  }

  export type StageUpdateWithWhereUniqueWithoutPipelineInput = {
    where: StageWhereUniqueInput
    data: XOR<StageUpdateWithoutPipelineInput, StageUncheckedUpdateWithoutPipelineInput>
  }

  export type StageUpdateManyWithWhereWithoutPipelineInput = {
    where: StageScalarWhereInput
    data: XOR<StageUpdateManyMutationInput, StageUncheckedUpdateManyWithoutPipelineInput>
  }

  export type StageScalarWhereInput = {
    AND?: StageScalarWhereInput | StageScalarWhereInput[]
    OR?: StageScalarWhereInput[]
    NOT?: StageScalarWhereInput | StageScalarWhereInput[]
    id?: StringFilter<"Stage"> | string
    pipelineId?: StringFilter<"Stage"> | string
    name?: StringFilter<"Stage"> | string
    order?: IntFilter<"Stage"> | number
    createdAt?: DateTimeFilter<"Stage"> | Date | string
    updatedAt?: DateTimeFilter<"Stage"> | Date | string
  }

  export type DealUpsertWithWhereUniqueWithoutPipelineInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutPipelineInput, DealUncheckedUpdateWithoutPipelineInput>
    create: XOR<DealCreateWithoutPipelineInput, DealUncheckedCreateWithoutPipelineInput>
  }

  export type DealUpdateWithWhereUniqueWithoutPipelineInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutPipelineInput, DealUncheckedUpdateWithoutPipelineInput>
  }

  export type DealUpdateManyWithWhereWithoutPipelineInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutPipelineInput>
  }

  export type PipelineCreateWithoutStagesInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPipelinesInput
    deals?: DealCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUncheckedCreateWithoutStagesInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deals?: DealUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineCreateOrConnectWithoutStagesInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutStagesInput, PipelineUncheckedCreateWithoutStagesInput>
  }

  export type DealCreateWithoutStageInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    contact: ContactCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    tickets?: TicketCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutStageInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutStageInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput>
  }

  export type DealCreateManyStageInputEnvelope = {
    data: DealCreateManyStageInput | DealCreateManyStageInput[]
    skipDuplicates?: boolean
  }

  export type PipelineUpsertWithoutStagesInput = {
    update: XOR<PipelineUpdateWithoutStagesInput, PipelineUncheckedUpdateWithoutStagesInput>
    create: XOR<PipelineCreateWithoutStagesInput, PipelineUncheckedCreateWithoutStagesInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutStagesInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutStagesInput, PipelineUncheckedUpdateWithoutStagesInput>
  }

  export type PipelineUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPipelinesNestedInput
    deals?: DealUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutStagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type DealUpsertWithWhereUniqueWithoutStageInput = {
    where: DealWhereUniqueInput
    update: XOR<DealUpdateWithoutStageInput, DealUncheckedUpdateWithoutStageInput>
    create: XOR<DealCreateWithoutStageInput, DealUncheckedCreateWithoutStageInput>
  }

  export type DealUpdateWithWhereUniqueWithoutStageInput = {
    where: DealWhereUniqueInput
    data: XOR<DealUpdateWithoutStageInput, DealUncheckedUpdateWithoutStageInput>
  }

  export type DealUpdateManyWithWhereWithoutStageInput = {
    where: DealScalarWhereInput
    data: XOR<DealUpdateManyMutationInput, DealUncheckedUpdateManyWithoutStageInput>
  }

  export type TenantCreateWithoutDealsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutDealsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutDealsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
  }

  export type ContactCreateWithoutDealsInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
    interactions?: InteractionCreateNestedManyWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    callLogs?: CallLogCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutDealsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutContactInput
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutDealsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutDealsInput, ContactUncheckedCreateWithoutDealsInput>
  }

  export type LeadCreateWithoutDealsInput = {
    id?: string
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutLeadsInput
    contact?: ContactCreateNestedOneWithoutLeadsInput
  }

  export type LeadUncheckedCreateWithoutDealsInput = {
    id?: string
    tenantId: string
    contactId?: string | null
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateOrConnectWithoutDealsInput = {
    where: LeadWhereUniqueInput
    create: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
  }

  export type PipelineCreateWithoutDealsInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPipelinesInput
    stages?: StageCreateNestedManyWithoutPipelineInput
  }

  export type PipelineUncheckedCreateWithoutDealsInput = {
    id?: string
    tenantId: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    stages?: StageUncheckedCreateNestedManyWithoutPipelineInput
  }

  export type PipelineCreateOrConnectWithoutDealsInput = {
    where: PipelineWhereUniqueInput
    create: XOR<PipelineCreateWithoutDealsInput, PipelineUncheckedCreateWithoutDealsInput>
  }

  export type StageCreateWithoutDealsInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
    pipeline: PipelineCreateNestedOneWithoutStagesInput
  }

  export type StageUncheckedCreateWithoutDealsInput = {
    id?: string
    pipelineId: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageCreateOrConnectWithoutDealsInput = {
    where: StageWhereUniqueInput
    create: XOR<StageCreateWithoutDealsInput, StageUncheckedCreateWithoutDealsInput>
  }

  export type InteractionCreateWithoutDealInput = {
    id?: string
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutInteractionsInput
    contact: ContactCreateNestedOneWithoutInteractionsInput
    user?: UserCreateNestedOneWithoutInteractionsInput
  }

  export type InteractionUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    contactId: string
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateOrConnectWithoutDealInput = {
    where: InteractionWhereUniqueInput
    create: XOR<InteractionCreateWithoutDealInput, InteractionUncheckedCreateWithoutDealInput>
  }

  export type InteractionCreateManyDealInputEnvelope = {
    data: InteractionCreateManyDealInput | InteractionCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TicketCreateWithoutDealInput = {
    id?: string
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketsInput
    assignedUser?: UserCreateNestedOneWithoutTicketsAssignedInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    contactId: string
    portalCustomerId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutDealInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutDealInput, TicketUncheckedCreateWithoutDealInput>
  }

  export type TicketCreateManyDealInputEnvelope = {
    data: TicketCreateManyDealInput | TicketCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type CallLogCreateWithoutDealInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallLogsInput
    contact?: ContactCreateNestedOneWithoutCallLogsInput
    recording?: CallRecordingCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionCreateNestedOneWithoutCallLogInput
  }

  export type CallLogUncheckedCreateWithoutDealInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    recording?: CallRecordingUncheckedCreateNestedOneWithoutCallLogInput
    transcription?: CallTranscriptionUncheckedCreateNestedOneWithoutCallLogInput
  }

  export type CallLogCreateOrConnectWithoutDealInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutDealInput, CallLogUncheckedCreateWithoutDealInput>
  }

  export type CallLogCreateManyDealInputEnvelope = {
    data: CallLogCreateManyDealInput | CallLogCreateManyDealInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutDealsInput = {
    update: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
    create: XOR<TenantCreateWithoutDealsInput, TenantUncheckedCreateWithoutDealsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutDealsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutDealsInput, TenantUncheckedUpdateWithoutDealsInput>
  }

  export type TenantUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutDealsInput = {
    update: XOR<ContactUpdateWithoutDealsInput, ContactUncheckedUpdateWithoutDealsInput>
    create: XOR<ContactCreateWithoutDealsInput, ContactUncheckedCreateWithoutDealsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutDealsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutDealsInput, ContactUncheckedUpdateWithoutDealsInput>
  }

  export type ContactUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
    interactions?: InteractionUpdateManyWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutContactNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutContactNestedInput
  }

  export type LeadUpsertWithoutDealsInput = {
    update: XOR<LeadUpdateWithoutDealsInput, LeadUncheckedUpdateWithoutDealsInput>
    create: XOR<LeadCreateWithoutDealsInput, LeadUncheckedCreateWithoutDealsInput>
    where?: LeadWhereInput
  }

  export type LeadUpdateToOneWithWhereWithoutDealsInput = {
    where?: LeadWhereInput
    data: XOR<LeadUpdateWithoutDealsInput, LeadUncheckedUpdateWithoutDealsInput>
  }

  export type LeadUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    contact?: ContactUpdateOneWithoutLeadsNestedInput
  }

  export type LeadUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUpsertWithoutDealsInput = {
    update: XOR<PipelineUpdateWithoutDealsInput, PipelineUncheckedUpdateWithoutDealsInput>
    create: XOR<PipelineCreateWithoutDealsInput, PipelineUncheckedCreateWithoutDealsInput>
    where?: PipelineWhereInput
  }

  export type PipelineUpdateToOneWithWhereWithoutDealsInput = {
    where?: PipelineWhereInput
    data: XOR<PipelineUpdateWithoutDealsInput, PipelineUncheckedUpdateWithoutDealsInput>
  }

  export type PipelineUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPipelinesNestedInput
    stages?: StageUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type StageUpsertWithoutDealsInput = {
    update: XOR<StageUpdateWithoutDealsInput, StageUncheckedUpdateWithoutDealsInput>
    create: XOR<StageCreateWithoutDealsInput, StageUncheckedCreateWithoutDealsInput>
    where?: StageWhereInput
  }

  export type StageUpdateToOneWithWhereWithoutDealsInput = {
    where?: StageWhereInput
    data: XOR<StageUpdateWithoutDealsInput, StageUncheckedUpdateWithoutDealsInput>
  }

  export type StageUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pipeline?: PipelineUpdateOneRequiredWithoutStagesNestedInput
  }

  export type StageUncheckedUpdateWithoutDealsInput = {
    id?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUpsertWithWhereUniqueWithoutDealInput = {
    where: InteractionWhereUniqueInput
    update: XOR<InteractionUpdateWithoutDealInput, InteractionUncheckedUpdateWithoutDealInput>
    create: XOR<InteractionCreateWithoutDealInput, InteractionUncheckedCreateWithoutDealInput>
  }

  export type InteractionUpdateWithWhereUniqueWithoutDealInput = {
    where: InteractionWhereUniqueInput
    data: XOR<InteractionUpdateWithoutDealInput, InteractionUncheckedUpdateWithoutDealInput>
  }

  export type InteractionUpdateManyWithWhereWithoutDealInput = {
    where: InteractionScalarWhereInput
    data: XOR<InteractionUpdateManyMutationInput, InteractionUncheckedUpdateManyWithoutDealInput>
  }

  export type TicketUpsertWithWhereUniqueWithoutDealInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutDealInput, TicketUncheckedUpdateWithoutDealInput>
    create: XOR<TicketCreateWithoutDealInput, TicketUncheckedCreateWithoutDealInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutDealInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutDealInput, TicketUncheckedUpdateWithoutDealInput>
  }

  export type TicketUpdateManyWithWhereWithoutDealInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutDealInput>
  }

  export type CallLogUpsertWithWhereUniqueWithoutDealInput = {
    where: CallLogWhereUniqueInput
    update: XOR<CallLogUpdateWithoutDealInput, CallLogUncheckedUpdateWithoutDealInput>
    create: XOR<CallLogCreateWithoutDealInput, CallLogUncheckedCreateWithoutDealInput>
  }

  export type CallLogUpdateWithWhereUniqueWithoutDealInput = {
    where: CallLogWhereUniqueInput
    data: XOR<CallLogUpdateWithoutDealInput, CallLogUncheckedUpdateWithoutDealInput>
  }

  export type CallLogUpdateManyWithWhereWithoutDealInput = {
    where: CallLogScalarWhereInput
    data: XOR<CallLogUpdateManyMutationInput, CallLogUncheckedUpdateManyWithoutDealInput>
  }

  export type TenantCreateWithoutInteractionsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutInteractionsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutInteractionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutInteractionsInput, TenantUncheckedCreateWithoutInteractionsInput>
  }

  export type ContactCreateWithoutInteractionsInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
    deals?: DealCreateNestedManyWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    callLogs?: CallLogCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutInteractionsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    deals?: DealUncheckedCreateNestedManyWithoutContactInput
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutInteractionsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutInteractionsInput, ContactUncheckedCreateWithoutInteractionsInput>
  }

  export type DealCreateWithoutInteractionsInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    contact: ContactCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    tickets?: TicketCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutInteractionsInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutInteractionsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutInteractionsInput, DealUncheckedCreateWithoutInteractionsInput>
  }

  export type UserCreateWithoutInteractionsInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInteractionsInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInteractionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
  }

  export type TenantUpsertWithoutInteractionsInput = {
    update: XOR<TenantUpdateWithoutInteractionsInput, TenantUncheckedUpdateWithoutInteractionsInput>
    create: XOR<TenantCreateWithoutInteractionsInput, TenantUncheckedCreateWithoutInteractionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutInteractionsInput, TenantUncheckedUpdateWithoutInteractionsInput>
  }

  export type TenantUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutInteractionsInput = {
    update: XOR<ContactUpdateWithoutInteractionsInput, ContactUncheckedUpdateWithoutInteractionsInput>
    create: XOR<ContactCreateWithoutInteractionsInput, ContactUncheckedCreateWithoutInteractionsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutInteractionsInput, ContactUncheckedUpdateWithoutInteractionsInput>
  }

  export type ContactUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
    deals?: DealUpdateManyWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    deals?: DealUncheckedUpdateManyWithoutContactNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutContactNestedInput
  }

  export type DealUpsertWithoutInteractionsInput = {
    update: XOR<DealUpdateWithoutInteractionsInput, DealUncheckedUpdateWithoutInteractionsInput>
    create: XOR<DealCreateWithoutInteractionsInput, DealUncheckedCreateWithoutInteractionsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutInteractionsInput, DealUncheckedUpdateWithoutInteractionsInput>
  }

  export type DealUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type UserUpsertWithoutInteractionsInput = {
    update: XOR<UserUpdateWithoutInteractionsInput, UserUncheckedUpdateWithoutInteractionsInput>
    create: XOR<UserCreateWithoutInteractionsInput, UserUncheckedCreateWithoutInteractionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInteractionsInput, UserUncheckedUpdateWithoutInteractionsInput>
  }

  export type UserUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInteractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutTicketsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutTicketsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutTicketsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
  }

  export type ContactCreateWithoutTicketsInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
    interactions?: InteractionCreateNestedManyWithoutContactInput
    deals?: DealCreateNestedManyWithoutContactInput
    callLogs?: CallLogCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutTicketsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutContactInput
    deals?: DealUncheckedCreateNestedManyWithoutContactInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutTicketsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
  }

  export type PortalCustomerCreateWithoutTicketsInput = {
    id?: string
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPortalCustomersInput
    contact?: ContactCreateNestedOneWithoutPortalCustomersInput
    ticketComments?: TicketCommentCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerUncheckedCreateWithoutTicketsInput = {
    id?: string
    tenantId: string
    contactId?: string | null
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerCreateOrConnectWithoutTicketsInput = {
    where: PortalCustomerWhereUniqueInput
    create: XOR<PortalCustomerCreateWithoutTicketsInput, PortalCustomerUncheckedCreateWithoutTicketsInput>
  }

  export type DealCreateWithoutTicketsInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    contact: ContactCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    callLogs?: CallLogCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutTicketsInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutTicketsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutTicketsInput, DealUncheckedCreateWithoutTicketsInput>
  }

  export type UserCreateWithoutTicketsAssignedInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketsAssignedInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketsAssignedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketsAssignedInput, UserUncheckedCreateWithoutTicketsAssignedInput>
  }

  export type TicketCommentCreateWithoutTicketInput = {
    id?: string
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutTicketCommentsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutTicketInput = {
    id?: string
    userId?: string | null
    portalCustomerId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentCreateManyTicketInputEnvelope = {
    data: TicketCommentCreateManyTicketInput | TicketCommentCreateManyTicketInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutTicketsInput = {
    update: XOR<TenantUpdateWithoutTicketsInput, TenantUncheckedUpdateWithoutTicketsInput>
    create: XOR<TenantCreateWithoutTicketsInput, TenantUncheckedCreateWithoutTicketsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutTicketsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutTicketsInput, TenantUncheckedUpdateWithoutTicketsInput>
  }

  export type TenantUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutTicketsInput = {
    update: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
    create: XOR<ContactCreateWithoutTicketsInput, ContactUncheckedCreateWithoutTicketsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutTicketsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutTicketsInput, ContactUncheckedUpdateWithoutTicketsInput>
  }

  export type ContactUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
    interactions?: InteractionUpdateManyWithoutContactNestedInput
    deals?: DealUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutContactNestedInput
    deals?: DealUncheckedUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutContactNestedInput
  }

  export type PortalCustomerUpsertWithoutTicketsInput = {
    update: XOR<PortalCustomerUpdateWithoutTicketsInput, PortalCustomerUncheckedUpdateWithoutTicketsInput>
    create: XOR<PortalCustomerCreateWithoutTicketsInput, PortalCustomerUncheckedCreateWithoutTicketsInput>
    where?: PortalCustomerWhereInput
  }

  export type PortalCustomerUpdateToOneWithWhereWithoutTicketsInput = {
    where?: PortalCustomerWhereInput
    data: XOR<PortalCustomerUpdateWithoutTicketsInput, PortalCustomerUncheckedUpdateWithoutTicketsInput>
  }

  export type PortalCustomerUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPortalCustomersNestedInput
    contact?: ContactUpdateOneWithoutPortalCustomersNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutPortalCustomerNestedInput
  }

  export type DealUpsertWithoutTicketsInput = {
    update: XOR<DealUpdateWithoutTicketsInput, DealUncheckedUpdateWithoutTicketsInput>
    create: XOR<DealCreateWithoutTicketsInput, DealUncheckedCreateWithoutTicketsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutTicketsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutTicketsInput, DealUncheckedUpdateWithoutTicketsInput>
  }

  export type DealUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutTicketsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type UserUpsertWithoutTicketsAssignedInput = {
    update: XOR<UserUpdateWithoutTicketsAssignedInput, UserUncheckedUpdateWithoutTicketsAssignedInput>
    create: XOR<UserCreateWithoutTicketsAssignedInput, UserUncheckedCreateWithoutTicketsAssignedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketsAssignedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketsAssignedInput, UserUncheckedUpdateWithoutTicketsAssignedInput>
  }

  export type UserUpdateWithoutTicketsAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketsAssignedInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
    create: XOR<TicketCommentCreateWithoutTicketInput, TicketCommentUncheckedCreateWithoutTicketInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutTicketInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutTicketInput, TicketCommentUncheckedUpdateWithoutTicketInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutTicketInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutTicketInput>
  }

  export type TicketCreateWithoutCommentsInput = {
    id?: string
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    portalCustomer?: PortalCustomerCreateNestedOneWithoutTicketsInput
    deal?: DealCreateNestedOneWithoutTicketsInput
    assignedUser?: UserCreateNestedOneWithoutTicketsAssignedInput
  }

  export type TicketUncheckedCreateWithoutCommentsInput = {
    id?: string
    tenantId: string
    contactId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type TicketCreateOrConnectWithoutCommentsInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutTicketCommentsInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTicketCommentsInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTicketCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
  }

  export type PortalCustomerCreateWithoutTicketCommentsInput = {
    id?: string
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutPortalCustomersInput
    contact?: ContactCreateNestedOneWithoutPortalCustomersInput
    tickets?: TicketCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerUncheckedCreateWithoutTicketCommentsInput = {
    id?: string
    tenantId: string
    contactId?: string | null
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tickets?: TicketUncheckedCreateNestedManyWithoutPortalCustomerInput
  }

  export type PortalCustomerCreateOrConnectWithoutTicketCommentsInput = {
    where: PortalCustomerWhereUniqueInput
    create: XOR<PortalCustomerCreateWithoutTicketCommentsInput, PortalCustomerUncheckedCreateWithoutTicketCommentsInput>
  }

  export type TicketUpsertWithoutCommentsInput = {
    update: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
    create: XOR<TicketCreateWithoutCommentsInput, TicketUncheckedCreateWithoutCommentsInput>
    where?: TicketWhereInput
  }

  export type TicketUpdateToOneWithWhereWithoutCommentsInput = {
    where?: TicketWhereInput
    data: XOR<TicketUpdateWithoutCommentsInput, TicketUncheckedUpdateWithoutCommentsInput>
  }

  export type TicketUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketsNestedInput
    deal?: DealUpdateOneWithoutTicketsNestedInput
    assignedUser?: UserUpdateOneWithoutTicketsAssignedNestedInput
  }

  export type TicketUncheckedUpdateWithoutCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUpsertWithoutTicketCommentsInput = {
    update: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
    create: XOR<UserCreateWithoutTicketCommentsInput, UserUncheckedCreateWithoutTicketCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTicketCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTicketCommentsInput, UserUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type UserUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PortalCustomerUpsertWithoutTicketCommentsInput = {
    update: XOR<PortalCustomerUpdateWithoutTicketCommentsInput, PortalCustomerUncheckedUpdateWithoutTicketCommentsInput>
    create: XOR<PortalCustomerCreateWithoutTicketCommentsInput, PortalCustomerUncheckedCreateWithoutTicketCommentsInput>
    where?: PortalCustomerWhereInput
  }

  export type PortalCustomerUpdateToOneWithWhereWithoutTicketCommentsInput = {
    where?: PortalCustomerWhereInput
    data: XOR<PortalCustomerUpdateWithoutTicketCommentsInput, PortalCustomerUncheckedUpdateWithoutTicketCommentsInput>
  }

  export type PortalCustomerUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPortalCustomersNestedInput
    contact?: ContactUpdateOneWithoutPortalCustomersNestedInput
    tickets?: TicketUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerUncheckedUpdateWithoutTicketCommentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutPortalCustomerNestedInput
  }

  export type TenantCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutIntegrationsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutIntegrationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
  }

  export type TenantUpsertWithoutIntegrationsInput = {
    update: XOR<TenantUpdateWithoutIntegrationsInput, TenantUncheckedUpdateWithoutIntegrationsInput>
    create: XOR<TenantCreateWithoutIntegrationsInput, TenantUncheckedCreateWithoutIntegrationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutIntegrationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutIntegrationsInput, TenantUncheckedUpdateWithoutIntegrationsInput>
  }

  export type TenantUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutIntegrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateWithoutCallLogsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCallLogsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCallLogsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCallLogsInput, TenantUncheckedCreateWithoutCallLogsInput>
  }

  export type ContactCreateWithoutCallLogsInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
    interactions?: InteractionCreateNestedManyWithoutContactInput
    deals?: DealCreateNestedManyWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutCallLogsInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutContactInput
    deals?: DealUncheckedCreateNestedManyWithoutContactInput
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutCallLogsInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutCallLogsInput, ContactUncheckedCreateWithoutCallLogsInput>
  }

  export type DealCreateWithoutCallLogsInput = {
    id?: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutDealsInput
    contact: ContactCreateNestedOneWithoutDealsInput
    lead?: LeadCreateNestedOneWithoutDealsInput
    pipeline: PipelineCreateNestedOneWithoutDealsInput
    stage: StageCreateNestedOneWithoutDealsInput
    interactions?: InteractionCreateNestedManyWithoutDealInput
    tickets?: TicketCreateNestedManyWithoutDealInput
  }

  export type DealUncheckedCreateWithoutCallLogsInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutDealInput
    tickets?: TicketUncheckedCreateNestedManyWithoutDealInput
  }

  export type DealCreateOrConnectWithoutCallLogsInput = {
    where: DealWhereUniqueInput
    create: XOR<DealCreateWithoutCallLogsInput, DealUncheckedCreateWithoutCallLogsInput>
  }

  export type CallRecordingCreateWithoutCallLogInput = {
    id?: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallRecordingsInput
  }

  export type CallRecordingUncheckedCreateWithoutCallLogInput = {
    id?: string
    tenantId: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallRecordingCreateOrConnectWithoutCallLogInput = {
    where: CallRecordingWhereUniqueInput
    create: XOR<CallRecordingCreateWithoutCallLogInput, CallRecordingUncheckedCreateWithoutCallLogInput>
  }

  export type CallTranscriptionCreateWithoutCallLogInput = {
    id?: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallTranscriptionsInput
  }

  export type CallTranscriptionUncheckedCreateWithoutCallLogInput = {
    id?: string
    tenantId: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallTranscriptionCreateOrConnectWithoutCallLogInput = {
    where: CallTranscriptionWhereUniqueInput
    create: XOR<CallTranscriptionCreateWithoutCallLogInput, CallTranscriptionUncheckedCreateWithoutCallLogInput>
  }

  export type TenantUpsertWithoutCallLogsInput = {
    update: XOR<TenantUpdateWithoutCallLogsInput, TenantUncheckedUpdateWithoutCallLogsInput>
    create: XOR<TenantCreateWithoutCallLogsInput, TenantUncheckedCreateWithoutCallLogsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCallLogsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCallLogsInput, TenantUncheckedUpdateWithoutCallLogsInput>
  }

  export type TenantUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutCallLogsInput = {
    update: XOR<ContactUpdateWithoutCallLogsInput, ContactUncheckedUpdateWithoutCallLogsInput>
    create: XOR<ContactCreateWithoutCallLogsInput, ContactUncheckedCreateWithoutCallLogsInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutCallLogsInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutCallLogsInput, ContactUncheckedUpdateWithoutCallLogsInput>
  }

  export type ContactUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
    interactions?: InteractionUpdateManyWithoutContactNestedInput
    deals?: DealUpdateManyWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutContactNestedInput
    deals?: DealUncheckedUpdateManyWithoutContactNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutContactNestedInput
  }

  export type DealUpsertWithoutCallLogsInput = {
    update: XOR<DealUpdateWithoutCallLogsInput, DealUncheckedUpdateWithoutCallLogsInput>
    create: XOR<DealCreateWithoutCallLogsInput, DealUncheckedCreateWithoutCallLogsInput>
    where?: DealWhereInput
  }

  export type DealUpdateToOneWithWhereWithoutCallLogsInput = {
    where?: DealWhereInput
    data: XOR<DealUpdateWithoutCallLogsInput, DealUncheckedUpdateWithoutCallLogsInput>
  }

  export type DealUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutCallLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
  }

  export type CallRecordingUpsertWithoutCallLogInput = {
    update: XOR<CallRecordingUpdateWithoutCallLogInput, CallRecordingUncheckedUpdateWithoutCallLogInput>
    create: XOR<CallRecordingCreateWithoutCallLogInput, CallRecordingUncheckedCreateWithoutCallLogInput>
    where?: CallRecordingWhereInput
  }

  export type CallRecordingUpdateToOneWithWhereWithoutCallLogInput = {
    where?: CallRecordingWhereInput
    data: XOR<CallRecordingUpdateWithoutCallLogInput, CallRecordingUncheckedUpdateWithoutCallLogInput>
  }

  export type CallRecordingUpdateWithoutCallLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallRecordingsNestedInput
  }

  export type CallRecordingUncheckedUpdateWithoutCallLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallTranscriptionUpsertWithoutCallLogInput = {
    update: XOR<CallTranscriptionUpdateWithoutCallLogInput, CallTranscriptionUncheckedUpdateWithoutCallLogInput>
    create: XOR<CallTranscriptionCreateWithoutCallLogInput, CallTranscriptionUncheckedCreateWithoutCallLogInput>
    where?: CallTranscriptionWhereInput
  }

  export type CallTranscriptionUpdateToOneWithWhereWithoutCallLogInput = {
    where?: CallTranscriptionWhereInput
    data: XOR<CallTranscriptionUpdateWithoutCallLogInput, CallTranscriptionUncheckedUpdateWithoutCallLogInput>
  }

  export type CallTranscriptionUpdateWithoutCallLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallTranscriptionsNestedInput
  }

  export type CallTranscriptionUncheckedUpdateWithoutCallLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantCreateWithoutPortalCustomersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutPortalCustomersInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutPortalCustomersInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutPortalCustomersInput, TenantUncheckedCreateWithoutPortalCustomersInput>
  }

  export type ContactCreateWithoutPortalCustomersInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutContactsInput
    leads?: LeadCreateNestedManyWithoutContactInput
    interactions?: InteractionCreateNestedManyWithoutContactInput
    deals?: DealCreateNestedManyWithoutContactInput
    tickets?: TicketCreateNestedManyWithoutContactInput
    callLogs?: CallLogCreateNestedManyWithoutContactInput
  }

  export type ContactUncheckedCreateWithoutPortalCustomersInput = {
    id?: string
    tenantId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    leads?: LeadUncheckedCreateNestedManyWithoutContactInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutContactInput
    deals?: DealUncheckedCreateNestedManyWithoutContactInput
    tickets?: TicketUncheckedCreateNestedManyWithoutContactInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutContactInput
  }

  export type ContactCreateOrConnectWithoutPortalCustomersInput = {
    where: ContactWhereUniqueInput
    create: XOR<ContactCreateWithoutPortalCustomersInput, ContactUncheckedCreateWithoutPortalCustomersInput>
  }

  export type TicketCreateWithoutPortalCustomerInput = {
    id?: string
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutTicketsInput
    contact: ContactCreateNestedOneWithoutTicketsInput
    deal?: DealCreateNestedOneWithoutTicketsInput
    assignedUser?: UserCreateNestedOneWithoutTicketsAssignedInput
    comments?: TicketCommentCreateNestedManyWithoutTicketInput
  }

  export type TicketUncheckedCreateWithoutPortalCustomerInput = {
    id?: string
    tenantId: string
    contactId: string
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
    comments?: TicketCommentUncheckedCreateNestedManyWithoutTicketInput
  }

  export type TicketCreateOrConnectWithoutPortalCustomerInput = {
    where: TicketWhereUniqueInput
    create: XOR<TicketCreateWithoutPortalCustomerInput, TicketUncheckedCreateWithoutPortalCustomerInput>
  }

  export type TicketCreateManyPortalCustomerInputEnvelope = {
    data: TicketCreateManyPortalCustomerInput | TicketCreateManyPortalCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TicketCommentCreateWithoutPortalCustomerInput = {
    id?: string
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    ticket: TicketCreateNestedOneWithoutCommentsInput
    user?: UserCreateNestedOneWithoutTicketCommentsInput
  }

  export type TicketCommentUncheckedCreateWithoutPortalCustomerInput = {
    id?: string
    ticketId: string
    userId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentCreateOrConnectWithoutPortalCustomerInput = {
    where: TicketCommentWhereUniqueInput
    create: XOR<TicketCommentCreateWithoutPortalCustomerInput, TicketCommentUncheckedCreateWithoutPortalCustomerInput>
  }

  export type TicketCommentCreateManyPortalCustomerInputEnvelope = {
    data: TicketCommentCreateManyPortalCustomerInput | TicketCommentCreateManyPortalCustomerInput[]
    skipDuplicates?: boolean
  }

  export type TenantUpsertWithoutPortalCustomersInput = {
    update: XOR<TenantUpdateWithoutPortalCustomersInput, TenantUncheckedUpdateWithoutPortalCustomersInput>
    create: XOR<TenantCreateWithoutPortalCustomersInput, TenantUncheckedCreateWithoutPortalCustomersInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutPortalCustomersInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutPortalCustomersInput, TenantUncheckedUpdateWithoutPortalCustomersInput>
  }

  export type TenantUpdateWithoutPortalCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutPortalCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ContactUpsertWithoutPortalCustomersInput = {
    update: XOR<ContactUpdateWithoutPortalCustomersInput, ContactUncheckedUpdateWithoutPortalCustomersInput>
    create: XOR<ContactCreateWithoutPortalCustomersInput, ContactUncheckedCreateWithoutPortalCustomersInput>
    where?: ContactWhereInput
  }

  export type ContactUpdateToOneWithWhereWithoutPortalCustomersInput = {
    where?: ContactWhereInput
    data: XOR<ContactUpdateWithoutPortalCustomersInput, ContactUncheckedUpdateWithoutPortalCustomersInput>
  }

  export type ContactUpdateWithoutPortalCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutContactsNestedInput
    leads?: LeadUpdateManyWithoutContactNestedInput
    interactions?: InteractionUpdateManyWithoutContactNestedInput
    deals?: DealUpdateManyWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutPortalCustomersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutContactNestedInput
    deals?: DealUncheckedUpdateManyWithoutContactNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutContactNestedInput
  }

  export type TicketUpsertWithWhereUniqueWithoutPortalCustomerInput = {
    where: TicketWhereUniqueInput
    update: XOR<TicketUpdateWithoutPortalCustomerInput, TicketUncheckedUpdateWithoutPortalCustomerInput>
    create: XOR<TicketCreateWithoutPortalCustomerInput, TicketUncheckedCreateWithoutPortalCustomerInput>
  }

  export type TicketUpdateWithWhereUniqueWithoutPortalCustomerInput = {
    where: TicketWhereUniqueInput
    data: XOR<TicketUpdateWithoutPortalCustomerInput, TicketUncheckedUpdateWithoutPortalCustomerInput>
  }

  export type TicketUpdateManyWithWhereWithoutPortalCustomerInput = {
    where: TicketScalarWhereInput
    data: XOR<TicketUpdateManyMutationInput, TicketUncheckedUpdateManyWithoutPortalCustomerInput>
  }

  export type TicketCommentUpsertWithWhereUniqueWithoutPortalCustomerInput = {
    where: TicketCommentWhereUniqueInput
    update: XOR<TicketCommentUpdateWithoutPortalCustomerInput, TicketCommentUncheckedUpdateWithoutPortalCustomerInput>
    create: XOR<TicketCommentCreateWithoutPortalCustomerInput, TicketCommentUncheckedCreateWithoutPortalCustomerInput>
  }

  export type TicketCommentUpdateWithWhereUniqueWithoutPortalCustomerInput = {
    where: TicketCommentWhereUniqueInput
    data: XOR<TicketCommentUpdateWithoutPortalCustomerInput, TicketCommentUncheckedUpdateWithoutPortalCustomerInput>
  }

  export type TicketCommentUpdateManyWithWhereWithoutPortalCustomerInput = {
    where: TicketCommentScalarWhereInput
    data: XOR<TicketCommentUpdateManyMutationInput, TicketCommentUncheckedUpdateManyWithoutPortalCustomerInput>
  }

  export type TenantCreateWithoutUserInvitationsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutUserInvitationsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutUserInvitationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutUserInvitationsInput, TenantUncheckedCreateWithoutUserInvitationsInput>
  }

  export type UserCreateWithoutInvitationsInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutInvitationsInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutInvitationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
  }

  export type TenantUpsertWithoutUserInvitationsInput = {
    update: XOR<TenantUpdateWithoutUserInvitationsInput, TenantUncheckedUpdateWithoutUserInvitationsInput>
    create: XOR<TenantCreateWithoutUserInvitationsInput, TenantUncheckedCreateWithoutUserInvitationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutUserInvitationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutUserInvitationsInput, TenantUncheckedUpdateWithoutUserInvitationsInput>
  }

  export type TenantUpdateWithoutUserInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutUserInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserUpsertWithoutInvitationsInput = {
    update: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
    create: XOR<UserCreateWithoutInvitationsInput, UserUncheckedCreateWithoutInvitationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvitationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvitationsInput, UserUncheckedUpdateWithoutInvitationsInput>
  }

  export type UserUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutInvitationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutConversationInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageCreateManyConversationInputEnvelope = {
    data: MessageCreateManyConversationInput | MessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutConversationsInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutConversationsInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutConversationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
  }

  export type TenantCreateWithoutConversationsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutConversationsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutConversationsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
    create: XOR<MessageCreateWithoutConversationInput, MessageUncheckedCreateWithoutConversationInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutConversationInput, MessageUncheckedUpdateWithoutConversationInput>
  }

  export type MessageUpdateManyWithWhereWithoutConversationInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    conversationId?: StringFilter<"Message"> | string
    role?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type UserUpsertWithoutConversationsInput = {
    update: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
    create: XOR<UserCreateWithoutConversationsInput, UserUncheckedCreateWithoutConversationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutConversationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutConversationsInput, UserUncheckedUpdateWithoutConversationsInput>
  }

  export type UserUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantUpsertWithoutConversationsInput = {
    update: XOR<TenantUpdateWithoutConversationsInput, TenantUncheckedUpdateWithoutConversationsInput>
    create: XOR<TenantCreateWithoutConversationsInput, TenantUncheckedCreateWithoutConversationsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutConversationsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutConversationsInput, TenantUncheckedUpdateWithoutConversationsInput>
  }

  export type TenantUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type ConversationCreateWithoutMessagesInput = {
    id?: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutConversationsInput
    tenant: TenantCreateNestedOneWithoutConversationsInput
  }

  export type ConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    userId: string
    tenantId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateOrConnectWithoutMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ConversationUpsertWithoutMessagesInput = {
    update: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ConversationCreateWithoutMessagesInput, ConversationUncheckedCreateWithoutMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutMessagesInput, ConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
    tenant?: TenantUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutTelegramLinkRequestsInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTelegramLinkRequestsInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramUsers?: TelegramUserUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTelegramLinkRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTelegramLinkRequestsInput, UserUncheckedCreateWithoutTelegramLinkRequestsInput>
  }

  export type UserUpsertWithoutTelegramLinkRequestsInput = {
    update: XOR<UserUpdateWithoutTelegramLinkRequestsInput, UserUncheckedUpdateWithoutTelegramLinkRequestsInput>
    create: XOR<UserCreateWithoutTelegramLinkRequestsInput, UserUncheckedCreateWithoutTelegramLinkRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTelegramLinkRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTelegramLinkRequestsInput, UserUncheckedUpdateWithoutTelegramLinkRequestsInput>
  }

  export type UserUpdateWithoutTelegramLinkRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTelegramLinkRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutTelegramUsersInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutUsersInput
    interactions?: InteractionCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentCreateNestedManyWithoutUserInput
    invitations?: UserInvitationCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTelegramUsersInput = {
    id?: string
    tenantId: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: InteractionUncheckedCreateNestedManyWithoutUserInput
    ticketsAssigned?: TicketUncheckedCreateNestedManyWithoutAssignedUserInput
    ticketComments?: TicketCommentUncheckedCreateNestedManyWithoutUserInput
    invitations?: UserInvitationUncheckedCreateNestedManyWithoutInvitedByUserInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutUserInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTelegramUsersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTelegramUsersInput, UserUncheckedCreateWithoutTelegramUsersInput>
  }

  export type UserUpsertWithoutTelegramUsersInput = {
    update: XOR<UserUpdateWithoutTelegramUsersInput, UserUncheckedUpdateWithoutTelegramUsersInput>
    create: XOR<UserCreateWithoutTelegramUsersInput, UserUncheckedCreateWithoutTelegramUsersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTelegramUsersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTelegramUsersInput, UserUncheckedUpdateWithoutTelegramUsersInput>
  }

  export type UserUpdateWithoutTelegramUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUsersNestedInput
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTelegramUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TenantCreateWithoutCallEventsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCallEventsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCallEventsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCallEventsInput, TenantUncheckedCreateWithoutCallEventsInput>
  }

  export type TenantUpsertWithoutCallEventsInput = {
    update: XOR<TenantUpdateWithoutCallEventsInput, TenantUncheckedUpdateWithoutCallEventsInput>
    create: XOR<TenantCreateWithoutCallEventsInput, TenantUncheckedCreateWithoutCallEventsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCallEventsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCallEventsInput, TenantUncheckedUpdateWithoutCallEventsInput>
  }

  export type TenantUpdateWithoutCallEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCallEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CallLogCreateWithoutRecordingInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallLogsInput
    contact?: ContactCreateNestedOneWithoutCallLogsInput
    deal?: DealCreateNestedOneWithoutCallLogsInput
    transcription?: CallTranscriptionCreateNestedOneWithoutCallLogInput
  }

  export type CallLogUncheckedCreateWithoutRecordingInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    dealId?: string | null
    transcription?: CallTranscriptionUncheckedCreateNestedOneWithoutCallLogInput
  }

  export type CallLogCreateOrConnectWithoutRecordingInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutRecordingInput, CallLogUncheckedCreateWithoutRecordingInput>
  }

  export type TenantCreateWithoutCallRecordingsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCallRecordingsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callTranscriptions?: CallTranscriptionUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCallRecordingsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCallRecordingsInput, TenantUncheckedCreateWithoutCallRecordingsInput>
  }

  export type CallLogUpsertWithoutRecordingInput = {
    update: XOR<CallLogUpdateWithoutRecordingInput, CallLogUncheckedUpdateWithoutRecordingInput>
    create: XOR<CallLogCreateWithoutRecordingInput, CallLogUncheckedCreateWithoutRecordingInput>
    where?: CallLogWhereInput
  }

  export type CallLogUpdateToOneWithWhereWithoutRecordingInput = {
    where?: CallLogWhereInput
    data: XOR<CallLogUpdateWithoutRecordingInput, CallLogUncheckedUpdateWithoutRecordingInput>
  }

  export type CallLogUpdateWithoutRecordingInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallLogsNestedInput
    contact?: ContactUpdateOneWithoutCallLogsNestedInput
    deal?: DealUpdateOneWithoutCallLogsNestedInput
    transcription?: CallTranscriptionUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateWithoutRecordingInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    transcription?: CallTranscriptionUncheckedUpdateOneWithoutCallLogNestedInput
  }

  export type TenantUpsertWithoutCallRecordingsInput = {
    update: XOR<TenantUpdateWithoutCallRecordingsInput, TenantUncheckedUpdateWithoutCallRecordingsInput>
    create: XOR<TenantCreateWithoutCallRecordingsInput, TenantUncheckedCreateWithoutCallRecordingsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCallRecordingsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCallRecordingsInput, TenantUncheckedUpdateWithoutCallRecordingsInput>
  }

  export type TenantUpdateWithoutCallRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCallRecordingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callTranscriptions?: CallTranscriptionUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type CallLogCreateWithoutTranscriptionInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant: TenantCreateNestedOneWithoutCallLogsInput
    contact?: ContactCreateNestedOneWithoutCallLogsInput
    deal?: DealCreateNestedOneWithoutCallLogsInput
    recording?: CallRecordingCreateNestedOneWithoutCallLogInput
  }

  export type CallLogUncheckedCreateWithoutTranscriptionInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    dealId?: string | null
    recording?: CallRecordingUncheckedCreateNestedOneWithoutCallLogInput
  }

  export type CallLogCreateOrConnectWithoutTranscriptionInput = {
    where: CallLogWhereUniqueInput
    create: XOR<CallLogCreateWithoutTranscriptionInput, CallLogUncheckedCreateWithoutTranscriptionInput>
  }

  export type TenantCreateWithoutCallTranscriptionsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutTenantInput
    contacts?: ContactCreateNestedManyWithoutTenantInput
    leads?: LeadCreateNestedManyWithoutTenantInput
    pipelines?: PipelineCreateNestedManyWithoutTenantInput
    deals?: DealCreateNestedManyWithoutTenantInput
    interactions?: InteractionCreateNestedManyWithoutTenantInput
    tickets?: TicketCreateNestedManyWithoutTenantInput
    integrations?: IntegrationCreateNestedManyWithoutTenantInput
    callLogs?: CallLogCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationCreateNestedManyWithoutTenantInput
    conversations?: ConversationCreateNestedManyWithoutTenantInput
    callEvents?: CallEventCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateWithoutCallTranscriptionsInput = {
    id?: string
    name: string
    slug: string
    domain?: string | null
    type?: $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutTenantInput
    contacts?: ContactUncheckedCreateNestedManyWithoutTenantInput
    leads?: LeadUncheckedCreateNestedManyWithoutTenantInput
    pipelines?: PipelineUncheckedCreateNestedManyWithoutTenantInput
    deals?: DealUncheckedCreateNestedManyWithoutTenantInput
    interactions?: InteractionUncheckedCreateNestedManyWithoutTenantInput
    tickets?: TicketUncheckedCreateNestedManyWithoutTenantInput
    integrations?: IntegrationUncheckedCreateNestedManyWithoutTenantInput
    callLogs?: CallLogUncheckedCreateNestedManyWithoutTenantInput
    portalCustomers?: PortalCustomerUncheckedCreateNestedManyWithoutTenantInput
    userInvitations?: UserInvitationUncheckedCreateNestedManyWithoutTenantInput
    conversations?: ConversationUncheckedCreateNestedManyWithoutTenantInput
    callEvents?: CallEventUncheckedCreateNestedManyWithoutTenantInput
    callRecordings?: CallRecordingUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantCreateOrConnectWithoutCallTranscriptionsInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutCallTranscriptionsInput, TenantUncheckedCreateWithoutCallTranscriptionsInput>
  }

  export type CallLogUpsertWithoutTranscriptionInput = {
    update: XOR<CallLogUpdateWithoutTranscriptionInput, CallLogUncheckedUpdateWithoutTranscriptionInput>
    create: XOR<CallLogCreateWithoutTranscriptionInput, CallLogUncheckedCreateWithoutTranscriptionInput>
    where?: CallLogWhereInput
  }

  export type CallLogUpdateToOneWithWhereWithoutTranscriptionInput = {
    where?: CallLogWhereInput
    data: XOR<CallLogUpdateWithoutTranscriptionInput, CallLogUncheckedUpdateWithoutTranscriptionInput>
  }

  export type CallLogUpdateWithoutTranscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallLogsNestedInput
    contact?: ContactUpdateOneWithoutCallLogsNestedInput
    deal?: DealUpdateOneWithoutCallLogsNestedInput
    recording?: CallRecordingUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateWithoutTranscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: CallRecordingUncheckedUpdateOneWithoutCallLogNestedInput
  }

  export type TenantUpsertWithoutCallTranscriptionsInput = {
    update: XOR<TenantUpdateWithoutCallTranscriptionsInput, TenantUncheckedUpdateWithoutCallTranscriptionsInput>
    create: XOR<TenantCreateWithoutCallTranscriptionsInput, TenantUncheckedCreateWithoutCallTranscriptionsInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutCallTranscriptionsInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutCallTranscriptionsInput, TenantUncheckedUpdateWithoutCallTranscriptionsInput>
  }

  export type TenantUpdateWithoutCallTranscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutTenantNestedInput
    contacts?: ContactUpdateManyWithoutTenantNestedInput
    leads?: LeadUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUpdateManyWithoutTenantNestedInput
    deals?: DealUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUpdateManyWithoutTenantNestedInput
    tickets?: TicketUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateWithoutCallTranscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumTenantTypeFieldUpdateOperationsInput | $Enums.TenantType
    settings?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutTenantNestedInput
    contacts?: ContactUncheckedUpdateManyWithoutTenantNestedInput
    leads?: LeadUncheckedUpdateManyWithoutTenantNestedInput
    pipelines?: PipelineUncheckedUpdateManyWithoutTenantNestedInput
    deals?: DealUncheckedUpdateManyWithoutTenantNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutTenantNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutTenantNestedInput
    integrations?: IntegrationUncheckedUpdateManyWithoutTenantNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutTenantNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutTenantNestedInput
    userInvitations?: UserInvitationUncheckedUpdateManyWithoutTenantNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutTenantNestedInput
    callEvents?: CallEventUncheckedUpdateManyWithoutTenantNestedInput
    callRecordings?: CallRecordingUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type UserCreateManyTenantInput = {
    id?: string
    supabaseUserId: string
    email: string
    firstName?: string | null
    lastName?: string | null
    name?: string | null
    avatarUrl?: string | null
    role?: $Enums.UserRole
    isActive?: boolean
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContactCreateManyTenantInput = {
    id?: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    company?: string | null
    jobTitle?: string | null
    source?: string | null
    notes?: string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadCreateManyTenantInput = {
    id?: string
    contactId?: string | null
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PipelineCreateManyTenantInput = {
    id?: string
    name: string
    description?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManyTenantInput = {
    id?: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateManyTenantInput = {
    id?: string
    contactId: string
    dealId?: string | null
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyTenantInput = {
    id?: string
    contactId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type IntegrationCreateManyTenantInput = {
    id?: string
    serviceName: string
    isActive?: boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: Date | string | null
    syncStatus?: string | null
    errorMessage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallLogCreateManyTenantInput = {
    id?: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
    dealId?: string | null
  }

  export type PortalCustomerCreateManyTenantInput = {
    id?: string
    contactId?: string | null
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationCreateManyTenantInput = {
    id?: string
    email: string
    role?: $Enums.UserRole
    invitedBy: string
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyTenantInput = {
    id?: string
    userId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallEventCreateManyTenantInput = {
    id?: string
    callerId?: string | null
    calleeId?: string | null
    roomName: string
    eventType: $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CallRecordingCreateManyTenantInput = {
    id?: string
    callLogId: string
    fileUrl: string
    fileName: string
    fileSize?: number | null
    format?: string
    duration?: number | null
    provider?: $Enums.RecordingProvider
    providerId?: string | null
    status?: $Enums.RecordingStatus
    recordingStartTime?: Date | string | null
    recordingEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CallTranscriptionCreateManyTenantInput = {
    id?: string
    callLogId: string
    fullText: string
    segments: JsonNullValueInput | InputJsonValue
    language?: string
    confidence?: number | null
    wordCount?: number | null
    summary?: string | null
    keywords?: CallTranscriptionCreatekeywordsInput | string[]
    sentiment?: string | null
    provider?: $Enums.TranscriptionProvider
    providerId?: string | null
    status?: $Enums.TranscriptionStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutUserNestedInput
    ticketsAssigned?: TicketUncheckedUpdateManyWithoutAssignedUserNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutUserNestedInput
    invitations?: UserInvitationUncheckedUpdateManyWithoutInvitedByUserNestedInput
    conversations?: ConversationUncheckedUpdateManyWithoutUserNestedInput
    telegramUsers?: TelegramUserUncheckedUpdateManyWithoutUserNestedInput
    telegramLinkRequests?: TelegramLinkRequestUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isActive?: BoolFieldUpdateOperationsInput | boolean
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContactUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUpdateManyWithoutContactNestedInput
    interactions?: InteractionUpdateManyWithoutContactNestedInput
    deals?: DealUpdateManyWithoutContactNestedInput
    tickets?: TicketUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leads?: LeadUncheckedUpdateManyWithoutContactNestedInput
    interactions?: InteractionUncheckedUpdateManyWithoutContactNestedInput
    deals?: DealUncheckedUpdateManyWithoutContactNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutContactNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutContactNestedInput
    portalCustomers?: PortalCustomerUncheckedUpdateManyWithoutContactNestedInput
  }

  export type ContactUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    company?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    customFields?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutLeadsNestedInput
    deals?: DealUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PipelineUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUpdateManyWithoutPipelineNestedInput
    deals?: DealUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    stages?: StageUncheckedUpdateManyWithoutPipelineNestedInput
    deals?: DealUncheckedUpdateManyWithoutPipelineNestedInput
  }

  export type PipelineUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutInteractionsNestedInput
    deal?: DealUpdateOneWithoutInteractionsNestedInput
    user?: UserUpdateOneWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketsNestedInput
    deal?: DealUpdateOneWithoutTicketsNestedInput
    assignedUser?: UserUpdateOneWithoutTicketsAssignedNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type IntegrationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntegrationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceName?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    config?: NullableJsonNullValueInput | InputJsonValue
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    syncStatus?: NullableStringFieldUpdateOperationsInput | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallLogUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutCallLogsNestedInput
    deal?: DealUpdateOneWithoutCallLogsNestedInput
    recording?: CallRecordingUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: CallRecordingUncheckedUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUncheckedUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortalCustomerUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contact?: ContactUpdateOneWithoutPortalCustomersNestedInput
    tickets?: TicketUpdateManyWithoutPortalCustomerNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutPortalCustomerNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    invitedByUser?: UserUpdateOneRequiredWithoutInvitationsNestedInput
  }

  export type UserInvitationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    invitedBy?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    user?: UserUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallEventUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: NullableStringFieldUpdateOperationsInput | string | null
    calleeId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCallEventTypeFieldUpdateOperationsInput | $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallEventUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: NullableStringFieldUpdateOperationsInput | string | null
    calleeId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCallEventTypeFieldUpdateOperationsInput | $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallEventUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callerId?: NullableStringFieldUpdateOperationsInput | string | null
    calleeId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: StringFieldUpdateOperationsInput | string
    eventType?: EnumCallEventTypeFieldUpdateOperationsInput | $Enums.CallEventType
    payload?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRecordingUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callLog?: CallLogUpdateOneRequiredWithoutRecordingNestedInput
  }

  export type CallRecordingUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallRecordingUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    format?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    provider?: EnumRecordingProviderFieldUpdateOperationsInput | $Enums.RecordingProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumRecordingStatusFieldUpdateOperationsInput | $Enums.RecordingStatus
    recordingStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallTranscriptionUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callLog?: CallLogUpdateOneRequiredWithoutTranscriptionNestedInput
  }

  export type CallTranscriptionUncheckedUpdateWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallTranscriptionUncheckedUpdateManyWithoutTenantInput = {
    id?: StringFieldUpdateOperationsInput | string
    callLogId?: StringFieldUpdateOperationsInput | string
    fullText?: StringFieldUpdateOperationsInput | string
    segments?: JsonNullValueInput | InputJsonValue
    language?: StringFieldUpdateOperationsInput | string
    confidence?: NullableFloatFieldUpdateOperationsInput | number | null
    wordCount?: NullableIntFieldUpdateOperationsInput | number | null
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: CallTranscriptionUpdatekeywordsInput | string[]
    sentiment?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: EnumTranscriptionProviderFieldUpdateOperationsInput | $Enums.TranscriptionProvider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTranscriptionStatusFieldUpdateOperationsInput | $Enums.TranscriptionStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateManyUserInput = {
    id?: string
    tenantId: string
    contactId: string
    dealId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyAssignedUserInput = {
    id?: string
    tenantId: string
    contactId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentCreateManyUserInput = {
    id?: string
    ticketId: string
    portalCustomerId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserInvitationCreateManyInvitedByUserInput = {
    id?: string
    tenantId: string
    email: string
    role?: $Enums.UserRole
    token: string
    expiresAt: Date | string
    acceptedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyUserInput = {
    id?: string
    tenantId: string
    title?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramUserCreateManyUserInput = {
    id?: string
    telegramId: string
    username?: string | null
    firstName?: string | null
    lastName?: string | null
    avatarUrl?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TelegramLinkRequestCreateManyUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    usedAt?: Date | string | null
    createdAt?: Date | string
  }

  export type InteractionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInteractionsNestedInput
    contact?: ContactUpdateOneRequiredWithoutInteractionsNestedInput
    deal?: DealUpdateOneWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketsNestedInput
    deal?: DealUpdateOneWithoutTicketsNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutAssignedUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUpdateWithoutInvitedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutUserInvitationsNestedInput
  }

  export type UserInvitationUncheckedUpdateWithoutInvitedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInvitationUncheckedUpdateManyWithoutInvitedByUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUpdateManyWithoutConversationNestedInput
    tenant?: TenantUpdateOneRequiredWithoutConversationsNestedInput
  }

  export type ConversationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    telegramId?: StringFieldUpdateOperationsInput | string
    username?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramLinkRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramLinkRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TelegramLinkRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeadCreateManyContactInput = {
    id?: string
    tenantId: string
    title: string
    source: string
    status?: $Enums.LeadStatus
    value?: Decimal | DecimalJsLike | number | string | null
    notes?: string | null
    convertedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InteractionCreateManyContactInput = {
    id?: string
    tenantId: string
    dealId?: string | null
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManyContactInput = {
    id?: string
    tenantId: string
    leadId?: string | null
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyContactInput = {
    id?: string
    tenantId: string
    portalCustomerId?: string | null
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type CallLogCreateManyContactInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    dealId?: string | null
  }

  export type PortalCustomerCreateManyContactInput = {
    id?: string
    tenantId: string
    supabaseUserId?: string | null
    email: string
    name?: string | null
    avatarUrl?: string | null
    accessToken?: string | null
    fcmToken?: string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeadUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutLeadsNestedInput
    deals?: DealUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutLeadNestedInput
  }

  export type LeadUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    source?: StringFieldUpdateOperationsInput | string
    status?: EnumLeadStatusFieldUpdateOperationsInput | $Enums.LeadStatus
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    convertedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInteractionsNestedInput
    deal?: DealUpdateOneWithoutInteractionsNestedInput
    user?: UserUpdateOneWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketsNestedInput
    deal?: DealUpdateOneWithoutTicketsNestedInput
    assignedUser?: UserUpdateOneWithoutTicketsAssignedNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallLogUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallLogsNestedInput
    deal?: DealUpdateOneWithoutCallLogsNestedInput
    recording?: CallRecordingUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: CallRecordingUncheckedUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUncheckedUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PortalCustomerUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutPortalCustomersNestedInput
    tickets?: TicketUpdateManyWithoutPortalCustomerNestedInput
    ticketComments?: TicketCommentUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerUncheckedUpdateWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tickets?: TicketUncheckedUpdateManyWithoutPortalCustomerNestedInput
    ticketComments?: TicketCommentUncheckedUpdateManyWithoutPortalCustomerNestedInput
  }

  export type PortalCustomerUncheckedUpdateManyWithoutContactInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    supabaseUserId?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    pushSubscription?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateManyLeadInput = {
    id?: string
    tenantId: string
    contactId: string
    pipelineId: string
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutLeadInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    pipelineId?: StringFieldUpdateOperationsInput | string
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StageCreateManyPipelineInput = {
    id?: string
    name: string
    order: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealCreateManyPipelineInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    stageId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StageUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deals?: DealUncheckedUpdateManyWithoutStageNestedInput
  }

  export type StageUncheckedUpdateManyWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    stage?: StageUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutPipelineInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    stageId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DealCreateManyStageInput = {
    id?: string
    tenantId: string
    contactId: string
    leadId?: string | null
    pipelineId: string
    title: string
    description?: string | null
    value?: Decimal | DecimalJsLike | number | string | null
    probability?: Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DealUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutDealsNestedInput
    contact?: ContactUpdateOneRequiredWithoutDealsNestedInput
    lead?: LeadUpdateOneWithoutDealsNestedInput
    pipeline?: PipelineUpdateOneRequiredWithoutDealsNestedInput
    interactions?: InteractionUpdateManyWithoutDealNestedInput
    tickets?: TicketUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: InteractionUncheckedUpdateManyWithoutDealNestedInput
    tickets?: TicketUncheckedUpdateManyWithoutDealNestedInput
    callLogs?: CallLogUncheckedUpdateManyWithoutDealNestedInput
  }

  export type DealUncheckedUpdateManyWithoutStageInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    leadId?: NullableStringFieldUpdateOperationsInput | string | null
    pipelineId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    probability?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    expectedCloseDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionCreateManyDealInput = {
    id?: string
    tenantId: string
    contactId: string
    userId?: string | null
    type: $Enums.InteractionType
    subject?: string | null
    content: string
    dateTime?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCreateManyDealInput = {
    id?: string
    tenantId: string
    contactId: string
    portalCustomerId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type CallLogCreateManyDealInput = {
    id?: string
    tenantId: string
    roomName: string
    callerSupabaseId: string
    calleeSupabaseId: string
    direction?: $Enums.CallDirection
    status?: string
    duration?: number | null
    startTime?: Date | string
    endTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contactId?: string | null
  }

  export type InteractionUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutInteractionsNestedInput
    contact?: ContactUpdateOneRequiredWithoutInteractionsNestedInput
    user?: UserUpdateOneWithoutInteractionsNestedInput
  }

  export type InteractionUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InteractionUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInteractionTypeFieldUpdateOperationsInput | $Enums.InteractionType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    dateTime?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketsNestedInput
    assignedUser?: UserUpdateOneWithoutTicketsAssignedNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CallLogUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutCallLogsNestedInput
    contact?: ContactUpdateOneWithoutCallLogsNestedInput
    recording?: CallRecordingUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
    recording?: CallRecordingUncheckedUpdateOneWithoutCallLogNestedInput
    transcription?: CallTranscriptionUncheckedUpdateOneWithoutCallLogNestedInput
  }

  export type CallLogUncheckedUpdateManyWithoutDealInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    roomName?: StringFieldUpdateOperationsInput | string
    callerSupabaseId?: StringFieldUpdateOperationsInput | string
    calleeSupabaseId?: StringFieldUpdateOperationsInput | string
    direction?: EnumCallDirectionFieldUpdateOperationsInput | $Enums.CallDirection
    status?: StringFieldUpdateOperationsInput | string
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contactId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCommentCreateManyTicketInput = {
    id?: string
    userId?: string | null
    portalCustomerId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketCommentUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutTicketCommentsNestedInput
    portalCustomer?: PortalCustomerUpdateOneWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutTicketInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    portalCustomerId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCreateManyPortalCustomerInput = {
    id?: string
    tenantId: string
    contactId: string
    dealId?: string | null
    externalId?: string | null
    externalSystem?: string | null
    title: string
    description?: string | null
    status?: $Enums.TicketStatus
    priority?: $Enums.TicketPriority
    source?: $Enums.TicketSource
    submittedByPortalCustomer?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    assignedUserId?: string | null
  }

  export type TicketCommentCreateManyPortalCustomerInput = {
    id?: string
    ticketId: string
    userId?: string | null
    content: string
    authorName?: string | null
    isInternal?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TicketUpdateWithoutPortalCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneRequiredWithoutTicketsNestedInput
    contact?: ContactUpdateOneRequiredWithoutTicketsNestedInput
    deal?: DealUpdateOneWithoutTicketsNestedInput
    assignedUser?: UserUpdateOneWithoutTicketsAssignedNestedInput
    comments?: TicketCommentUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateWithoutPortalCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
    comments?: TicketCommentUncheckedUpdateManyWithoutTicketNestedInput
  }

  export type TicketUncheckedUpdateManyWithoutPortalCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    tenantId?: StringFieldUpdateOperationsInput | string
    contactId?: StringFieldUpdateOperationsInput | string
    dealId?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalSystem?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTicketStatusFieldUpdateOperationsInput | $Enums.TicketStatus
    priority?: EnumTicketPriorityFieldUpdateOperationsInput | $Enums.TicketPriority
    source?: EnumTicketSourceFieldUpdateOperationsInput | $Enums.TicketSource
    submittedByPortalCustomer?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignedUserId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TicketCommentUpdateWithoutPortalCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ticket?: TicketUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneWithoutTicketCommentsNestedInput
  }

  export type TicketCommentUncheckedUpdateWithoutPortalCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TicketCommentUncheckedUpdateManyWithoutPortalCustomerInput = {
    id?: StringFieldUpdateOperationsInput | string
    ticketId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    authorName?: NullableStringFieldUpdateOperationsInput | string | null
    isInternal?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}